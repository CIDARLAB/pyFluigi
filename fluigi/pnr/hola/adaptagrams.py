# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info

if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_adaptagrams')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_adaptagrams')
    _adaptagrams = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        import imp
        from os.path import dirname
        fp = None
        try:
            fp, pathname, description = imp.find_module('_adaptagrams', [dirname(__file__)])
        except ImportError:
            import _adaptagrams
            return _adaptagrams
        try:
            _mod = imp.load_module('_adaptagrams', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _adaptagrams = swig_import_helper()
    del swig_import_helper
else:
    import _adaptagrams
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

try:
    import weakref
    weakref_proxy = weakref.proxy
except __builtin__.Exception:
    weakref_proxy = lambda x: x


class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _adaptagrams.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self):
        return _adaptagrams.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _adaptagrams.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _adaptagrams.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _adaptagrams.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _adaptagrams.SwigPyIterator_equal(self, x)

    def copy(self):
        return _adaptagrams.SwigPyIterator_copy(self)

    def next(self):
        return _adaptagrams.SwigPyIterator_next(self)

    def __next__(self):
        return _adaptagrams.SwigPyIterator___next__(self)

    def previous(self):
        return _adaptagrams.SwigPyIterator_previous(self)

    def advance(self, n):
        return _adaptagrams.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _adaptagrams.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _adaptagrams.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _adaptagrams.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _adaptagrams.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _adaptagrams.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _adaptagrams.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _adaptagrams.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

SHARED_PTR_DISOWN = _adaptagrams.SHARED_PTR_DISOWN
class Chars(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Chars, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Chars, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _adaptagrams.Chars_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _adaptagrams.Chars___nonzero__(self)

    def __bool__(self):
        return _adaptagrams.Chars___bool__(self)

    def __len__(self):
        return _adaptagrams.Chars___len__(self)

    def __getslice__(self, i, j):
        return _adaptagrams.Chars___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _adaptagrams.Chars___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _adaptagrams.Chars___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _adaptagrams.Chars___delitem__(self, *args)

    def __getitem__(self, *args):
        return _adaptagrams.Chars___getitem__(self, *args)

    def __setitem__(self, *args):
        return _adaptagrams.Chars___setitem__(self, *args)

    def pop(self):
        return _adaptagrams.Chars_pop(self)

    def append(self, x):
        return _adaptagrams.Chars_append(self, x)

    def empty(self):
        return _adaptagrams.Chars_empty(self)

    def size(self):
        return _adaptagrams.Chars_size(self)

    def swap(self, v):
        return _adaptagrams.Chars_swap(self, v)

    def begin(self):
        return _adaptagrams.Chars_begin(self)

    def end(self):
        return _adaptagrams.Chars_end(self)

    def rbegin(self):
        return _adaptagrams.Chars_rbegin(self)

    def rend(self):
        return _adaptagrams.Chars_rend(self)

    def clear(self):
        return _adaptagrams.Chars_clear(self)

    def get_allocator(self):
        return _adaptagrams.Chars_get_allocator(self)

    def pop_back(self):
        return _adaptagrams.Chars_pop_back(self)

    def erase(self, *args):
        return _adaptagrams.Chars_erase(self, *args)

    def __init__(self, *args):
        this = _adaptagrams.new_Chars(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _adaptagrams.Chars_push_back(self, x)

    def front(self):
        return _adaptagrams.Chars_front(self)

    def back(self):
        return _adaptagrams.Chars_back(self)

    def assign(self, n, x):
        return _adaptagrams.Chars_assign(self, n, x)

    def resize(self, *args):
        return _adaptagrams.Chars_resize(self, *args)

    def insert(self, *args):
        return _adaptagrams.Chars_insert(self, *args)

    def reserve(self, n):
        return _adaptagrams.Chars_reserve(self, n)

    def capacity(self):
        return _adaptagrams.Chars_capacity(self)
    __swig_destroy__ = _adaptagrams.delete_Chars
    __del__ = lambda self: None
Chars_swigregister = _adaptagrams.Chars_swigregister
Chars_swigregister(Chars)

class Unsigneds(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Unsigneds, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Unsigneds, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _adaptagrams.Unsigneds_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _adaptagrams.Unsigneds___nonzero__(self)

    def __bool__(self):
        return _adaptagrams.Unsigneds___bool__(self)

    def __len__(self):
        return _adaptagrams.Unsigneds___len__(self)

    def __getslice__(self, i, j):
        return _adaptagrams.Unsigneds___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _adaptagrams.Unsigneds___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _adaptagrams.Unsigneds___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _adaptagrams.Unsigneds___delitem__(self, *args)

    def __getitem__(self, *args):
        return _adaptagrams.Unsigneds___getitem__(self, *args)

    def __setitem__(self, *args):
        return _adaptagrams.Unsigneds___setitem__(self, *args)

    def pop(self):
        return _adaptagrams.Unsigneds_pop(self)

    def append(self, x):
        return _adaptagrams.Unsigneds_append(self, x)

    def empty(self):
        return _adaptagrams.Unsigneds_empty(self)

    def size(self):
        return _adaptagrams.Unsigneds_size(self)

    def swap(self, v):
        return _adaptagrams.Unsigneds_swap(self, v)

    def begin(self):
        return _adaptagrams.Unsigneds_begin(self)

    def end(self):
        return _adaptagrams.Unsigneds_end(self)

    def rbegin(self):
        return _adaptagrams.Unsigneds_rbegin(self)

    def rend(self):
        return _adaptagrams.Unsigneds_rend(self)

    def clear(self):
        return _adaptagrams.Unsigneds_clear(self)

    def get_allocator(self):
        return _adaptagrams.Unsigneds_get_allocator(self)

    def pop_back(self):
        return _adaptagrams.Unsigneds_pop_back(self)

    def erase(self, *args):
        return _adaptagrams.Unsigneds_erase(self, *args)

    def __init__(self, *args):
        this = _adaptagrams.new_Unsigneds(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _adaptagrams.Unsigneds_push_back(self, x)

    def front(self):
        return _adaptagrams.Unsigneds_front(self)

    def back(self):
        return _adaptagrams.Unsigneds_back(self)

    def assign(self, n, x):
        return _adaptagrams.Unsigneds_assign(self, n, x)

    def resize(self, *args):
        return _adaptagrams.Unsigneds_resize(self, *args)

    def insert(self, *args):
        return _adaptagrams.Unsigneds_insert(self, *args)

    def reserve(self, n):
        return _adaptagrams.Unsigneds_reserve(self, n)

    def capacity(self):
        return _adaptagrams.Unsigneds_capacity(self)
    __swig_destroy__ = _adaptagrams.delete_Unsigneds
    __del__ = lambda self: None
Unsigneds_swigregister = _adaptagrams.Unsigneds_swigregister
Unsigneds_swigregister(Unsigneds)

class Doubles(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Doubles, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Doubles, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _adaptagrams.Doubles_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _adaptagrams.Doubles___nonzero__(self)

    def __bool__(self):
        return _adaptagrams.Doubles___bool__(self)

    def __len__(self):
        return _adaptagrams.Doubles___len__(self)

    def __getslice__(self, i, j):
        return _adaptagrams.Doubles___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _adaptagrams.Doubles___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _adaptagrams.Doubles___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _adaptagrams.Doubles___delitem__(self, *args)

    def __getitem__(self, *args):
        return _adaptagrams.Doubles___getitem__(self, *args)

    def __setitem__(self, *args):
        return _adaptagrams.Doubles___setitem__(self, *args)

    def pop(self):
        return _adaptagrams.Doubles_pop(self)

    def append(self, x):
        return _adaptagrams.Doubles_append(self, x)

    def empty(self):
        return _adaptagrams.Doubles_empty(self)

    def size(self):
        return _adaptagrams.Doubles_size(self)

    def swap(self, v):
        return _adaptagrams.Doubles_swap(self, v)

    def begin(self):
        return _adaptagrams.Doubles_begin(self)

    def end(self):
        return _adaptagrams.Doubles_end(self)

    def rbegin(self):
        return _adaptagrams.Doubles_rbegin(self)

    def rend(self):
        return _adaptagrams.Doubles_rend(self)

    def clear(self):
        return _adaptagrams.Doubles_clear(self)

    def get_allocator(self):
        return _adaptagrams.Doubles_get_allocator(self)

    def pop_back(self):
        return _adaptagrams.Doubles_pop_back(self)

    def erase(self, *args):
        return _adaptagrams.Doubles_erase(self, *args)

    def __init__(self, *args):
        this = _adaptagrams.new_Doubles(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _adaptagrams.Doubles_push_back(self, x)

    def front(self):
        return _adaptagrams.Doubles_front(self)

    def back(self):
        return _adaptagrams.Doubles_back(self)

    def assign(self, n, x):
        return _adaptagrams.Doubles_assign(self, n, x)

    def resize(self, *args):
        return _adaptagrams.Doubles_resize(self, *args)

    def insert(self, *args):
        return _adaptagrams.Doubles_insert(self, *args)

    def reserve(self, n):
        return _adaptagrams.Doubles_reserve(self, n)

    def capacity(self):
        return _adaptagrams.Doubles_capacity(self)
    __swig_destroy__ = _adaptagrams.delete_Doubles
    __del__ = lambda self: None
Doubles_swigregister = _adaptagrams.Doubles_swigregister
Doubles_swigregister(Doubles)

class UnsatisfiableConstraintInfoPtrs(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, UnsatisfiableConstraintInfoPtrs, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, UnsatisfiableConstraintInfoPtrs, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _adaptagrams.UnsatisfiableConstraintInfoPtrs_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _adaptagrams.UnsatisfiableConstraintInfoPtrs___nonzero__(self)

    def __bool__(self):
        return _adaptagrams.UnsatisfiableConstraintInfoPtrs___bool__(self)

    def __len__(self):
        return _adaptagrams.UnsatisfiableConstraintInfoPtrs___len__(self)

    def __getslice__(self, i, j):
        return _adaptagrams.UnsatisfiableConstraintInfoPtrs___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _adaptagrams.UnsatisfiableConstraintInfoPtrs___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _adaptagrams.UnsatisfiableConstraintInfoPtrs___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _adaptagrams.UnsatisfiableConstraintInfoPtrs___delitem__(self, *args)

    def __getitem__(self, *args):
        return _adaptagrams.UnsatisfiableConstraintInfoPtrs___getitem__(self, *args)

    def __setitem__(self, *args):
        return _adaptagrams.UnsatisfiableConstraintInfoPtrs___setitem__(self, *args)

    def pop(self):
        return _adaptagrams.UnsatisfiableConstraintInfoPtrs_pop(self)

    def append(self, x):
        return _adaptagrams.UnsatisfiableConstraintInfoPtrs_append(self, x)

    def empty(self):
        return _adaptagrams.UnsatisfiableConstraintInfoPtrs_empty(self)

    def size(self):
        return _adaptagrams.UnsatisfiableConstraintInfoPtrs_size(self)

    def swap(self, v):
        return _adaptagrams.UnsatisfiableConstraintInfoPtrs_swap(self, v)

    def begin(self):
        return _adaptagrams.UnsatisfiableConstraintInfoPtrs_begin(self)

    def end(self):
        return _adaptagrams.UnsatisfiableConstraintInfoPtrs_end(self)

    def rbegin(self):
        return _adaptagrams.UnsatisfiableConstraintInfoPtrs_rbegin(self)

    def rend(self):
        return _adaptagrams.UnsatisfiableConstraintInfoPtrs_rend(self)

    def clear(self):
        return _adaptagrams.UnsatisfiableConstraintInfoPtrs_clear(self)

    def get_allocator(self):
        return _adaptagrams.UnsatisfiableConstraintInfoPtrs_get_allocator(self)

    def pop_back(self):
        return _adaptagrams.UnsatisfiableConstraintInfoPtrs_pop_back(self)

    def erase(self, *args):
        return _adaptagrams.UnsatisfiableConstraintInfoPtrs_erase(self, *args)

    def __init__(self, *args):
        this = _adaptagrams.new_UnsatisfiableConstraintInfoPtrs(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _adaptagrams.UnsatisfiableConstraintInfoPtrs_push_back(self, x)

    def front(self):
        return _adaptagrams.UnsatisfiableConstraintInfoPtrs_front(self)

    def back(self):
        return _adaptagrams.UnsatisfiableConstraintInfoPtrs_back(self)

    def assign(self, n, x):
        return _adaptagrams.UnsatisfiableConstraintInfoPtrs_assign(self, n, x)

    def resize(self, *args):
        return _adaptagrams.UnsatisfiableConstraintInfoPtrs_resize(self, *args)

    def insert(self, *args):
        return _adaptagrams.UnsatisfiableConstraintInfoPtrs_insert(self, *args)

    def reserve(self, n):
        return _adaptagrams.UnsatisfiableConstraintInfoPtrs_reserve(self, n)

    def capacity(self):
        return _adaptagrams.UnsatisfiableConstraintInfoPtrs_capacity(self)
    __swig_destroy__ = _adaptagrams.delete_UnsatisfiableConstraintInfoPtrs
    __del__ = lambda self: None
UnsatisfiableConstraintInfoPtrs_swigregister = _adaptagrams.UnsatisfiableConstraintInfoPtrs_swigregister
UnsatisfiableConstraintInfoPtrs_swigregister(UnsatisfiableConstraintInfoPtrs)

class ColaEdge(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ColaEdge, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ColaEdge, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _adaptagrams.new_ColaEdge(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["first"] = _adaptagrams.ColaEdge_first_set
    __swig_getmethods__["first"] = _adaptagrams.ColaEdge_first_get
    if _newclass:
        first = _swig_property(_adaptagrams.ColaEdge_first_get, _adaptagrams.ColaEdge_first_set)
    __swig_setmethods__["second"] = _adaptagrams.ColaEdge_second_set
    __swig_getmethods__["second"] = _adaptagrams.ColaEdge_second_get
    if _newclass:
        second = _swig_property(_adaptagrams.ColaEdge_second_get, _adaptagrams.ColaEdge_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _adaptagrams.delete_ColaEdge
    __del__ = lambda self: None
ColaEdge_swigregister = _adaptagrams.ColaEdge_swigregister
ColaEdge_swigregister(ColaEdge)

class ColaEdges(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ColaEdges, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ColaEdges, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _adaptagrams.ColaEdges_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _adaptagrams.ColaEdges___nonzero__(self)

    def __bool__(self):
        return _adaptagrams.ColaEdges___bool__(self)

    def __len__(self):
        return _adaptagrams.ColaEdges___len__(self)

    def __getslice__(self, i, j):
        return _adaptagrams.ColaEdges___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _adaptagrams.ColaEdges___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _adaptagrams.ColaEdges___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _adaptagrams.ColaEdges___delitem__(self, *args)

    def __getitem__(self, *args):
        return _adaptagrams.ColaEdges___getitem__(self, *args)

    def __setitem__(self, *args):
        return _adaptagrams.ColaEdges___setitem__(self, *args)

    def pop(self):
        return _adaptagrams.ColaEdges_pop(self)

    def append(self, x):
        return _adaptagrams.ColaEdges_append(self, x)

    def empty(self):
        return _adaptagrams.ColaEdges_empty(self)

    def size(self):
        return _adaptagrams.ColaEdges_size(self)

    def swap(self, v):
        return _adaptagrams.ColaEdges_swap(self, v)

    def begin(self):
        return _adaptagrams.ColaEdges_begin(self)

    def end(self):
        return _adaptagrams.ColaEdges_end(self)

    def rbegin(self):
        return _adaptagrams.ColaEdges_rbegin(self)

    def rend(self):
        return _adaptagrams.ColaEdges_rend(self)

    def clear(self):
        return _adaptagrams.ColaEdges_clear(self)

    def get_allocator(self):
        return _adaptagrams.ColaEdges_get_allocator(self)

    def pop_back(self):
        return _adaptagrams.ColaEdges_pop_back(self)

    def erase(self, *args):
        return _adaptagrams.ColaEdges_erase(self, *args)

    def __init__(self, *args):
        this = _adaptagrams.new_ColaEdges(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _adaptagrams.ColaEdges_push_back(self, x)

    def front(self):
        return _adaptagrams.ColaEdges_front(self)

    def back(self):
        return _adaptagrams.ColaEdges_back(self)

    def assign(self, n, x):
        return _adaptagrams.ColaEdges_assign(self, n, x)

    def resize(self, *args):
        return _adaptagrams.ColaEdges_resize(self, *args)

    def insert(self, *args):
        return _adaptagrams.ColaEdges_insert(self, *args)

    def reserve(self, n):
        return _adaptagrams.ColaEdges_reserve(self, n)

    def capacity(self):
        return _adaptagrams.ColaEdges_capacity(self)
    __swig_destroy__ = _adaptagrams.delete_ColaEdges
    __del__ = lambda self: None
ColaEdges_swigregister = _adaptagrams.ColaEdges_swigregister
ColaEdges_swigregister(ColaEdges)

class RectanglePtrs(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RectanglePtrs, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RectanglePtrs, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _adaptagrams.RectanglePtrs_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _adaptagrams.RectanglePtrs___nonzero__(self)

    def __bool__(self):
        return _adaptagrams.RectanglePtrs___bool__(self)

    def __len__(self):
        return _adaptagrams.RectanglePtrs___len__(self)

    def __getslice__(self, i, j):
        return _adaptagrams.RectanglePtrs___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _adaptagrams.RectanglePtrs___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _adaptagrams.RectanglePtrs___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _adaptagrams.RectanglePtrs___delitem__(self, *args)

    def __getitem__(self, *args):
        return _adaptagrams.RectanglePtrs___getitem__(self, *args)

    def __setitem__(self, *args):
        return _adaptagrams.RectanglePtrs___setitem__(self, *args)

    def pop(self):
        return _adaptagrams.RectanglePtrs_pop(self)

    def append(self, x):
        return _adaptagrams.RectanglePtrs_append(self, x)

    def empty(self):
        return _adaptagrams.RectanglePtrs_empty(self)

    def size(self):
        return _adaptagrams.RectanglePtrs_size(self)

    def swap(self, v):
        return _adaptagrams.RectanglePtrs_swap(self, v)

    def begin(self):
        return _adaptagrams.RectanglePtrs_begin(self)

    def end(self):
        return _adaptagrams.RectanglePtrs_end(self)

    def rbegin(self):
        return _adaptagrams.RectanglePtrs_rbegin(self)

    def rend(self):
        return _adaptagrams.RectanglePtrs_rend(self)

    def clear(self):
        return _adaptagrams.RectanglePtrs_clear(self)

    def get_allocator(self):
        return _adaptagrams.RectanglePtrs_get_allocator(self)

    def pop_back(self):
        return _adaptagrams.RectanglePtrs_pop_back(self)

    def erase(self, *args):
        return _adaptagrams.RectanglePtrs_erase(self, *args)

    def __init__(self, *args):
        this = _adaptagrams.new_RectanglePtrs(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _adaptagrams.RectanglePtrs_push_back(self, x)

    def front(self):
        return _adaptagrams.RectanglePtrs_front(self)

    def back(self):
        return _adaptagrams.RectanglePtrs_back(self)

    def assign(self, n, x):
        return _adaptagrams.RectanglePtrs_assign(self, n, x)

    def resize(self, *args):
        return _adaptagrams.RectanglePtrs_resize(self, *args)

    def insert(self, *args):
        return _adaptagrams.RectanglePtrs_insert(self, *args)

    def reserve(self, n):
        return _adaptagrams.RectanglePtrs_reserve(self, n)

    def capacity(self):
        return _adaptagrams.RectanglePtrs_capacity(self)
    __swig_destroy__ = _adaptagrams.delete_RectanglePtrs
    __del__ = lambda self: None
RectanglePtrs_swigregister = _adaptagrams.RectanglePtrs_swigregister
RectanglePtrs_swigregister(RectanglePtrs)

class CompoundConstraintPtrs(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CompoundConstraintPtrs, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CompoundConstraintPtrs, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _adaptagrams.CompoundConstraintPtrs_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _adaptagrams.CompoundConstraintPtrs___nonzero__(self)

    def __bool__(self):
        return _adaptagrams.CompoundConstraintPtrs___bool__(self)

    def __len__(self):
        return _adaptagrams.CompoundConstraintPtrs___len__(self)

    def __getslice__(self, i, j):
        return _adaptagrams.CompoundConstraintPtrs___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _adaptagrams.CompoundConstraintPtrs___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _adaptagrams.CompoundConstraintPtrs___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _adaptagrams.CompoundConstraintPtrs___delitem__(self, *args)

    def __getitem__(self, *args):
        return _adaptagrams.CompoundConstraintPtrs___getitem__(self, *args)

    def __setitem__(self, *args):
        return _adaptagrams.CompoundConstraintPtrs___setitem__(self, *args)

    def pop(self):
        return _adaptagrams.CompoundConstraintPtrs_pop(self)

    def append(self, x):
        return _adaptagrams.CompoundConstraintPtrs_append(self, x)

    def empty(self):
        return _adaptagrams.CompoundConstraintPtrs_empty(self)

    def size(self):
        return _adaptagrams.CompoundConstraintPtrs_size(self)

    def swap(self, v):
        return _adaptagrams.CompoundConstraintPtrs_swap(self, v)

    def begin(self):
        return _adaptagrams.CompoundConstraintPtrs_begin(self)

    def end(self):
        return _adaptagrams.CompoundConstraintPtrs_end(self)

    def rbegin(self):
        return _adaptagrams.CompoundConstraintPtrs_rbegin(self)

    def rend(self):
        return _adaptagrams.CompoundConstraintPtrs_rend(self)

    def clear(self):
        return _adaptagrams.CompoundConstraintPtrs_clear(self)

    def get_allocator(self):
        return _adaptagrams.CompoundConstraintPtrs_get_allocator(self)

    def pop_back(self):
        return _adaptagrams.CompoundConstraintPtrs_pop_back(self)

    def erase(self, *args):
        return _adaptagrams.CompoundConstraintPtrs_erase(self, *args)

    def __init__(self, *args):
        this = _adaptagrams.new_CompoundConstraintPtrs(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _adaptagrams.CompoundConstraintPtrs_push_back(self, x)

    def front(self):
        return _adaptagrams.CompoundConstraintPtrs_front(self)

    def back(self):
        return _adaptagrams.CompoundConstraintPtrs_back(self)

    def assign(self, n, x):
        return _adaptagrams.CompoundConstraintPtrs_assign(self, n, x)

    def resize(self, *args):
        return _adaptagrams.CompoundConstraintPtrs_resize(self, *args)

    def insert(self, *args):
        return _adaptagrams.CompoundConstraintPtrs_insert(self, *args)

    def reserve(self, n):
        return _adaptagrams.CompoundConstraintPtrs_reserve(self, n)

    def capacity(self):
        return _adaptagrams.CompoundConstraintPtrs_capacity(self)
    __swig_destroy__ = _adaptagrams.delete_CompoundConstraintPtrs
    __del__ = lambda self: None
CompoundConstraintPtrs_swigregister = _adaptagrams.CompoundConstraintPtrs_swigregister
CompoundConstraintPtrs_swigregister(CompoundConstraintPtrs)

class ColaLocks(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ColaLocks, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ColaLocks, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _adaptagrams.ColaLocks_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _adaptagrams.ColaLocks___nonzero__(self)

    def __bool__(self):
        return _adaptagrams.ColaLocks___bool__(self)

    def __len__(self):
        return _adaptagrams.ColaLocks___len__(self)

    def __getslice__(self, i, j):
        return _adaptagrams.ColaLocks___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _adaptagrams.ColaLocks___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _adaptagrams.ColaLocks___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _adaptagrams.ColaLocks___delitem__(self, *args)

    def __getitem__(self, *args):
        return _adaptagrams.ColaLocks___getitem__(self, *args)

    def __setitem__(self, *args):
        return _adaptagrams.ColaLocks___setitem__(self, *args)

    def pop(self):
        return _adaptagrams.ColaLocks_pop(self)

    def append(self, x):
        return _adaptagrams.ColaLocks_append(self, x)

    def empty(self):
        return _adaptagrams.ColaLocks_empty(self)

    def size(self):
        return _adaptagrams.ColaLocks_size(self)

    def swap(self, v):
        return _adaptagrams.ColaLocks_swap(self, v)

    def begin(self):
        return _adaptagrams.ColaLocks_begin(self)

    def end(self):
        return _adaptagrams.ColaLocks_end(self)

    def rbegin(self):
        return _adaptagrams.ColaLocks_rbegin(self)

    def rend(self):
        return _adaptagrams.ColaLocks_rend(self)

    def clear(self):
        return _adaptagrams.ColaLocks_clear(self)

    def get_allocator(self):
        return _adaptagrams.ColaLocks_get_allocator(self)

    def pop_back(self):
        return _adaptagrams.ColaLocks_pop_back(self)

    def erase(self, *args):
        return _adaptagrams.ColaLocks_erase(self, *args)

    def __init__(self, *args):
        this = _adaptagrams.new_ColaLocks(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _adaptagrams.ColaLocks_push_back(self, x)

    def front(self):
        return _adaptagrams.ColaLocks_front(self)

    def back(self):
        return _adaptagrams.ColaLocks_back(self)

    def assign(self, n, x):
        return _adaptagrams.ColaLocks_assign(self, n, x)

    def resize(self, *args):
        return _adaptagrams.ColaLocks_resize(self, *args)

    def insert(self, *args):
        return _adaptagrams.ColaLocks_insert(self, *args)

    def reserve(self, n):
        return _adaptagrams.ColaLocks_reserve(self, n)

    def capacity(self):
        return _adaptagrams.ColaLocks_capacity(self)
    __swig_destroy__ = _adaptagrams.delete_ColaLocks
    __del__ = lambda self: None
ColaLocks_swigregister = _adaptagrams.ColaLocks_swigregister
ColaLocks_swigregister(ColaLocks)

class ColaResizes(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ColaResizes, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ColaResizes, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _adaptagrams.ColaResizes_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _adaptagrams.ColaResizes___nonzero__(self)

    def __bool__(self):
        return _adaptagrams.ColaResizes___bool__(self)

    def __len__(self):
        return _adaptagrams.ColaResizes___len__(self)

    def __getslice__(self, i, j):
        return _adaptagrams.ColaResizes___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _adaptagrams.ColaResizes___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _adaptagrams.ColaResizes___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _adaptagrams.ColaResizes___delitem__(self, *args)

    def __getitem__(self, *args):
        return _adaptagrams.ColaResizes___getitem__(self, *args)

    def __setitem__(self, *args):
        return _adaptagrams.ColaResizes___setitem__(self, *args)

    def pop(self):
        return _adaptagrams.ColaResizes_pop(self)

    def append(self, x):
        return _adaptagrams.ColaResizes_append(self, x)

    def empty(self):
        return _adaptagrams.ColaResizes_empty(self)

    def size(self):
        return _adaptagrams.ColaResizes_size(self)

    def swap(self, v):
        return _adaptagrams.ColaResizes_swap(self, v)

    def begin(self):
        return _adaptagrams.ColaResizes_begin(self)

    def end(self):
        return _adaptagrams.ColaResizes_end(self)

    def rbegin(self):
        return _adaptagrams.ColaResizes_rbegin(self)

    def rend(self):
        return _adaptagrams.ColaResizes_rend(self)

    def clear(self):
        return _adaptagrams.ColaResizes_clear(self)

    def get_allocator(self):
        return _adaptagrams.ColaResizes_get_allocator(self)

    def pop_back(self):
        return _adaptagrams.ColaResizes_pop_back(self)

    def erase(self, *args):
        return _adaptagrams.ColaResizes_erase(self, *args)

    def __init__(self, *args):
        this = _adaptagrams.new_ColaResizes(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _adaptagrams.ColaResizes_push_back(self, x)

    def front(self):
        return _adaptagrams.ColaResizes_front(self)

    def back(self):
        return _adaptagrams.ColaResizes_back(self)

    def assign(self, n, x):
        return _adaptagrams.ColaResizes_assign(self, n, x)

    def resize(self, *args):
        return _adaptagrams.ColaResizes_resize(self, *args)

    def insert(self, *args):
        return _adaptagrams.ColaResizes_insert(self, *args)

    def reserve(self, n):
        return _adaptagrams.ColaResizes_reserve(self, n)

    def capacity(self):
        return _adaptagrams.ColaResizes_capacity(self)
    __swig_destroy__ = _adaptagrams.delete_ColaResizes
    __del__ = lambda self: None
ColaResizes_swigregister = _adaptagrams.ColaResizes_swigregister
ColaResizes_swigregister(ColaResizes)

class ColaDesiredPositions(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ColaDesiredPositions, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ColaDesiredPositions, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _adaptagrams.ColaDesiredPositions_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _adaptagrams.ColaDesiredPositions___nonzero__(self)

    def __bool__(self):
        return _adaptagrams.ColaDesiredPositions___bool__(self)

    def __len__(self):
        return _adaptagrams.ColaDesiredPositions___len__(self)

    def __getslice__(self, i, j):
        return _adaptagrams.ColaDesiredPositions___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _adaptagrams.ColaDesiredPositions___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _adaptagrams.ColaDesiredPositions___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _adaptagrams.ColaDesiredPositions___delitem__(self, *args)

    def __getitem__(self, *args):
        return _adaptagrams.ColaDesiredPositions___getitem__(self, *args)

    def __setitem__(self, *args):
        return _adaptagrams.ColaDesiredPositions___setitem__(self, *args)

    def pop(self):
        return _adaptagrams.ColaDesiredPositions_pop(self)

    def append(self, x):
        return _adaptagrams.ColaDesiredPositions_append(self, x)

    def empty(self):
        return _adaptagrams.ColaDesiredPositions_empty(self)

    def size(self):
        return _adaptagrams.ColaDesiredPositions_size(self)

    def swap(self, v):
        return _adaptagrams.ColaDesiredPositions_swap(self, v)

    def begin(self):
        return _adaptagrams.ColaDesiredPositions_begin(self)

    def end(self):
        return _adaptagrams.ColaDesiredPositions_end(self)

    def rbegin(self):
        return _adaptagrams.ColaDesiredPositions_rbegin(self)

    def rend(self):
        return _adaptagrams.ColaDesiredPositions_rend(self)

    def clear(self):
        return _adaptagrams.ColaDesiredPositions_clear(self)

    def get_allocator(self):
        return _adaptagrams.ColaDesiredPositions_get_allocator(self)

    def pop_back(self):
        return _adaptagrams.ColaDesiredPositions_pop_back(self)

    def erase(self, *args):
        return _adaptagrams.ColaDesiredPositions_erase(self, *args)

    def __init__(self, *args):
        this = _adaptagrams.new_ColaDesiredPositions(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _adaptagrams.ColaDesiredPositions_push_back(self, x)

    def front(self):
        return _adaptagrams.ColaDesiredPositions_front(self)

    def back(self):
        return _adaptagrams.ColaDesiredPositions_back(self)

    def assign(self, n, x):
        return _adaptagrams.ColaDesiredPositions_assign(self, n, x)

    def resize(self, *args):
        return _adaptagrams.ColaDesiredPositions_resize(self, *args)

    def insert(self, *args):
        return _adaptagrams.ColaDesiredPositions_insert(self, *args)

    def reserve(self, n):
        return _adaptagrams.ColaDesiredPositions_reserve(self, n)

    def capacity(self):
        return _adaptagrams.ColaDesiredPositions_capacity(self)
    __swig_destroy__ = _adaptagrams.delete_ColaDesiredPositions
    __del__ = lambda self: None
ColaDesiredPositions_swigregister = _adaptagrams.ColaDesiredPositions_swigregister
ColaDesiredPositions_swigregister(ColaDesiredPositions)

class TopologyEdgePointPtrs(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TopologyEdgePointPtrs, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TopologyEdgePointPtrs, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _adaptagrams.TopologyEdgePointPtrs_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _adaptagrams.TopologyEdgePointPtrs___nonzero__(self)

    def __bool__(self):
        return _adaptagrams.TopologyEdgePointPtrs___bool__(self)

    def __len__(self):
        return _adaptagrams.TopologyEdgePointPtrs___len__(self)

    def __getslice__(self, i, j):
        return _adaptagrams.TopologyEdgePointPtrs___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _adaptagrams.TopologyEdgePointPtrs___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _adaptagrams.TopologyEdgePointPtrs___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _adaptagrams.TopologyEdgePointPtrs___delitem__(self, *args)

    def __getitem__(self, *args):
        return _adaptagrams.TopologyEdgePointPtrs___getitem__(self, *args)

    def __setitem__(self, *args):
        return _adaptagrams.TopologyEdgePointPtrs___setitem__(self, *args)

    def pop(self):
        return _adaptagrams.TopologyEdgePointPtrs_pop(self)

    def append(self, x):
        return _adaptagrams.TopologyEdgePointPtrs_append(self, x)

    def empty(self):
        return _adaptagrams.TopologyEdgePointPtrs_empty(self)

    def size(self):
        return _adaptagrams.TopologyEdgePointPtrs_size(self)

    def swap(self, v):
        return _adaptagrams.TopologyEdgePointPtrs_swap(self, v)

    def begin(self):
        return _adaptagrams.TopologyEdgePointPtrs_begin(self)

    def end(self):
        return _adaptagrams.TopologyEdgePointPtrs_end(self)

    def rbegin(self):
        return _adaptagrams.TopologyEdgePointPtrs_rbegin(self)

    def rend(self):
        return _adaptagrams.TopologyEdgePointPtrs_rend(self)

    def clear(self):
        return _adaptagrams.TopologyEdgePointPtrs_clear(self)

    def get_allocator(self):
        return _adaptagrams.TopologyEdgePointPtrs_get_allocator(self)

    def pop_back(self):
        return _adaptagrams.TopologyEdgePointPtrs_pop_back(self)

    def erase(self, *args):
        return _adaptagrams.TopologyEdgePointPtrs_erase(self, *args)

    def __init__(self, *args):
        this = _adaptagrams.new_TopologyEdgePointPtrs(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _adaptagrams.TopologyEdgePointPtrs_push_back(self, x)

    def front(self):
        return _adaptagrams.TopologyEdgePointPtrs_front(self)

    def back(self):
        return _adaptagrams.TopologyEdgePointPtrs_back(self)

    def assign(self, n, x):
        return _adaptagrams.TopologyEdgePointPtrs_assign(self, n, x)

    def resize(self, *args):
        return _adaptagrams.TopologyEdgePointPtrs_resize(self, *args)

    def insert(self, *args):
        return _adaptagrams.TopologyEdgePointPtrs_insert(self, *args)

    def reserve(self, n):
        return _adaptagrams.TopologyEdgePointPtrs_reserve(self, n)

    def capacity(self):
        return _adaptagrams.TopologyEdgePointPtrs_capacity(self)
    __swig_destroy__ = _adaptagrams.delete_TopologyEdgePointPtrs
    __del__ = lambda self: None
TopologyEdgePointPtrs_swigregister = _adaptagrams.TopologyEdgePointPtrs_swigregister
TopologyEdgePointPtrs_swigregister(TopologyEdgePointPtrs)

class TopologyEdgePointConstPtrs(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TopologyEdgePointConstPtrs, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TopologyEdgePointConstPtrs, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _adaptagrams.TopologyEdgePointConstPtrs_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _adaptagrams.TopologyEdgePointConstPtrs___nonzero__(self)

    def __bool__(self):
        return _adaptagrams.TopologyEdgePointConstPtrs___bool__(self)

    def __len__(self):
        return _adaptagrams.TopologyEdgePointConstPtrs___len__(self)

    def __getslice__(self, i, j):
        return _adaptagrams.TopologyEdgePointConstPtrs___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _adaptagrams.TopologyEdgePointConstPtrs___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _adaptagrams.TopologyEdgePointConstPtrs___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _adaptagrams.TopologyEdgePointConstPtrs___delitem__(self, *args)

    def __getitem__(self, *args):
        return _adaptagrams.TopologyEdgePointConstPtrs___getitem__(self, *args)

    def __setitem__(self, *args):
        return _adaptagrams.TopologyEdgePointConstPtrs___setitem__(self, *args)

    def pop(self):
        return _adaptagrams.TopologyEdgePointConstPtrs_pop(self)

    def append(self, x):
        return _adaptagrams.TopologyEdgePointConstPtrs_append(self, x)

    def empty(self):
        return _adaptagrams.TopologyEdgePointConstPtrs_empty(self)

    def size(self):
        return _adaptagrams.TopologyEdgePointConstPtrs_size(self)

    def swap(self, v):
        return _adaptagrams.TopologyEdgePointConstPtrs_swap(self, v)

    def begin(self):
        return _adaptagrams.TopologyEdgePointConstPtrs_begin(self)

    def end(self):
        return _adaptagrams.TopologyEdgePointConstPtrs_end(self)

    def rbegin(self):
        return _adaptagrams.TopologyEdgePointConstPtrs_rbegin(self)

    def rend(self):
        return _adaptagrams.TopologyEdgePointConstPtrs_rend(self)

    def clear(self):
        return _adaptagrams.TopologyEdgePointConstPtrs_clear(self)

    def get_allocator(self):
        return _adaptagrams.TopologyEdgePointConstPtrs_get_allocator(self)

    def pop_back(self):
        return _adaptagrams.TopologyEdgePointConstPtrs_pop_back(self)

    def erase(self, *args):
        return _adaptagrams.TopologyEdgePointConstPtrs_erase(self, *args)

    def __init__(self, *args):
        this = _adaptagrams.new_TopologyEdgePointConstPtrs(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _adaptagrams.TopologyEdgePointConstPtrs_push_back(self, x)

    def front(self):
        return _adaptagrams.TopologyEdgePointConstPtrs_front(self)

    def back(self):
        return _adaptagrams.TopologyEdgePointConstPtrs_back(self)

    def assign(self, n, x):
        return _adaptagrams.TopologyEdgePointConstPtrs_assign(self, n, x)

    def resize(self, *args):
        return _adaptagrams.TopologyEdgePointConstPtrs_resize(self, *args)

    def insert(self, *args):
        return _adaptagrams.TopologyEdgePointConstPtrs_insert(self, *args)

    def reserve(self, n):
        return _adaptagrams.TopologyEdgePointConstPtrs_reserve(self, n)

    def capacity(self):
        return _adaptagrams.TopologyEdgePointConstPtrs_capacity(self)
    __swig_destroy__ = _adaptagrams.delete_TopologyEdgePointConstPtrs
    __del__ = lambda self: None
TopologyEdgePointConstPtrs_swigregister = _adaptagrams.TopologyEdgePointConstPtrs_swigregister
TopologyEdgePointConstPtrs_swigregister(TopologyEdgePointConstPtrs)

class TopologyEdgePtrs(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TopologyEdgePtrs, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TopologyEdgePtrs, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _adaptagrams.TopologyEdgePtrs_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _adaptagrams.TopologyEdgePtrs___nonzero__(self)

    def __bool__(self):
        return _adaptagrams.TopologyEdgePtrs___bool__(self)

    def __len__(self):
        return _adaptagrams.TopologyEdgePtrs___len__(self)

    def __getslice__(self, i, j):
        return _adaptagrams.TopologyEdgePtrs___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _adaptagrams.TopologyEdgePtrs___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _adaptagrams.TopologyEdgePtrs___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _adaptagrams.TopologyEdgePtrs___delitem__(self, *args)

    def __getitem__(self, *args):
        return _adaptagrams.TopologyEdgePtrs___getitem__(self, *args)

    def __setitem__(self, *args):
        return _adaptagrams.TopologyEdgePtrs___setitem__(self, *args)

    def pop(self):
        return _adaptagrams.TopologyEdgePtrs_pop(self)

    def append(self, x):
        return _adaptagrams.TopologyEdgePtrs_append(self, x)

    def empty(self):
        return _adaptagrams.TopologyEdgePtrs_empty(self)

    def size(self):
        return _adaptagrams.TopologyEdgePtrs_size(self)

    def swap(self, v):
        return _adaptagrams.TopologyEdgePtrs_swap(self, v)

    def begin(self):
        return _adaptagrams.TopologyEdgePtrs_begin(self)

    def end(self):
        return _adaptagrams.TopologyEdgePtrs_end(self)

    def rbegin(self):
        return _adaptagrams.TopologyEdgePtrs_rbegin(self)

    def rend(self):
        return _adaptagrams.TopologyEdgePtrs_rend(self)

    def clear(self):
        return _adaptagrams.TopologyEdgePtrs_clear(self)

    def get_allocator(self):
        return _adaptagrams.TopologyEdgePtrs_get_allocator(self)

    def pop_back(self):
        return _adaptagrams.TopologyEdgePtrs_pop_back(self)

    def erase(self, *args):
        return _adaptagrams.TopologyEdgePtrs_erase(self, *args)

    def __init__(self, *args):
        this = _adaptagrams.new_TopologyEdgePtrs(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _adaptagrams.TopologyEdgePtrs_push_back(self, x)

    def front(self):
        return _adaptagrams.TopologyEdgePtrs_front(self)

    def back(self):
        return _adaptagrams.TopologyEdgePtrs_back(self)

    def assign(self, n, x):
        return _adaptagrams.TopologyEdgePtrs_assign(self, n, x)

    def resize(self, *args):
        return _adaptagrams.TopologyEdgePtrs_resize(self, *args)

    def insert(self, *args):
        return _adaptagrams.TopologyEdgePtrs_insert(self, *args)

    def reserve(self, n):
        return _adaptagrams.TopologyEdgePtrs_reserve(self, n)

    def capacity(self):
        return _adaptagrams.TopologyEdgePtrs_capacity(self)
    __swig_destroy__ = _adaptagrams.delete_TopologyEdgePtrs
    __del__ = lambda self: None
TopologyEdgePtrs_swigregister = _adaptagrams.TopologyEdgePtrs_swigregister
TopologyEdgePtrs_swigregister(TopologyEdgePtrs)

class TopologyNodePtrs(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TopologyNodePtrs, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TopologyNodePtrs, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _adaptagrams.TopologyNodePtrs_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _adaptagrams.TopologyNodePtrs___nonzero__(self)

    def __bool__(self):
        return _adaptagrams.TopologyNodePtrs___bool__(self)

    def __len__(self):
        return _adaptagrams.TopologyNodePtrs___len__(self)

    def __getslice__(self, i, j):
        return _adaptagrams.TopologyNodePtrs___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _adaptagrams.TopologyNodePtrs___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _adaptagrams.TopologyNodePtrs___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _adaptagrams.TopologyNodePtrs___delitem__(self, *args)

    def __getitem__(self, *args):
        return _adaptagrams.TopologyNodePtrs___getitem__(self, *args)

    def __setitem__(self, *args):
        return _adaptagrams.TopologyNodePtrs___setitem__(self, *args)

    def pop(self):
        return _adaptagrams.TopologyNodePtrs_pop(self)

    def append(self, x):
        return _adaptagrams.TopologyNodePtrs_append(self, x)

    def empty(self):
        return _adaptagrams.TopologyNodePtrs_empty(self)

    def size(self):
        return _adaptagrams.TopologyNodePtrs_size(self)

    def swap(self, v):
        return _adaptagrams.TopologyNodePtrs_swap(self, v)

    def begin(self):
        return _adaptagrams.TopologyNodePtrs_begin(self)

    def end(self):
        return _adaptagrams.TopologyNodePtrs_end(self)

    def rbegin(self):
        return _adaptagrams.TopologyNodePtrs_rbegin(self)

    def rend(self):
        return _adaptagrams.TopologyNodePtrs_rend(self)

    def clear(self):
        return _adaptagrams.TopologyNodePtrs_clear(self)

    def get_allocator(self):
        return _adaptagrams.TopologyNodePtrs_get_allocator(self)

    def pop_back(self):
        return _adaptagrams.TopologyNodePtrs_pop_back(self)

    def erase(self, *args):
        return _adaptagrams.TopologyNodePtrs_erase(self, *args)

    def __init__(self, *args):
        this = _adaptagrams.new_TopologyNodePtrs(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _adaptagrams.TopologyNodePtrs_push_back(self, x)

    def front(self):
        return _adaptagrams.TopologyNodePtrs_front(self)

    def back(self):
        return _adaptagrams.TopologyNodePtrs_back(self)

    def assign(self, n, x):
        return _adaptagrams.TopologyNodePtrs_assign(self, n, x)

    def resize(self, *args):
        return _adaptagrams.TopologyNodePtrs_resize(self, *args)

    def insert(self, *args):
        return _adaptagrams.TopologyNodePtrs_insert(self, *args)

    def reserve(self, n):
        return _adaptagrams.TopologyNodePtrs_reserve(self, n)

    def capacity(self):
        return _adaptagrams.TopologyNodePtrs_capacity(self)
    __swig_destroy__ = _adaptagrams.delete_TopologyNodePtrs
    __del__ = lambda self: None
TopologyNodePtrs_swigregister = _adaptagrams.TopologyNodePtrs_swigregister
TopologyNodePtrs_swigregister(TopologyNodePtrs)

class ColaClusters(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ColaClusters, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ColaClusters, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _adaptagrams.ColaClusters_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _adaptagrams.ColaClusters___nonzero__(self)

    def __bool__(self):
        return _adaptagrams.ColaClusters___bool__(self)

    def __len__(self):
        return _adaptagrams.ColaClusters___len__(self)

    def __getslice__(self, i, j):
        return _adaptagrams.ColaClusters___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _adaptagrams.ColaClusters___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _adaptagrams.ColaClusters___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _adaptagrams.ColaClusters___delitem__(self, *args)

    def __getitem__(self, *args):
        return _adaptagrams.ColaClusters___getitem__(self, *args)

    def __setitem__(self, *args):
        return _adaptagrams.ColaClusters___setitem__(self, *args)

    def pop(self):
        return _adaptagrams.ColaClusters_pop(self)

    def append(self, x):
        return _adaptagrams.ColaClusters_append(self, x)

    def empty(self):
        return _adaptagrams.ColaClusters_empty(self)

    def size(self):
        return _adaptagrams.ColaClusters_size(self)

    def swap(self, v):
        return _adaptagrams.ColaClusters_swap(self, v)

    def begin(self):
        return _adaptagrams.ColaClusters_begin(self)

    def end(self):
        return _adaptagrams.ColaClusters_end(self)

    def rbegin(self):
        return _adaptagrams.ColaClusters_rbegin(self)

    def rend(self):
        return _adaptagrams.ColaClusters_rend(self)

    def clear(self):
        return _adaptagrams.ColaClusters_clear(self)

    def get_allocator(self):
        return _adaptagrams.ColaClusters_get_allocator(self)

    def pop_back(self):
        return _adaptagrams.ColaClusters_pop_back(self)

    def erase(self, *args):
        return _adaptagrams.ColaClusters_erase(self, *args)

    def __init__(self, *args):
        this = _adaptagrams.new_ColaClusters(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _adaptagrams.ColaClusters_push_back(self, x)

    def front(self):
        return _adaptagrams.ColaClusters_front(self)

    def back(self):
        return _adaptagrams.ColaClusters_back(self)

    def assign(self, n, x):
        return _adaptagrams.ColaClusters_assign(self, n, x)

    def resize(self, *args):
        return _adaptagrams.ColaClusters_resize(self, *args)

    def insert(self, *args):
        return _adaptagrams.ColaClusters_insert(self, *args)

    def reserve(self, n):
        return _adaptagrams.ColaClusters_reserve(self, n)

    def capacity(self):
        return _adaptagrams.ColaClusters_capacity(self)
    __swig_destroy__ = _adaptagrams.delete_ColaClusters
    __del__ = lambda self: None
ColaClusters_swigregister = _adaptagrams.ColaClusters_swigregister
ColaClusters_swigregister(ColaClusters)

class AvoidPoints(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AvoidPoints, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AvoidPoints, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _adaptagrams.AvoidPoints_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _adaptagrams.AvoidPoints___nonzero__(self)

    def __bool__(self):
        return _adaptagrams.AvoidPoints___bool__(self)

    def __len__(self):
        return _adaptagrams.AvoidPoints___len__(self)

    def __getslice__(self, i, j):
        return _adaptagrams.AvoidPoints___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _adaptagrams.AvoidPoints___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _adaptagrams.AvoidPoints___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _adaptagrams.AvoidPoints___delitem__(self, *args)

    def __getitem__(self, *args):
        return _adaptagrams.AvoidPoints___getitem__(self, *args)

    def __setitem__(self, *args):
        return _adaptagrams.AvoidPoints___setitem__(self, *args)

    def pop(self):
        return _adaptagrams.AvoidPoints_pop(self)

    def append(self, x):
        return _adaptagrams.AvoidPoints_append(self, x)

    def empty(self):
        return _adaptagrams.AvoidPoints_empty(self)

    def size(self):
        return _adaptagrams.AvoidPoints_size(self)

    def swap(self, v):
        return _adaptagrams.AvoidPoints_swap(self, v)

    def begin(self):
        return _adaptagrams.AvoidPoints_begin(self)

    def end(self):
        return _adaptagrams.AvoidPoints_end(self)

    def rbegin(self):
        return _adaptagrams.AvoidPoints_rbegin(self)

    def rend(self):
        return _adaptagrams.AvoidPoints_rend(self)

    def clear(self):
        return _adaptagrams.AvoidPoints_clear(self)

    def get_allocator(self):
        return _adaptagrams.AvoidPoints_get_allocator(self)

    def pop_back(self):
        return _adaptagrams.AvoidPoints_pop_back(self)

    def erase(self, *args):
        return _adaptagrams.AvoidPoints_erase(self, *args)

    def __init__(self, *args):
        this = _adaptagrams.new_AvoidPoints(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _adaptagrams.AvoidPoints_push_back(self, x)

    def front(self):
        return _adaptagrams.AvoidPoints_front(self)

    def back(self):
        return _adaptagrams.AvoidPoints_back(self)

    def assign(self, n, x):
        return _adaptagrams.AvoidPoints_assign(self, n, x)

    def resize(self, *args):
        return _adaptagrams.AvoidPoints_resize(self, *args)

    def insert(self, *args):
        return _adaptagrams.AvoidPoints_insert(self, *args)

    def reserve(self, n):
        return _adaptagrams.AvoidPoints_reserve(self, n)

    def capacity(self):
        return _adaptagrams.AvoidPoints_capacity(self)
    __swig_destroy__ = _adaptagrams.delete_AvoidPoints
    __del__ = lambda self: None
AvoidPoints_swigregister = _adaptagrams.AvoidPoints_swigregister
AvoidPoints_swigregister(AvoidPoints)

class AvoidCheckpoints(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AvoidCheckpoints, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AvoidCheckpoints, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _adaptagrams.AvoidCheckpoints_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _adaptagrams.AvoidCheckpoints___nonzero__(self)

    def __bool__(self):
        return _adaptagrams.AvoidCheckpoints___bool__(self)

    def __len__(self):
        return _adaptagrams.AvoidCheckpoints___len__(self)

    def __getslice__(self, i, j):
        return _adaptagrams.AvoidCheckpoints___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _adaptagrams.AvoidCheckpoints___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _adaptagrams.AvoidCheckpoints___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _adaptagrams.AvoidCheckpoints___delitem__(self, *args)

    def __getitem__(self, *args):
        return _adaptagrams.AvoidCheckpoints___getitem__(self, *args)

    def __setitem__(self, *args):
        return _adaptagrams.AvoidCheckpoints___setitem__(self, *args)

    def pop(self):
        return _adaptagrams.AvoidCheckpoints_pop(self)

    def append(self, x):
        return _adaptagrams.AvoidCheckpoints_append(self, x)

    def empty(self):
        return _adaptagrams.AvoidCheckpoints_empty(self)

    def size(self):
        return _adaptagrams.AvoidCheckpoints_size(self)

    def swap(self, v):
        return _adaptagrams.AvoidCheckpoints_swap(self, v)

    def begin(self):
        return _adaptagrams.AvoidCheckpoints_begin(self)

    def end(self):
        return _adaptagrams.AvoidCheckpoints_end(self)

    def rbegin(self):
        return _adaptagrams.AvoidCheckpoints_rbegin(self)

    def rend(self):
        return _adaptagrams.AvoidCheckpoints_rend(self)

    def clear(self):
        return _adaptagrams.AvoidCheckpoints_clear(self)

    def get_allocator(self):
        return _adaptagrams.AvoidCheckpoints_get_allocator(self)

    def pop_back(self):
        return _adaptagrams.AvoidCheckpoints_pop_back(self)

    def erase(self, *args):
        return _adaptagrams.AvoidCheckpoints_erase(self, *args)

    def __init__(self, *args):
        this = _adaptagrams.new_AvoidCheckpoints(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _adaptagrams.AvoidCheckpoints_push_back(self, x)

    def front(self):
        return _adaptagrams.AvoidCheckpoints_front(self)

    def back(self):
        return _adaptagrams.AvoidCheckpoints_back(self)

    def assign(self, n, x):
        return _adaptagrams.AvoidCheckpoints_assign(self, n, x)

    def resize(self, *args):
        return _adaptagrams.AvoidCheckpoints_resize(self, *args)

    def insert(self, *args):
        return _adaptagrams.AvoidCheckpoints_insert(self, *args)

    def reserve(self, n):
        return _adaptagrams.AvoidCheckpoints_reserve(self, n)

    def capacity(self):
        return _adaptagrams.AvoidCheckpoints_capacity(self)
    __swig_destroy__ = _adaptagrams.delete_AvoidCheckpoints
    __del__ = lambda self: None
AvoidCheckpoints_swigregister = _adaptagrams.AvoidCheckpoints_swigregister
AvoidCheckpoints_swigregister(AvoidCheckpoints)

class OrderedAlignmentPtrs(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OrderedAlignmentPtrs, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OrderedAlignmentPtrs, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _adaptagrams.OrderedAlignmentPtrs_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _adaptagrams.OrderedAlignmentPtrs___nonzero__(self)

    def __bool__(self):
        return _adaptagrams.OrderedAlignmentPtrs___bool__(self)

    def __len__(self):
        return _adaptagrams.OrderedAlignmentPtrs___len__(self)

    def __getslice__(self, i, j):
        return _adaptagrams.OrderedAlignmentPtrs___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _adaptagrams.OrderedAlignmentPtrs___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _adaptagrams.OrderedAlignmentPtrs___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _adaptagrams.OrderedAlignmentPtrs___delitem__(self, *args)

    def __getitem__(self, *args):
        return _adaptagrams.OrderedAlignmentPtrs___getitem__(self, *args)

    def __setitem__(self, *args):
        return _adaptagrams.OrderedAlignmentPtrs___setitem__(self, *args)

    def pop(self):
        return _adaptagrams.OrderedAlignmentPtrs_pop(self)

    def append(self, x):
        return _adaptagrams.OrderedAlignmentPtrs_append(self, x)

    def empty(self):
        return _adaptagrams.OrderedAlignmentPtrs_empty(self)

    def size(self):
        return _adaptagrams.OrderedAlignmentPtrs_size(self)

    def swap(self, v):
        return _adaptagrams.OrderedAlignmentPtrs_swap(self, v)

    def begin(self):
        return _adaptagrams.OrderedAlignmentPtrs_begin(self)

    def end(self):
        return _adaptagrams.OrderedAlignmentPtrs_end(self)

    def rbegin(self):
        return _adaptagrams.OrderedAlignmentPtrs_rbegin(self)

    def rend(self):
        return _adaptagrams.OrderedAlignmentPtrs_rend(self)

    def clear(self):
        return _adaptagrams.OrderedAlignmentPtrs_clear(self)

    def get_allocator(self):
        return _adaptagrams.OrderedAlignmentPtrs_get_allocator(self)

    def pop_back(self):
        return _adaptagrams.OrderedAlignmentPtrs_pop_back(self)

    def erase(self, *args):
        return _adaptagrams.OrderedAlignmentPtrs_erase(self, *args)

    def __init__(self, *args):
        this = _adaptagrams.new_OrderedAlignmentPtrs(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _adaptagrams.OrderedAlignmentPtrs_push_back(self, x)

    def front(self):
        return _adaptagrams.OrderedAlignmentPtrs_front(self)

    def back(self):
        return _adaptagrams.OrderedAlignmentPtrs_back(self)

    def assign(self, n, x):
        return _adaptagrams.OrderedAlignmentPtrs_assign(self, n, x)

    def resize(self, *args):
        return _adaptagrams.OrderedAlignmentPtrs_resize(self, *args)

    def insert(self, *args):
        return _adaptagrams.OrderedAlignmentPtrs_insert(self, *args)

    def reserve(self, n):
        return _adaptagrams.OrderedAlignmentPtrs_reserve(self, n)

    def capacity(self):
        return _adaptagrams.OrderedAlignmentPtrs_capacity(self)
    __swig_destroy__ = _adaptagrams.delete_OrderedAlignmentPtrs
    __del__ = lambda self: None
OrderedAlignmentPtrs_swigregister = _adaptagrams.OrderedAlignmentPtrs_swigregister
OrderedAlignmentPtrs_swigregister(OrderedAlignmentPtrs)

class TreePtrs(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TreePtrs, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TreePtrs, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _adaptagrams.TreePtrs_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _adaptagrams.TreePtrs___nonzero__(self)

    def __bool__(self):
        return _adaptagrams.TreePtrs___bool__(self)

    def __len__(self):
        return _adaptagrams.TreePtrs___len__(self)

    def __getslice__(self, i, j):
        return _adaptagrams.TreePtrs___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _adaptagrams.TreePtrs___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _adaptagrams.TreePtrs___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _adaptagrams.TreePtrs___delitem__(self, *args)

    def __getitem__(self, *args):
        return _adaptagrams.TreePtrs___getitem__(self, *args)

    def __setitem__(self, *args):
        return _adaptagrams.TreePtrs___setitem__(self, *args)

    def pop(self):
        return _adaptagrams.TreePtrs_pop(self)

    def append(self, x):
        return _adaptagrams.TreePtrs_append(self, x)

    def empty(self):
        return _adaptagrams.TreePtrs_empty(self)

    def size(self):
        return _adaptagrams.TreePtrs_size(self)

    def swap(self, v):
        return _adaptagrams.TreePtrs_swap(self, v)

    def begin(self):
        return _adaptagrams.TreePtrs_begin(self)

    def end(self):
        return _adaptagrams.TreePtrs_end(self)

    def rbegin(self):
        return _adaptagrams.TreePtrs_rbegin(self)

    def rend(self):
        return _adaptagrams.TreePtrs_rend(self)

    def clear(self):
        return _adaptagrams.TreePtrs_clear(self)

    def get_allocator(self):
        return _adaptagrams.TreePtrs_get_allocator(self)

    def pop_back(self):
        return _adaptagrams.TreePtrs_pop_back(self)

    def erase(self, *args):
        return _adaptagrams.TreePtrs_erase(self, *args)

    def __init__(self, *args):
        this = _adaptagrams.new_TreePtrs(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _adaptagrams.TreePtrs_push_back(self, x)

    def front(self):
        return _adaptagrams.TreePtrs_front(self)

    def back(self):
        return _adaptagrams.TreePtrs_back(self)

    def assign(self, n, x):
        return _adaptagrams.TreePtrs_assign(self, n, x)

    def resize(self, *args):
        return _adaptagrams.TreePtrs_resize(self, *args)

    def insert(self, *args):
        return _adaptagrams.TreePtrs_insert(self, *args)

    def reserve(self, n):
        return _adaptagrams.TreePtrs_reserve(self, n)

    def capacity(self):
        return _adaptagrams.TreePtrs_capacity(self)
    __swig_destroy__ = _adaptagrams.delete_TreePtrs
    __del__ = lambda self: None
TreePtrs_swigregister = _adaptagrams.TreePtrs_swigregister
TreePtrs_swigregister(TreePtrs)

class ChainPtrs(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ChainPtrs, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ChainPtrs, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _adaptagrams.ChainPtrs_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _adaptagrams.ChainPtrs___nonzero__(self)

    def __bool__(self):
        return _adaptagrams.ChainPtrs___bool__(self)

    def __len__(self):
        return _adaptagrams.ChainPtrs___len__(self)

    def __getslice__(self, i, j):
        return _adaptagrams.ChainPtrs___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _adaptagrams.ChainPtrs___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _adaptagrams.ChainPtrs___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _adaptagrams.ChainPtrs___delitem__(self, *args)

    def __getitem__(self, *args):
        return _adaptagrams.ChainPtrs___getitem__(self, *args)

    def __setitem__(self, *args):
        return _adaptagrams.ChainPtrs___setitem__(self, *args)

    def pop(self):
        return _adaptagrams.ChainPtrs_pop(self)

    def append(self, x):
        return _adaptagrams.ChainPtrs_append(self, x)

    def empty(self):
        return _adaptagrams.ChainPtrs_empty(self)

    def size(self):
        return _adaptagrams.ChainPtrs_size(self)

    def swap(self, v):
        return _adaptagrams.ChainPtrs_swap(self, v)

    def begin(self):
        return _adaptagrams.ChainPtrs_begin(self)

    def end(self):
        return _adaptagrams.ChainPtrs_end(self)

    def rbegin(self):
        return _adaptagrams.ChainPtrs_rbegin(self)

    def rend(self):
        return _adaptagrams.ChainPtrs_rend(self)

    def clear(self):
        return _adaptagrams.ChainPtrs_clear(self)

    def get_allocator(self):
        return _adaptagrams.ChainPtrs_get_allocator(self)

    def pop_back(self):
        return _adaptagrams.ChainPtrs_pop_back(self)

    def erase(self, *args):
        return _adaptagrams.ChainPtrs_erase(self, *args)

    def __init__(self, *args):
        this = _adaptagrams.new_ChainPtrs(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _adaptagrams.ChainPtrs_push_back(self, x)

    def front(self):
        return _adaptagrams.ChainPtrs_front(self)

    def back(self):
        return _adaptagrams.ChainPtrs_back(self)

    def assign(self, n, x):
        return _adaptagrams.ChainPtrs_assign(self, n, x)

    def resize(self, *args):
        return _adaptagrams.ChainPtrs_resize(self, *args)

    def insert(self, *args):
        return _adaptagrams.ChainPtrs_insert(self, *args)

    def reserve(self, n):
        return _adaptagrams.ChainPtrs_reserve(self, n)

    def capacity(self):
        return _adaptagrams.ChainPtrs_capacity(self)
    __swig_destroy__ = _adaptagrams.delete_ChainPtrs
    __del__ = lambda self: None
ChainPtrs_swigregister = _adaptagrams.ChainPtrs_swigregister
ChainPtrs_swigregister(ChainPtrs)

class DialectNodes(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DialectNodes, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DialectNodes, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _adaptagrams.DialectNodes_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _adaptagrams.DialectNodes___nonzero__(self)

    def __bool__(self):
        return _adaptagrams.DialectNodes___bool__(self)

    def __len__(self):
        return _adaptagrams.DialectNodes___len__(self)

    def __getslice__(self, i, j):
        return _adaptagrams.DialectNodes___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _adaptagrams.DialectNodes___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _adaptagrams.DialectNodes___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _adaptagrams.DialectNodes___delitem__(self, *args)

    def __getitem__(self, *args):
        return _adaptagrams.DialectNodes___getitem__(self, *args)

    def __setitem__(self, *args):
        return _adaptagrams.DialectNodes___setitem__(self, *args)

    def pop(self):
        return _adaptagrams.DialectNodes_pop(self)

    def append(self, x):
        return _adaptagrams.DialectNodes_append(self, x)

    def empty(self):
        return _adaptagrams.DialectNodes_empty(self)

    def size(self):
        return _adaptagrams.DialectNodes_size(self)

    def swap(self, v):
        return _adaptagrams.DialectNodes_swap(self, v)

    def begin(self):
        return _adaptagrams.DialectNodes_begin(self)

    def end(self):
        return _adaptagrams.DialectNodes_end(self)

    def rbegin(self):
        return _adaptagrams.DialectNodes_rbegin(self)

    def rend(self):
        return _adaptagrams.DialectNodes_rend(self)

    def clear(self):
        return _adaptagrams.DialectNodes_clear(self)

    def get_allocator(self):
        return _adaptagrams.DialectNodes_get_allocator(self)

    def pop_back(self):
        return _adaptagrams.DialectNodes_pop_back(self)

    def erase(self, *args):
        return _adaptagrams.DialectNodes_erase(self, *args)

    def __init__(self, *args):
        this = _adaptagrams.new_DialectNodes(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _adaptagrams.DialectNodes_push_back(self, x)

    def front(self):
        return _adaptagrams.DialectNodes_front(self)

    def back(self):
        return _adaptagrams.DialectNodes_back(self)

    def assign(self, n, x):
        return _adaptagrams.DialectNodes_assign(self, n, x)

    def resize(self, *args):
        return _adaptagrams.DialectNodes_resize(self, *args)

    def insert(self, *args):
        return _adaptagrams.DialectNodes_insert(self, *args)

    def reserve(self, n):
        return _adaptagrams.DialectNodes_reserve(self, n)

    def capacity(self):
        return _adaptagrams.DialectNodes_capacity(self)
    __swig_destroy__ = _adaptagrams.delete_DialectNodes
    __del__ = lambda self: None
DialectNodes_swigregister = _adaptagrams.DialectNodes_swigregister
DialectNodes_swigregister(DialectNodes)

class DialectNodeLookup(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DialectNodeLookup, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DialectNodeLookup, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _adaptagrams.DialectNodeLookup_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _adaptagrams.DialectNodeLookup___nonzero__(self)

    def __bool__(self):
        return _adaptagrams.DialectNodeLookup___bool__(self)

    def __len__(self):
        return _adaptagrams.DialectNodeLookup___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _adaptagrams.DialectNodeLookup___getitem__(self, key)

    def __delitem__(self, key):
        return _adaptagrams.DialectNodeLookup___delitem__(self, key)

    def has_key(self, key):
        return _adaptagrams.DialectNodeLookup_has_key(self, key)

    def keys(self):
        return _adaptagrams.DialectNodeLookup_keys(self)

    def values(self):
        return _adaptagrams.DialectNodeLookup_values(self)

    def items(self):
        return _adaptagrams.DialectNodeLookup_items(self)

    def __contains__(self, key):
        return _adaptagrams.DialectNodeLookup___contains__(self, key)

    def key_iterator(self):
        return _adaptagrams.DialectNodeLookup_key_iterator(self)

    def value_iterator(self):
        return _adaptagrams.DialectNodeLookup_value_iterator(self)

    def __setitem__(self, *args):
        return _adaptagrams.DialectNodeLookup___setitem__(self, *args)

    def asdict(self):
        return _adaptagrams.DialectNodeLookup_asdict(self)

    def __init__(self, *args):
        this = _adaptagrams.new_DialectNodeLookup(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def empty(self):
        return _adaptagrams.DialectNodeLookup_empty(self)

    def size(self):
        return _adaptagrams.DialectNodeLookup_size(self)

    def swap(self, v):
        return _adaptagrams.DialectNodeLookup_swap(self, v)

    def begin(self):
        return _adaptagrams.DialectNodeLookup_begin(self)

    def end(self):
        return _adaptagrams.DialectNodeLookup_end(self)

    def rbegin(self):
        return _adaptagrams.DialectNodeLookup_rbegin(self)

    def rend(self):
        return _adaptagrams.DialectNodeLookup_rend(self)

    def clear(self):
        return _adaptagrams.DialectNodeLookup_clear(self)

    def get_allocator(self):
        return _adaptagrams.DialectNodeLookup_get_allocator(self)

    def count(self, x):
        return _adaptagrams.DialectNodeLookup_count(self, x)

    def erase(self, *args):
        return _adaptagrams.DialectNodeLookup_erase(self, *args)

    def find(self, x):
        return _adaptagrams.DialectNodeLookup_find(self, x)

    def lower_bound(self, x):
        return _adaptagrams.DialectNodeLookup_lower_bound(self, x)

    def upper_bound(self, x):
        return _adaptagrams.DialectNodeLookup_upper_bound(self, x)
    __swig_destroy__ = _adaptagrams.delete_DialectNodeLookup
    __del__ = lambda self: None
DialectNodeLookup_swigregister = _adaptagrams.DialectNodeLookup_swigregister
DialectNodeLookup_swigregister(DialectNodeLookup)

class DialectNodeDeques(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DialectNodeDeques, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DialectNodeDeques, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _adaptagrams.DialectNodeDeques_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _adaptagrams.DialectNodeDeques___nonzero__(self)

    def __bool__(self):
        return _adaptagrams.DialectNodeDeques___bool__(self)

    def __len__(self):
        return _adaptagrams.DialectNodeDeques___len__(self)

    def __getslice__(self, i, j):
        return _adaptagrams.DialectNodeDeques___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _adaptagrams.DialectNodeDeques___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _adaptagrams.DialectNodeDeques___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _adaptagrams.DialectNodeDeques___delitem__(self, *args)

    def __getitem__(self, *args):
        return _adaptagrams.DialectNodeDeques___getitem__(self, *args)

    def __setitem__(self, *args):
        return _adaptagrams.DialectNodeDeques___setitem__(self, *args)

    def pop(self):
        return _adaptagrams.DialectNodeDeques_pop(self)

    def append(self, x):
        return _adaptagrams.DialectNodeDeques_append(self, x)

    def empty(self):
        return _adaptagrams.DialectNodeDeques_empty(self)

    def size(self):
        return _adaptagrams.DialectNodeDeques_size(self)

    def swap(self, v):
        return _adaptagrams.DialectNodeDeques_swap(self, v)

    def begin(self):
        return _adaptagrams.DialectNodeDeques_begin(self)

    def end(self):
        return _adaptagrams.DialectNodeDeques_end(self)

    def rbegin(self):
        return _adaptagrams.DialectNodeDeques_rbegin(self)

    def rend(self):
        return _adaptagrams.DialectNodeDeques_rend(self)

    def clear(self):
        return _adaptagrams.DialectNodeDeques_clear(self)

    def get_allocator(self):
        return _adaptagrams.DialectNodeDeques_get_allocator(self)

    def pop_back(self):
        return _adaptagrams.DialectNodeDeques_pop_back(self)

    def erase(self, *args):
        return _adaptagrams.DialectNodeDeques_erase(self, *args)

    def __init__(self, *args):
        this = _adaptagrams.new_DialectNodeDeques(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _adaptagrams.DialectNodeDeques_push_back(self, x)

    def front(self):
        return _adaptagrams.DialectNodeDeques_front(self)

    def back(self):
        return _adaptagrams.DialectNodeDeques_back(self)

    def assign(self, n, x):
        return _adaptagrams.DialectNodeDeques_assign(self, n, x)

    def resize(self, *args):
        return _adaptagrams.DialectNodeDeques_resize(self, *args)

    def insert(self, *args):
        return _adaptagrams.DialectNodeDeques_insert(self, *args)

    def reserve(self, n):
        return _adaptagrams.DialectNodeDeques_reserve(self, n)

    def capacity(self):
        return _adaptagrams.DialectNodeDeques_capacity(self)
    __swig_destroy__ = _adaptagrams.delete_DialectNodeDeques
    __del__ = lambda self: None
DialectNodeDeques_swigregister = _adaptagrams.DialectNodeDeques_swigregister
DialectNodeDeques_swigregister(DialectNodeDeques)


def doubleArraySet(a, i, val):
    return _adaptagrams.doubleArraySet(a, i, val)
doubleArraySet = _adaptagrams.doubleArraySet

def doubleArrayGet(a, i):
    return _adaptagrams.doubleArrayGet(a, i)
doubleArrayGet = _adaptagrams.doubleArrayGet

def newDoubleArray(size):
    return _adaptagrams.newDoubleArray(size)
newDoubleArray = _adaptagrams.newDoubleArray

def deleteDoubleArray(a):
    return _adaptagrams.deleteDoubleArray(a)
deleteDoubleArray = _adaptagrams.deleteDoubleArray
HORIZONTAL = _adaptagrams.HORIZONTAL
XDIM = _adaptagrams.XDIM
VERTICAL = _adaptagrams.VERTICAL
YDIM = _adaptagrams.YDIM
UNSET = _adaptagrams.UNSET

def conjugate(d):
    return _adaptagrams.conjugate(d)
conjugate = _adaptagrams.conjugate
class RectangleIntersections(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RectangleIntersections, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RectangleIntersections, name)
    __repr__ = _swig_repr
    __swig_setmethods__["intersects"] = _adaptagrams.RectangleIntersections_intersects_set
    __swig_getmethods__["intersects"] = _adaptagrams.RectangleIntersections_intersects_get
    if _newclass:
        intersects = _swig_property(_adaptagrams.RectangleIntersections_intersects_get, _adaptagrams.RectangleIntersections_intersects_set)
    __swig_setmethods__["top"] = _adaptagrams.RectangleIntersections_top_set
    __swig_getmethods__["top"] = _adaptagrams.RectangleIntersections_top_get
    if _newclass:
        top = _swig_property(_adaptagrams.RectangleIntersections_top_get, _adaptagrams.RectangleIntersections_top_set)
    __swig_setmethods__["bottom"] = _adaptagrams.RectangleIntersections_bottom_set
    __swig_getmethods__["bottom"] = _adaptagrams.RectangleIntersections_bottom_get
    if _newclass:
        bottom = _swig_property(_adaptagrams.RectangleIntersections_bottom_get, _adaptagrams.RectangleIntersections_bottom_set)
    __swig_setmethods__["left"] = _adaptagrams.RectangleIntersections_left_set
    __swig_getmethods__["left"] = _adaptagrams.RectangleIntersections_left_get
    if _newclass:
        left = _swig_property(_adaptagrams.RectangleIntersections_left_get, _adaptagrams.RectangleIntersections_left_set)
    __swig_setmethods__["right"] = _adaptagrams.RectangleIntersections_right_set
    __swig_getmethods__["right"] = _adaptagrams.RectangleIntersections_right_get
    if _newclass:
        right = _swig_property(_adaptagrams.RectangleIntersections_right_get, _adaptagrams.RectangleIntersections_right_set)
    __swig_setmethods__["topX"] = _adaptagrams.RectangleIntersections_topX_set
    __swig_getmethods__["topX"] = _adaptagrams.RectangleIntersections_topX_get
    if _newclass:
        topX = _swig_property(_adaptagrams.RectangleIntersections_topX_get, _adaptagrams.RectangleIntersections_topX_set)
    __swig_setmethods__["topY"] = _adaptagrams.RectangleIntersections_topY_set
    __swig_getmethods__["topY"] = _adaptagrams.RectangleIntersections_topY_get
    if _newclass:
        topY = _swig_property(_adaptagrams.RectangleIntersections_topY_get, _adaptagrams.RectangleIntersections_topY_set)
    __swig_setmethods__["bottomX"] = _adaptagrams.RectangleIntersections_bottomX_set
    __swig_getmethods__["bottomX"] = _adaptagrams.RectangleIntersections_bottomX_get
    if _newclass:
        bottomX = _swig_property(_adaptagrams.RectangleIntersections_bottomX_get, _adaptagrams.RectangleIntersections_bottomX_set)
    __swig_setmethods__["bottomY"] = _adaptagrams.RectangleIntersections_bottomY_set
    __swig_getmethods__["bottomY"] = _adaptagrams.RectangleIntersections_bottomY_get
    if _newclass:
        bottomY = _swig_property(_adaptagrams.RectangleIntersections_bottomY_get, _adaptagrams.RectangleIntersections_bottomY_set)
    __swig_setmethods__["leftX"] = _adaptagrams.RectangleIntersections_leftX_set
    __swig_getmethods__["leftX"] = _adaptagrams.RectangleIntersections_leftX_get
    if _newclass:
        leftX = _swig_property(_adaptagrams.RectangleIntersections_leftX_get, _adaptagrams.RectangleIntersections_leftX_set)
    __swig_setmethods__["leftY"] = _adaptagrams.RectangleIntersections_leftY_set
    __swig_getmethods__["leftY"] = _adaptagrams.RectangleIntersections_leftY_get
    if _newclass:
        leftY = _swig_property(_adaptagrams.RectangleIntersections_leftY_get, _adaptagrams.RectangleIntersections_leftY_set)
    __swig_setmethods__["rightX"] = _adaptagrams.RectangleIntersections_rightX_set
    __swig_getmethods__["rightX"] = _adaptagrams.RectangleIntersections_rightX_get
    if _newclass:
        rightX = _swig_property(_adaptagrams.RectangleIntersections_rightX_get, _adaptagrams.RectangleIntersections_rightX_set)
    __swig_setmethods__["rightY"] = _adaptagrams.RectangleIntersections_rightY_set
    __swig_getmethods__["rightY"] = _adaptagrams.RectangleIntersections_rightY_get
    if _newclass:
        rightY = _swig_property(_adaptagrams.RectangleIntersections_rightY_get, _adaptagrams.RectangleIntersections_rightY_set)

    def __init__(self):
        this = _adaptagrams.new_RectangleIntersections()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def countIntersections(self):
        return _adaptagrams.RectangleIntersections_countIntersections(self)

    def printIntersections(self):
        return _adaptagrams.RectangleIntersections_printIntersections(self)

    def nearest(self, x, y, xi, yi):
        return _adaptagrams.RectangleIntersections_nearest(self, x, y, xi, yi)
    __swig_destroy__ = _adaptagrams.delete_RectangleIntersections
    __del__ = lambda self: None
RectangleIntersections_swigregister = _adaptagrams.RectangleIntersections_swigregister
RectangleIntersections_swigregister(RectangleIntersections)

class Rectangle(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Rectangle, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Rectangle, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _adaptagrams.new_Rectangle(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def isValid(self):
        return _adaptagrams.Rectangle_isValid(self)

    def unionWith(self, rhs):
        return _adaptagrams.Rectangle_unionWith(self, rhs)

    def reset(self, d, x, X):
        return _adaptagrams.Rectangle_reset(self, d, x, X)

    def getMaxX(self):
        return _adaptagrams.Rectangle_getMaxX(self)

    def getMaxY(self):
        return _adaptagrams.Rectangle_getMaxY(self)

    def getMinX(self):
        return _adaptagrams.Rectangle_getMinX(self)

    def getMinY(self):
        return _adaptagrams.Rectangle_getMinY(self)

    def getMinD(self, d):
        return _adaptagrams.Rectangle_getMinD(self, d)

    def getMaxD(self, d):
        return _adaptagrams.Rectangle_getMaxD(self, d)

    def setMinD(self, d, val):
        return _adaptagrams.Rectangle_setMinD(self, d, val)

    def setMaxD(self, d, val):
        return _adaptagrams.Rectangle_setMaxD(self, d, val)

    def getCentreX(self):
        return _adaptagrams.Rectangle_getCentreX(self)

    def getCentreY(self):
        return _adaptagrams.Rectangle_getCentreY(self)

    def getCentreD(self, d):
        return _adaptagrams.Rectangle_getCentreD(self, d)

    def width(self):
        return _adaptagrams.Rectangle_width(self)

    def height(self):
        return _adaptagrams.Rectangle_height(self)

    def length(self, d):
        return _adaptagrams.Rectangle_length(self, d)

    def set_width(self, w):
        return _adaptagrams.Rectangle_set_width(self, w)

    def set_height(self, h):
        return _adaptagrams.Rectangle_set_height(self, h)

    def moveCentreD(self, d, p):
        return _adaptagrams.Rectangle_moveCentreD(self, d, p)

    def moveCentreX(self, x):
        return _adaptagrams.Rectangle_moveCentreX(self, x)

    def moveCentreY(self, y):
        return _adaptagrams.Rectangle_moveCentreY(self, y)

    def moveCentre(self, x, y):
        return _adaptagrams.Rectangle_moveCentre(self, x, y)

    def moveMinX(self, x):
        return _adaptagrams.Rectangle_moveMinX(self, x)

    def moveMinY(self, y):
        return _adaptagrams.Rectangle_moveMinY(self, y)

    def overlapD(self, d, r):
        return _adaptagrams.Rectangle_overlapD(self, d, r)

    def overlapX(self, r):
        return _adaptagrams.Rectangle_overlapX(self, r)

    def overlapY(self, r):
        return _adaptagrams.Rectangle_overlapY(self, r)

    def allowOverlap(self):
        return _adaptagrams.Rectangle_allowOverlap(self)

    def offset(self, dx, dy):
        return _adaptagrams.Rectangle_offset(self, dx, dy)

    def lineIntersections(self, x1, y1, x2, y2, ri):
        return _adaptagrams.Rectangle_lineIntersections(self, x1, y1, x2, y2, ri)

    def inside(self, x, y):
        return _adaptagrams.Rectangle_inside(self, x, y)

    def overlaps(self, x1, y1, x2, y2):
        return _adaptagrams.Rectangle_overlaps(self, x1, y1, x2, y2)

    def routeAround(self, x1, y1, x2, y2, xs, ys):
        return _adaptagrams.Rectangle_routeAround(self, x1, y1, x2, y2, xs, ys)
    __swig_setmethods__["xBorder"] = _adaptagrams.Rectangle_xBorder_set
    __swig_getmethods__["xBorder"] = _adaptagrams.Rectangle_xBorder_get
    if _newclass:
        xBorder = _swig_property(_adaptagrams.Rectangle_xBorder_get, _adaptagrams.Rectangle_xBorder_set)
    __swig_setmethods__["yBorder"] = _adaptagrams.Rectangle_yBorder_set
    __swig_getmethods__["yBorder"] = _adaptagrams.Rectangle_yBorder_get
    if _newclass:
        yBorder = _swig_property(_adaptagrams.Rectangle_yBorder_get, _adaptagrams.Rectangle_yBorder_set)
Rectangle_swigregister = _adaptagrams.Rectangle_swigregister
Rectangle_swigregister(Rectangle)
cvar = _adaptagrams.cvar


def __lshift__(os, r):
    return _adaptagrams.__lshift__(os, r)
__lshift__ = _adaptagrams.__lshift__

def generateXConstraints(rs, vars, cs, useNeighbourLists):
    return _adaptagrams.generateXConstraints(rs, vars, cs, useNeighbourLists)
generateXConstraints = _adaptagrams.generateXConstraints

def generateYConstraints(rs, vars, cs):
    return _adaptagrams.generateYConstraints(rs, vars, cs)
generateYConstraints = _adaptagrams.generateYConstraints

def removeoverlaps(*args):
    return _adaptagrams.removeoverlaps(*args)
removeoverlaps = _adaptagrams.removeoverlaps

def noRectangleOverlaps(rs):
    return _adaptagrams.noRectangleOverlaps(rs)
noRectangleOverlaps = _adaptagrams.noRectangleOverlaps
class delete_object(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, delete_object, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, delete_object, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _adaptagrams.new_delete_object()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _adaptagrams.delete_delete_object
    __del__ = lambda self: None
delete_object_swigregister = _adaptagrams.delete_object_swigregister
delete_object_swigregister(delete_object)

class VariableIDMap(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VariableIDMap, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VariableIDMap, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _adaptagrams.new_VariableIDMap()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _adaptagrams.delete_VariableIDMap
    __del__ = lambda self: None

    def addMappingForVariable(self, arg2, to):
        return _adaptagrams.VariableIDMap_addMappingForVariable(self, arg2, to)

    def mappingForVariable(self, var, forward=True):
        return _adaptagrams.VariableIDMap_mappingForVariable(self, var, forward)

    def clear(self):
        return _adaptagrams.VariableIDMap_clear(self)

    def printCreationCode(self, fp):
        return _adaptagrams.VariableIDMap_printCreationCode(self, fp)
VariableIDMap_swigregister = _adaptagrams.VariableIDMap_swigregister
VariableIDMap_swigregister(VariableIDMap)
freeWeight = cvar.freeWeight
DEFAULT_CONSTRAINT_PRIORITY = cvar.DEFAULT_CONSTRAINT_PRIORITY
PRIORITY_NONOVERLAP = cvar.PRIORITY_NONOVERLAP

class CompoundConstraint(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CompoundConstraint, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CompoundConstraint, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def generateVariables(self, dim, vars):
        return _adaptagrams.CompoundConstraint_generateVariables(self, dim, vars)

    def generateSeparationConstraints(self, dim, var, cs, bbs):
        return _adaptagrams.CompoundConstraint_generateSeparationConstraints(self, dim, var, cs, bbs)

    def updatePosition(self, dim):
        return _adaptagrams.CompoundConstraint_updatePosition(self, dim)

    def toString(self):
        return _adaptagrams.CompoundConstraint_toString(self)

    def dimension(self):
        return _adaptagrams.CompoundConstraint_dimension(self)

    def priority(self):
        return _adaptagrams.CompoundConstraint_priority(self)

    def updateVarIDsWithMapping(self, idMap, forward=True):
        return _adaptagrams.CompoundConstraint_updateVarIDsWithMapping(self, idMap, forward)

    def updateShapeOffsetsForDifferentCentres(self, offsets, forward=True):
        return _adaptagrams.CompoundConstraint_updateShapeOffsetsForDifferentCentres(self, offsets, forward)

    def markAllSubConstraintsAsInactive(self):
        return _adaptagrams.CompoundConstraint_markAllSubConstraintsAsInactive(self)

    def subConstraintsRemaining(self):
        return _adaptagrams.CompoundConstraint_subConstraintsRemaining(self)

    def markCurrSubConstraintAsActive(self, satisfiable):
        return _adaptagrams.CompoundConstraint_markCurrSubConstraintAsActive(self, satisfiable)

    def getCurrSubConstraintAlternatives(self, vs):
        return _adaptagrams.CompoundConstraint_getCurrSubConstraintAlternatives(self, vs)

    def subConstraintObjIndexes(self):
        return _adaptagrams.CompoundConstraint_subConstraintObjIndexes(self)

    def printCreationCode(self, fp):
        return _adaptagrams.CompoundConstraint_printCreationCode(self, fp)

    def shouldCombineSubConstraints(self):
        return _adaptagrams.CompoundConstraint_shouldCombineSubConstraints(self)
CompoundConstraint_swigregister = _adaptagrams.CompoundConstraint_swigregister
CompoundConstraint_swigregister(CompoundConstraint)


def generateVariablesAndConstraints(ccs, dim, vars, cs, bbs):
    return _adaptagrams.generateVariablesAndConstraints(ccs, dim, vars, cs, bbs)
generateVariablesAndConstraints = _adaptagrams.generateVariablesAndConstraints

def generateVariables(ccs, dim, vars):
    return _adaptagrams.generateVariables(ccs, dim, vars)
generateVariables = _adaptagrams.generateVariables
class BoundaryConstraint(CompoundConstraint):
    __swig_setmethods__ = {}
    for _s in [CompoundConstraint]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BoundaryConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [CompoundConstraint]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BoundaryConstraint, name)
    __repr__ = _swig_repr

    def __init__(self, dim):
        this = _adaptagrams.new_BoundaryConstraint(dim)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def addShape(self, index, offset):
        return _adaptagrams.BoundaryConstraint_addShape(self, index, offset)

    def toString(self):
        return _adaptagrams.BoundaryConstraint_toString(self)

    def getCurrSubConstraintAlternatives(self, vs):
        return _adaptagrams.BoundaryConstraint_getCurrSubConstraintAlternatives(self, vs)

    def generateVariables(self, dim, vars):
        return _adaptagrams.BoundaryConstraint_generateVariables(self, dim, vars)

    def generateSeparationConstraints(self, dim, vars, cs, bbs):
        return _adaptagrams.BoundaryConstraint_generateSeparationConstraints(self, dim, vars, cs, bbs)

    def updatePosition(self, dim):
        return _adaptagrams.BoundaryConstraint_updatePosition(self, dim)

    def printCreationCode(self, fp):
        return _adaptagrams.BoundaryConstraint_printCreationCode(self, fp)
    __swig_setmethods__["position"] = _adaptagrams.BoundaryConstraint_position_set
    __swig_getmethods__["position"] = _adaptagrams.BoundaryConstraint_position_get
    if _newclass:
        position = _swig_property(_adaptagrams.BoundaryConstraint_position_get, _adaptagrams.BoundaryConstraint_position_set)
    __swig_setmethods__["variable"] = _adaptagrams.BoundaryConstraint_variable_set
    __swig_getmethods__["variable"] = _adaptagrams.BoundaryConstraint_variable_get
    if _newclass:
        variable = _swig_property(_adaptagrams.BoundaryConstraint_variable_get, _adaptagrams.BoundaryConstraint_variable_set)
BoundaryConstraint_swigregister = _adaptagrams.BoundaryConstraint_swigregister
BoundaryConstraint_swigregister(BoundaryConstraint)

class AlignmentConstraint(CompoundConstraint):
    __swig_setmethods__ = {}
    for _s in [CompoundConstraint]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AlignmentConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [CompoundConstraint]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AlignmentConstraint, name)
    __repr__ = _swig_repr

    def __init__(self, dim, position=0.0):
        this = _adaptagrams.new_AlignmentConstraint(dim, position)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def addShape(self, index, offset):
        return _adaptagrams.AlignmentConstraint_addShape(self, index, offset)

    def fixPos(self, pos):
        return _adaptagrams.AlignmentConstraint_fixPos(self, pos)

    def unfixPos(self):
        return _adaptagrams.AlignmentConstraint_unfixPos(self)

    def isFixed(self):
        return _adaptagrams.AlignmentConstraint_isFixed(self)

    def toString(self):
        return _adaptagrams.AlignmentConstraint_toString(self)

    def getCurrSubConstraintAlternatives(self, vs):
        return _adaptagrams.AlignmentConstraint_getCurrSubConstraintAlternatives(self, vs)

    def generateVariables(self, dim, vars):
        return _adaptagrams.AlignmentConstraint_generateVariables(self, dim, vars)

    def generateSeparationConstraints(self, dim, vars, cs, bbs):
        return _adaptagrams.AlignmentConstraint_generateSeparationConstraints(self, dim, vars, cs, bbs)

    def updatePosition(self, dim):
        return _adaptagrams.AlignmentConstraint_updatePosition(self, dim)

    def position(self):
        return _adaptagrams.AlignmentConstraint_position(self)

    def printCreationCode(self, fp):
        return _adaptagrams.AlignmentConstraint_printCreationCode(self, fp)

    def updateShapeOffsetsForDifferentCentres(self, offsets, forward=True):
        return _adaptagrams.AlignmentConstraint_updateShapeOffsetsForDifferentCentres(self, offsets, forward)
    __swig_setmethods__["indicator"] = _adaptagrams.AlignmentConstraint_indicator_set
    __swig_getmethods__["indicator"] = _adaptagrams.AlignmentConstraint_indicator_get
    if _newclass:
        indicator = _swig_property(_adaptagrams.AlignmentConstraint_indicator_get, _adaptagrams.AlignmentConstraint_indicator_set)
    __swig_setmethods__["variable"] = _adaptagrams.AlignmentConstraint_variable_set
    __swig_getmethods__["variable"] = _adaptagrams.AlignmentConstraint_variable_get
    if _newclass:
        variable = _swig_property(_adaptagrams.AlignmentConstraint_variable_get, _adaptagrams.AlignmentConstraint_variable_set)
AlignmentConstraint_swigregister = _adaptagrams.AlignmentConstraint_swigregister
AlignmentConstraint_swigregister(AlignmentConstraint)

class SeparationConstraint(CompoundConstraint):
    __swig_setmethods__ = {}
    for _s in [CompoundConstraint]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SeparationConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [CompoundConstraint]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SeparationConstraint, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _adaptagrams.new_SeparationConstraint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def toString(self):
        return _adaptagrams.SeparationConstraint_toString(self)

    def getCurrSubConstraintAlternatives(self, vs):
        return _adaptagrams.SeparationConstraint_getCurrSubConstraintAlternatives(self, vs)

    def generateVariables(self, dim, vars):
        return _adaptagrams.SeparationConstraint_generateVariables(self, dim, vars)

    def generateSeparationConstraints(self, dim, vs, cs, bbs):
        return _adaptagrams.SeparationConstraint_generateSeparationConstraints(self, dim, vs, cs, bbs)

    def setSeparation(self, gap):
        return _adaptagrams.SeparationConstraint_setSeparation(self, gap)

    def left(self):
        return _adaptagrams.SeparationConstraint_left(self)

    def right(self):
        return _adaptagrams.SeparationConstraint_right(self)

    def printCreationCode(self, fp):
        return _adaptagrams.SeparationConstraint_printCreationCode(self, fp)
    __swig_setmethods__["gap"] = _adaptagrams.SeparationConstraint_gap_set
    __swig_getmethods__["gap"] = _adaptagrams.SeparationConstraint_gap_get
    if _newclass:
        gap = _swig_property(_adaptagrams.SeparationConstraint_gap_get, _adaptagrams.SeparationConstraint_gap_set)
    __swig_setmethods__["equality"] = _adaptagrams.SeparationConstraint_equality_set
    __swig_getmethods__["equality"] = _adaptagrams.SeparationConstraint_equality_get
    if _newclass:
        equality = _swig_property(_adaptagrams.SeparationConstraint_equality_get, _adaptagrams.SeparationConstraint_equality_set)
    __swig_setmethods__["vpscConstraint"] = _adaptagrams.SeparationConstraint_vpscConstraint_set
    __swig_getmethods__["vpscConstraint"] = _adaptagrams.SeparationConstraint_vpscConstraint_get
    if _newclass:
        vpscConstraint = _swig_property(_adaptagrams.SeparationConstraint_vpscConstraint_get, _adaptagrams.SeparationConstraint_vpscConstraint_set)
SeparationConstraint_swigregister = _adaptagrams.SeparationConstraint_swigregister
SeparationConstraint_swigregister(SeparationConstraint)

class OrthogonalEdgeConstraint(CompoundConstraint):
    __swig_setmethods__ = {}
    for _s in [CompoundConstraint]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OrthogonalEdgeConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [CompoundConstraint]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, OrthogonalEdgeConstraint, name)
    __repr__ = _swig_repr

    def __init__(self, dim, l, r):
        this = _adaptagrams.new_OrthogonalEdgeConstraint(dim, l, r)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getCurrSubConstraintAlternatives(self, vs):
        return _adaptagrams.OrthogonalEdgeConstraint_getCurrSubConstraintAlternatives(self, vs)

    def generateVariables(self, dim, vars):
        return _adaptagrams.OrthogonalEdgeConstraint_generateVariables(self, dim, vars)

    def generateSeparationConstraints(self, dim, vs, cs, bbs):
        return _adaptagrams.OrthogonalEdgeConstraint_generateSeparationConstraints(self, dim, vs, cs, bbs)

    def generateTopologyConstraints(self, k, rs, vars, cs):
        return _adaptagrams.OrthogonalEdgeConstraint_generateTopologyConstraints(self, k, rs, vars, cs)

    def printCreationCode(self, fp):
        return _adaptagrams.OrthogonalEdgeConstraint_printCreationCode(self, fp)

    def toString(self):
        return _adaptagrams.OrthogonalEdgeConstraint_toString(self)
    __swig_setmethods__["left"] = _adaptagrams.OrthogonalEdgeConstraint_left_set
    __swig_getmethods__["left"] = _adaptagrams.OrthogonalEdgeConstraint_left_get
    if _newclass:
        left = _swig_property(_adaptagrams.OrthogonalEdgeConstraint_left_get, _adaptagrams.OrthogonalEdgeConstraint_left_set)
    __swig_setmethods__["right"] = _adaptagrams.OrthogonalEdgeConstraint_right_set
    __swig_getmethods__["right"] = _adaptagrams.OrthogonalEdgeConstraint_right_get
    if _newclass:
        right = _swig_property(_adaptagrams.OrthogonalEdgeConstraint_right_get, _adaptagrams.OrthogonalEdgeConstraint_right_set)
    __swig_setmethods__["vpscConstraint"] = _adaptagrams.OrthogonalEdgeConstraint_vpscConstraint_set
    __swig_getmethods__["vpscConstraint"] = _adaptagrams.OrthogonalEdgeConstraint_vpscConstraint_get
    if _newclass:
        vpscConstraint = _swig_property(_adaptagrams.OrthogonalEdgeConstraint_vpscConstraint_get, _adaptagrams.OrthogonalEdgeConstraint_vpscConstraint_set)
OrthogonalEdgeConstraint_swigregister = _adaptagrams.OrthogonalEdgeConstraint_swigregister
OrthogonalEdgeConstraint_swigregister(OrthogonalEdgeConstraint)

class MultiSeparationConstraint(CompoundConstraint):
    __swig_setmethods__ = {}
    for _s in [CompoundConstraint]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MultiSeparationConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [CompoundConstraint]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MultiSeparationConstraint, name)
    __repr__ = _swig_repr

    def __init__(self, dim, minSep=0, equality=False):
        this = _adaptagrams.new_MultiSeparationConstraint(dim, minSep, equality)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def addAlignmentPair(self, ac1, ac2):
        return _adaptagrams.MultiSeparationConstraint_addAlignmentPair(self, ac1, ac2)

    def setSeparation(self, sep):
        return _adaptagrams.MultiSeparationConstraint_setSeparation(self, sep)

    def toString(self):
        return _adaptagrams.MultiSeparationConstraint_toString(self)

    def getCurrSubConstraintAlternatives(self, vs):
        return _adaptagrams.MultiSeparationConstraint_getCurrSubConstraintAlternatives(self, vs)

    def generateVariables(self, dim, vars):
        return _adaptagrams.MultiSeparationConstraint_generateVariables(self, dim, vars)

    def generateSeparationConstraints(self, dim, vs, gcs, bbs):
        return _adaptagrams.MultiSeparationConstraint_generateSeparationConstraints(self, dim, vs, gcs, bbs)

    def printCreationCode(self, fp):
        return _adaptagrams.MultiSeparationConstraint_printCreationCode(self, fp)
    __swig_setmethods__["cs"] = _adaptagrams.MultiSeparationConstraint_cs_set
    __swig_getmethods__["cs"] = _adaptagrams.MultiSeparationConstraint_cs_get
    if _newclass:
        cs = _swig_property(_adaptagrams.MultiSeparationConstraint_cs_get, _adaptagrams.MultiSeparationConstraint_cs_set)
    __swig_setmethods__["indicator"] = _adaptagrams.MultiSeparationConstraint_indicator_set
    __swig_getmethods__["indicator"] = _adaptagrams.MultiSeparationConstraint_indicator_get
    if _newclass:
        indicator = _swig_property(_adaptagrams.MultiSeparationConstraint_indicator_get, _adaptagrams.MultiSeparationConstraint_indicator_set)
    __swig_setmethods__["sep"] = _adaptagrams.MultiSeparationConstraint_sep_set
    __swig_getmethods__["sep"] = _adaptagrams.MultiSeparationConstraint_sep_get
    if _newclass:
        sep = _swig_property(_adaptagrams.MultiSeparationConstraint_sep_get, _adaptagrams.MultiSeparationConstraint_sep_set)
    __swig_setmethods__["equality"] = _adaptagrams.MultiSeparationConstraint_equality_set
    __swig_getmethods__["equality"] = _adaptagrams.MultiSeparationConstraint_equality_get
    if _newclass:
        equality = _swig_property(_adaptagrams.MultiSeparationConstraint_equality_get, _adaptagrams.MultiSeparationConstraint_equality_set)
MultiSeparationConstraint_swigregister = _adaptagrams.MultiSeparationConstraint_swigregister
MultiSeparationConstraint_swigregister(MultiSeparationConstraint)

class DistributionConstraint(CompoundConstraint):
    __swig_setmethods__ = {}
    for _s in [CompoundConstraint]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DistributionConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [CompoundConstraint]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DistributionConstraint, name)
    __repr__ = _swig_repr

    def __init__(self, dim):
        this = _adaptagrams.new_DistributionConstraint(dim)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def addAlignmentPair(self, ac1, ac2):
        return _adaptagrams.DistributionConstraint_addAlignmentPair(self, ac1, ac2)

    def setSeparation(self, sep):
        return _adaptagrams.DistributionConstraint_setSeparation(self, sep)

    def toString(self):
        return _adaptagrams.DistributionConstraint_toString(self)

    def getCurrSubConstraintAlternatives(self, vs):
        return _adaptagrams.DistributionConstraint_getCurrSubConstraintAlternatives(self, vs)

    def generateVariables(self, dim, vars):
        return _adaptagrams.DistributionConstraint_generateVariables(self, dim, vars)

    def generateSeparationConstraints(self, dim, vars, gcs, bbs):
        return _adaptagrams.DistributionConstraint_generateSeparationConstraints(self, dim, vars, gcs, bbs)

    def printCreationCode(self, fp):
        return _adaptagrams.DistributionConstraint_printCreationCode(self, fp)
    __swig_setmethods__["cs"] = _adaptagrams.DistributionConstraint_cs_set
    __swig_getmethods__["cs"] = _adaptagrams.DistributionConstraint_cs_get
    if _newclass:
        cs = _swig_property(_adaptagrams.DistributionConstraint_cs_get, _adaptagrams.DistributionConstraint_cs_set)
    __swig_setmethods__["indicator"] = _adaptagrams.DistributionConstraint_indicator_set
    __swig_getmethods__["indicator"] = _adaptagrams.DistributionConstraint_indicator_get
    if _newclass:
        indicator = _swig_property(_adaptagrams.DistributionConstraint_indicator_get, _adaptagrams.DistributionConstraint_indicator_set)
    __swig_setmethods__["sep"] = _adaptagrams.DistributionConstraint_sep_set
    __swig_getmethods__["sep"] = _adaptagrams.DistributionConstraint_sep_get
    if _newclass:
        sep = _swig_property(_adaptagrams.DistributionConstraint_sep_get, _adaptagrams.DistributionConstraint_sep_set)
DistributionConstraint_swigregister = _adaptagrams.DistributionConstraint_swigregister
DistributionConstraint_swigregister(DistributionConstraint)

class FixedRelativeConstraint(CompoundConstraint):
    __swig_setmethods__ = {}
    for _s in [CompoundConstraint]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FixedRelativeConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [CompoundConstraint]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FixedRelativeConstraint, name)
    __repr__ = _swig_repr

    def __init__(self, rs, shapeIds, fixedPosition=False):
        this = _adaptagrams.new_FixedRelativeConstraint(rs, shapeIds, fixedPosition)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def toString(self):
        return _adaptagrams.FixedRelativeConstraint_toString(self)

    def getCurrSubConstraintAlternatives(self, vs):
        return _adaptagrams.FixedRelativeConstraint_getCurrSubConstraintAlternatives(self, vs)

    def generateVariables(self, dim, vars):
        return _adaptagrams.FixedRelativeConstraint_generateVariables(self, dim, vars)

    def generateSeparationConstraints(self, dim, vars, gcs, bbs):
        return _adaptagrams.FixedRelativeConstraint_generateSeparationConstraints(self, dim, vars, gcs, bbs)

    def printCreationCode(self, fp):
        return _adaptagrams.FixedRelativeConstraint_printCreationCode(self, fp)

    def updateVarIDsWithMapping(self, idMap, forward=True):
        return _adaptagrams.FixedRelativeConstraint_updateVarIDsWithMapping(self, idMap, forward)
FixedRelativeConstraint_swigregister = _adaptagrams.FixedRelativeConstraint_swigregister
FixedRelativeConstraint_swigregister(FixedRelativeConstraint)

class PageBoundaryConstraints(CompoundConstraint):
    __swig_setmethods__ = {}
    for _s in [CompoundConstraint]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PageBoundaryConstraints, name, value)
    __swig_getmethods__ = {}
    for _s in [CompoundConstraint]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PageBoundaryConstraints, name)
    __repr__ = _swig_repr

    def __init__(self, xLow, xHigh, yLow, yHigh, weight=100.0):
        this = _adaptagrams.new_PageBoundaryConstraints(xLow, xHigh, yLow, yHigh, weight)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def addShape(self, index, halfW, halfH):
        return _adaptagrams.PageBoundaryConstraints_addShape(self, index, halfW, halfH)

    def toString(self):
        return _adaptagrams.PageBoundaryConstraints_toString(self)

    def getCurrSubConstraintAlternatives(self, vs):
        return _adaptagrams.PageBoundaryConstraints_getCurrSubConstraintAlternatives(self, vs)

    def generateVariables(self, dim, vars):
        return _adaptagrams.PageBoundaryConstraints_generateVariables(self, dim, vars)

    def generateSeparationConstraints(self, dim, vars, gcs, bbs):
        return _adaptagrams.PageBoundaryConstraints_generateSeparationConstraints(self, dim, vars, gcs, bbs)

    def updatePosition(self, dim):
        return _adaptagrams.PageBoundaryConstraints_updatePosition(self, dim)

    def getActualLeftMargin(self, dim):
        return _adaptagrams.PageBoundaryConstraints_getActualLeftMargin(self, dim)

    def getActualRightMargin(self, dim):
        return _adaptagrams.PageBoundaryConstraints_getActualRightMargin(self, dim)

    def printCreationCode(self, fp):
        return _adaptagrams.PageBoundaryConstraints_printCreationCode(self, fp)
PageBoundaryConstraints_swigregister = _adaptagrams.PageBoundaryConstraints_swigregister
PageBoundaryConstraints_swigregister(PageBoundaryConstraints)

class UnsatisfiableConstraintInfo(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, UnsatisfiableConstraintInfo, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, UnsatisfiableConstraintInfo, name)
    __repr__ = _swig_repr

    def __init__(self, c):
        this = _adaptagrams.new_UnsatisfiableConstraintInfo(c)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["leftVarIndex"] = _adaptagrams.UnsatisfiableConstraintInfo_leftVarIndex_set
    __swig_getmethods__["leftVarIndex"] = _adaptagrams.UnsatisfiableConstraintInfo_leftVarIndex_get
    if _newclass:
        leftVarIndex = _swig_property(_adaptagrams.UnsatisfiableConstraintInfo_leftVarIndex_get, _adaptagrams.UnsatisfiableConstraintInfo_leftVarIndex_set)
    __swig_setmethods__["rightVarIndex"] = _adaptagrams.UnsatisfiableConstraintInfo_rightVarIndex_set
    __swig_getmethods__["rightVarIndex"] = _adaptagrams.UnsatisfiableConstraintInfo_rightVarIndex_get
    if _newclass:
        rightVarIndex = _swig_property(_adaptagrams.UnsatisfiableConstraintInfo_rightVarIndex_get, _adaptagrams.UnsatisfiableConstraintInfo_rightVarIndex_set)
    __swig_setmethods__["separation"] = _adaptagrams.UnsatisfiableConstraintInfo_separation_set
    __swig_getmethods__["separation"] = _adaptagrams.UnsatisfiableConstraintInfo_separation_get
    if _newclass:
        separation = _swig_property(_adaptagrams.UnsatisfiableConstraintInfo_separation_get, _adaptagrams.UnsatisfiableConstraintInfo_separation_set)
    __swig_setmethods__["equality"] = _adaptagrams.UnsatisfiableConstraintInfo_equality_set
    __swig_getmethods__["equality"] = _adaptagrams.UnsatisfiableConstraintInfo_equality_get
    if _newclass:
        equality = _swig_property(_adaptagrams.UnsatisfiableConstraintInfo_equality_get, _adaptagrams.UnsatisfiableConstraintInfo_equality_set)
    __swig_setmethods__["cc"] = _adaptagrams.UnsatisfiableConstraintInfo_cc_set
    __swig_getmethods__["cc"] = _adaptagrams.UnsatisfiableConstraintInfo_cc_get
    if _newclass:
        cc = _swig_property(_adaptagrams.UnsatisfiableConstraintInfo_cc_get, _adaptagrams.UnsatisfiableConstraintInfo_cc_set)

    def toString(self):
        return _adaptagrams.UnsatisfiableConstraintInfo_toString(self)
    __swig_destroy__ = _adaptagrams.delete_UnsatisfiableConstraintInfo
    __del__ = lambda self: None
UnsatisfiableConstraintInfo_swigregister = _adaptagrams.UnsatisfiableConstraintInfo_swigregister
UnsatisfiableConstraintInfo_swigregister(UnsatisfiableConstraintInfo)

class Lock(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Lock, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Lock, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _adaptagrams.new_Lock(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getID(self):
        return _adaptagrams.Lock_getID(self)

    def pos(self, dim):
        return _adaptagrams.Lock_pos(self, dim)
Lock_swigregister = _adaptagrams.Lock_swigregister
Lock_swigregister(Lock)

class Resize(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Resize, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Resize, name)
    __repr__ = _swig_repr

    def __init__(self, id, x, y, w, h):
        this = _adaptagrams.new_Resize(id, x, y, w, h)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getID(self):
        return _adaptagrams.Resize_getID(self)

    def getTarget(self):
        return _adaptagrams.Resize_getTarget(self)
Resize_swigregister = _adaptagrams.Resize_swigregister
Resize_swigregister(Resize)

class DesiredPosition(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DesiredPosition, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DesiredPosition, name)
    __repr__ = _swig_repr
    __swig_setmethods__["id"] = _adaptagrams.DesiredPosition_id_set
    __swig_getmethods__["id"] = _adaptagrams.DesiredPosition_id_get
    if _newclass:
        id = _swig_property(_adaptagrams.DesiredPosition_id_get, _adaptagrams.DesiredPosition_id_set)
    __swig_setmethods__["x"] = _adaptagrams.DesiredPosition_x_set
    __swig_getmethods__["x"] = _adaptagrams.DesiredPosition_x_get
    if _newclass:
        x = _swig_property(_adaptagrams.DesiredPosition_x_get, _adaptagrams.DesiredPosition_x_set)
    __swig_setmethods__["y"] = _adaptagrams.DesiredPosition_y_set
    __swig_getmethods__["y"] = _adaptagrams.DesiredPosition_y_get
    if _newclass:
        y = _swig_property(_adaptagrams.DesiredPosition_y_get, _adaptagrams.DesiredPosition_y_set)
    __swig_setmethods__["weight"] = _adaptagrams.DesiredPosition_weight_set
    __swig_getmethods__["weight"] = _adaptagrams.DesiredPosition_weight_get
    if _newclass:
        weight = _swig_property(_adaptagrams.DesiredPosition_weight_get, _adaptagrams.DesiredPosition_weight_set)

    def __init__(self):
        this = _adaptagrams.new_DesiredPosition()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _adaptagrams.delete_DesiredPosition
    __del__ = lambda self: None
DesiredPosition_swigregister = _adaptagrams.DesiredPosition_swigregister
DesiredPosition_swigregister(DesiredPosition)

class PreIteration(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PreIteration, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PreIteration, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _adaptagrams.new_PreIteration(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["locks"] = _adaptagrams.PreIteration_locks_set
    __swig_getmethods__["locks"] = _adaptagrams.PreIteration_locks_get
    if _newclass:
        locks = _swig_property(_adaptagrams.PreIteration_locks_get, _adaptagrams.PreIteration_locks_set)
    __swig_setmethods__["resizes"] = _adaptagrams.PreIteration_resizes_set
    __swig_getmethods__["resizes"] = _adaptagrams.PreIteration_resizes_get
    if _newclass:
        resizes = _swig_property(_adaptagrams.PreIteration_resizes_get, _adaptagrams.PreIteration_resizes_set)
    __swig_setmethods__["changed"] = _adaptagrams.PreIteration_changed_set
    __swig_getmethods__["changed"] = _adaptagrams.PreIteration_changed_get
    if _newclass:
        changed = _swig_property(_adaptagrams.PreIteration_changed_get, _adaptagrams.PreIteration_changed_set)
PreIteration_swigregister = _adaptagrams.PreIteration_swigregister
PreIteration_swigregister(PreIteration)

class TestConvergence(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TestConvergence, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TestConvergence, name)
    __repr__ = _swig_repr
    __swig_setmethods__["old_stress"] = _adaptagrams.TestConvergence_old_stress_set
    __swig_getmethods__["old_stress"] = _adaptagrams.TestConvergence_old_stress_get
    if _newclass:
        old_stress = _swig_property(_adaptagrams.TestConvergence_old_stress_get, _adaptagrams.TestConvergence_old_stress_set)

    def __init__(self, tol=1e-4, maxiterations=100):
        if self.__class__ == TestConvergence:
            _self = None
        else:
            _self = self
        this = _adaptagrams.new_TestConvergence(_self, tol, maxiterations)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _adaptagrams.delete_TestConvergence
    __del__ = lambda self: None

    def ColaTestConvergenceOperator(self, new_stress, X, Y):
        return _adaptagrams.TestConvergence_ColaTestConvergenceOperator(self, new_stress, X, Y)

    def reset(self):
        return _adaptagrams.TestConvergence_reset(self)
    __swig_getmethods__["tolerance"] = _adaptagrams.TestConvergence_tolerance_get
    if _newclass:
        tolerance = _swig_property(_adaptagrams.TestConvergence_tolerance_get)
    __swig_getmethods__["maxiterations"] = _adaptagrams.TestConvergence_maxiterations_get
    if _newclass:
        maxiterations = _swig_property(_adaptagrams.TestConvergence_maxiterations_get)
    __swig_setmethods__["iterations"] = _adaptagrams.TestConvergence_iterations_set
    __swig_getmethods__["iterations"] = _adaptagrams.TestConvergence_iterations_get
    if _newclass:
        iterations = _swig_property(_adaptagrams.TestConvergence_iterations_get, _adaptagrams.TestConvergence_iterations_set)
    def __disown__(self):
        self.this.disown()
        _adaptagrams.disown_TestConvergence(self)
        return weakref_proxy(self)
TestConvergence_swigregister = _adaptagrams.TestConvergence_swigregister
TestConvergence_swigregister(TestConvergence)

class ConstrainedMajorizationLayout(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConstrainedMajorizationLayout, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ConstrainedMajorizationLayout, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _adaptagrams.new_ConstrainedMajorizationLayout(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def setConstraints(self, ccs):
        return _adaptagrams.ConstrainedMajorizationLayout_setConstraints(self, ccs)

    def setConstraintsVector(self, ccs):
        return _adaptagrams.ConstrainedMajorizationLayout_setConstraintsVector(self, ccs)

    def setUnsatisfiableConstraintInfo(self, unsatisfiableX, unsatisfiableY):
        return _adaptagrams.ConstrainedMajorizationLayout_setUnsatisfiableConstraintInfo(self, unsatisfiableX, unsatisfiableY)

    def setStickyNodes(self, stickyWeight, startX, startY):
        return _adaptagrams.ConstrainedMajorizationLayout_setStickyNodes(self, stickyWeight, startX, startY)

    def setScaling(self, scaling):
        return _adaptagrams.ConstrainedMajorizationLayout_setScaling(self, scaling)

    def setExternalSolver(self, externalSolver):
        return _adaptagrams.ConstrainedMajorizationLayout_setExternalSolver(self, externalSolver)

    def setAvoidOverlaps(self, horizontal=False):
        return _adaptagrams.ConstrainedMajorizationLayout_setAvoidOverlaps(self, horizontal)

    def setNonOverlappingClusters(self):
        return _adaptagrams.ConstrainedMajorizationLayout_setNonOverlappingClusters(self)

    def setStraightenEdges(self, straightenEdges, bendWeight=0.01, potBendWeight=0.1, xSkipping=True):
        return _adaptagrams.ConstrainedMajorizationLayout_setStraightenEdges(self, straightenEdges, bendWeight, potBendWeight, xSkipping)

    def moveBoundingBoxes(self):
        return _adaptagrams.ConstrainedMajorizationLayout_moveBoundingBoxes(self)
    __swig_destroy__ = _adaptagrams.delete_ConstrainedMajorizationLayout
    __del__ = lambda self: None

    def run(self, x=True, y=True):
        return _adaptagrams.ConstrainedMajorizationLayout_run(self, x, y)

    def runOnce(self, x=True, y=True):
        return _adaptagrams.ConstrainedMajorizationLayout_runOnce(self, x, y)

    def straighten(self, arg2, arg3):
        return _adaptagrams.ConstrainedMajorizationLayout_straighten(self, arg2, arg3)

    def setConstrainedLayout(self, c):
        return _adaptagrams.ConstrainedMajorizationLayout_setConstrainedLayout(self, c)

    def computeStress(self):
        return _adaptagrams.ConstrainedMajorizationLayout_computeStress(self)
ConstrainedMajorizationLayout_swigregister = _adaptagrams.ConstrainedMajorizationLayout_swigregister
ConstrainedMajorizationLayout_swigregister(ConstrainedMajorizationLayout)


def bounds(rs):
    return _adaptagrams.bounds(rs)
bounds = _adaptagrams.bounds
class TopologyAddonInterface(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TopologyAddonInterface, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TopologyAddonInterface, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _adaptagrams.new_TopologyAddonInterface()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _adaptagrams.delete_TopologyAddonInterface
    __del__ = lambda self: None

    def clone(self):
        return _adaptagrams.TopologyAddonInterface_clone(self)

    def freeAssociatedObjects(self):
        return _adaptagrams.TopologyAddonInterface_freeAssociatedObjects(self)

    def handleResizes(self, resizeList, n, X, Y, ccs, boundingBoxes, clusterHierarchy):
        return _adaptagrams.TopologyAddonInterface_handleResizes(self, resizeList, n, X, Y, ccs, boundingBoxes, clusterHierarchy)

    def computePathLengths(self, G):
        return _adaptagrams.TopologyAddonInterface_computePathLengths(self, G)

    def computeStress(self):
        return _adaptagrams.TopologyAddonInterface_computeStress(self)

    def useTopologySolver(self):
        return _adaptagrams.TopologyAddonInterface_useTopologySolver(self)

    def makeFeasible(self, generateNonOverlapConstraints, boundingBoxes, clusterHierarchy):
        return _adaptagrams.TopologyAddonInterface_makeFeasible(self, generateNonOverlapConstraints, boundingBoxes, clusterHierarchy)

    def moveTo(self, dim, vs, cs, coords, clusterHierarchy):
        return _adaptagrams.TopologyAddonInterface_moveTo(self, dim, vs, cs, coords, clusterHierarchy)

    def applyForcesAndConstraints(self, layout, dim, g, vs, cs, coords, des, oldStress):
        return _adaptagrams.TopologyAddonInterface_applyForcesAndConstraints(self, layout, dim, g, vs, cs, coords, des, oldStress)
TopologyAddonInterface_swigregister = _adaptagrams.TopologyAddonInterface_swigregister
TopologyAddonInterface_swigregister(TopologyAddonInterface)

class ConstrainedFDLayout(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConstrainedFDLayout, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ConstrainedFDLayout, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _adaptagrams.new_ConstrainedFDLayout(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _adaptagrams.delete_ConstrainedFDLayout
    __del__ = lambda self: None

    def run(self, x=True, y=True):
        return _adaptagrams.ConstrainedFDLayout_run(self, x, y)

    def runOnce(self, x=True, y=True):
        return _adaptagrams.ConstrainedFDLayout_runOnce(self, x, y)

    def setConstraints(self, ccs):
        return _adaptagrams.ConstrainedFDLayout_setConstraints(self, ccs)

    def setAvoidNodeOverlaps(self, *args):
        return _adaptagrams.ConstrainedFDLayout_setAvoidNodeOverlaps(self, *args)

    def setTopology(self, topology):
        return _adaptagrams.ConstrainedFDLayout_setTopology(self, topology)

    def getTopology(self):
        return _adaptagrams.ConstrainedFDLayout_getTopology(self)

    def setDesiredPositions(self, desiredPositions):
        return _adaptagrams.ConstrainedFDLayout_setDesiredPositions(self, desiredPositions)

    def setClusterHierarchy(self, hierarchy):
        return _adaptagrams.ConstrainedFDLayout_setClusterHierarchy(self, hierarchy)

    def setUnsatisfiableConstraintInfo(self, unsatisfiableX, unsatisfiableY):
        return _adaptagrams.ConstrainedFDLayout_setUnsatisfiableConstraintInfo(self, unsatisfiableX, unsatisfiableY)

    def makeFeasible(self, xBorder=1, yBorder=1):
        return _adaptagrams.ConstrainedFDLayout_makeFeasible(self, xBorder, yBorder)

    def freeAssociatedObjects(self):
        return _adaptagrams.ConstrainedFDLayout_freeAssociatedObjects(self)

    def outputInstanceToSVG(self, *args):
        return _adaptagrams.ConstrainedFDLayout_outputInstanceToSVG(self, *args)

    def setUseNeighbourStress(self, useNeighbourStress):
        return _adaptagrams.ConstrainedFDLayout_setUseNeighbourStress(self, useNeighbourStress)

    def readLinearD(self):
        return _adaptagrams.ConstrainedFDLayout_readLinearD(self)

    def readLinearG(self):
        return _adaptagrams.ConstrainedFDLayout_readLinearG(self)

    def computeStress(self):
        return _adaptagrams.ConstrainedFDLayout_computeStress(self)
ConstrainedFDLayout_swigregister = _adaptagrams.ConstrainedFDLayout_swigregister
ConstrainedFDLayout_swigregister(ConstrainedFDLayout)

class ProjectionResult(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ProjectionResult, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ProjectionResult, name)
    __repr__ = _swig_repr
    __swig_setmethods__["errorLevel"] = _adaptagrams.ProjectionResult_errorLevel_set
    __swig_getmethods__["errorLevel"] = _adaptagrams.ProjectionResult_errorLevel_get
    if _newclass:
        errorLevel = _swig_property(_adaptagrams.ProjectionResult_errorLevel_get, _adaptagrams.ProjectionResult_errorLevel_set)
    __swig_setmethods__["unsatinfo"] = _adaptagrams.ProjectionResult_unsatinfo_set
    __swig_getmethods__["unsatinfo"] = _adaptagrams.ProjectionResult_unsatinfo_get
    if _newclass:
        unsatinfo = _swig_property(_adaptagrams.ProjectionResult_unsatinfo_get, _adaptagrams.ProjectionResult_unsatinfo_set)

    def __init__(self):
        this = _adaptagrams.new_ProjectionResult()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _adaptagrams.delete_ProjectionResult
    __del__ = lambda self: None
ProjectionResult_swigregister = _adaptagrams.ProjectionResult_swigregister
ProjectionResult_swigregister(ProjectionResult)


def projectOntoCCs(dim, rs, ccs, preventOverlaps, accept=0, debugLevel=0):
    return _adaptagrams.projectOntoCCs(dim, rs, ccs, preventOverlaps, accept, debugLevel)
projectOntoCCs = _adaptagrams.projectOntoCCs

def solve(vs, cs, rs, debugLevel=0):
    return _adaptagrams.solve(vs, cs, rs, debugLevel)
solve = _adaptagrams.solve

def simpleCMLFactory(rs, es, clusterHierarchy, idealLength, useNeighbourStress=False):
    return _adaptagrams.simpleCMLFactory(rs, es, clusterHierarchy, idealLength, useNeighbourStress)
simpleCMLFactory = _adaptagrams.simpleCMLFactory

def dijkstra(s, n, d, es, eLengths):
    return _adaptagrams.dijkstra(s, n, d, es, eLengths)
dijkstra = _adaptagrams.dijkstra

def setupVarsAndConstraints(n, ccs, dim, boundingBoxes, clusterHierarchy, vs, cs, coords):
    return _adaptagrams.setupVarsAndConstraints(n, ccs, dim, boundingBoxes, clusterHierarchy, vs, cs, coords)
setupVarsAndConstraints = _adaptagrams.setupVarsAndConstraints

def setVariableDesiredPositions(vs, cs, des, coords):
    return _adaptagrams.setVariableDesiredPositions(vs, cs, des, coords)
setVariableDesiredPositions = _adaptagrams.setVariableDesiredPositions
class Cluster(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Cluster, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Cluster, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def computeBoundary(self, rs):
        return _adaptagrams.Cluster_computeBoundary(self, rs)

    def computeBoundingRect(self, rs):
        return _adaptagrams.Cluster_computeBoundingRect(self, rs)

    def addChildNode(self, index):
        return _adaptagrams.Cluster_addChildNode(self, index)

    def addChildCluster(self, cluster):
        return _adaptagrams.Cluster_addChildCluster(self, cluster)

    def padding(self):
        return _adaptagrams.Cluster_padding(self)

    def margin(self):
        return _adaptagrams.Cluster_margin(self)

    def setDesiredBounds(self, bounds):
        return _adaptagrams.Cluster_setDesiredBounds(self, bounds)

    def unsetDesiredBounds(self):
        return _adaptagrams.Cluster_unsetDesiredBounds(self)

    def createVars(self, dim, rs, vars):
        return _adaptagrams.Cluster_createVars(self, dim, rs, vars)

    def printCreationCode(self, fp):
        return _adaptagrams.Cluster_printCreationCode(self, fp)

    def countContainedNodes(self, counts):
        return _adaptagrams.Cluster_countContainedNodes(self, counts)

    def clusterIsFromFixedRectangle(self):
        return _adaptagrams.Cluster_clusterIsFromFixedRectangle(self)

    def outputToSVG(self, fp):
        return _adaptagrams.Cluster_outputToSVG(self, fp)

    def area(self, rs):
        return _adaptagrams.Cluster_area(self, rs)

    def updateBounds(self, dim):
        return _adaptagrams.Cluster_updateBounds(self, dim)

    def computeVarRect(self, vs, dim):
        return _adaptagrams.Cluster_computeVarRect(self, vs, dim)
    __swig_setmethods__["bounds"] = _adaptagrams.Cluster_bounds_set
    __swig_getmethods__["bounds"] = _adaptagrams.Cluster_bounds_get
    if _newclass:
        bounds = _swig_property(_adaptagrams.Cluster_bounds_get, _adaptagrams.Cluster_bounds_set)
    __swig_setmethods__["varRect"] = _adaptagrams.Cluster_varRect_set
    __swig_getmethods__["varRect"] = _adaptagrams.Cluster_varRect_get
    if _newclass:
        varRect = _swig_property(_adaptagrams.Cluster_varRect_get, _adaptagrams.Cluster_varRect_set)
    __swig_setmethods__["vXMin"] = _adaptagrams.Cluster_vXMin_set
    __swig_getmethods__["vXMin"] = _adaptagrams.Cluster_vXMin_get
    if _newclass:
        vXMin = _swig_property(_adaptagrams.Cluster_vXMin_get, _adaptagrams.Cluster_vXMin_set)
    __swig_setmethods__["vXMax"] = _adaptagrams.Cluster_vXMax_set
    __swig_getmethods__["vXMax"] = _adaptagrams.Cluster_vXMax_get
    if _newclass:
        vXMax = _swig_property(_adaptagrams.Cluster_vXMax_get, _adaptagrams.Cluster_vXMax_set)
    __swig_setmethods__["vYMin"] = _adaptagrams.Cluster_vYMin_set
    __swig_getmethods__["vYMin"] = _adaptagrams.Cluster_vYMin_get
    if _newclass:
        vYMin = _swig_property(_adaptagrams.Cluster_vYMin_get, _adaptagrams.Cluster_vYMin_set)
    __swig_setmethods__["vYMax"] = _adaptagrams.Cluster_vYMax_set
    __swig_getmethods__["vYMax"] = _adaptagrams.Cluster_vYMax_get
    if _newclass:
        vYMax = _swig_property(_adaptagrams.Cluster_vYMax_get, _adaptagrams.Cluster_vYMax_set)
    __swig_setmethods__["clusterVarId"] = _adaptagrams.Cluster_clusterVarId_set
    __swig_getmethods__["clusterVarId"] = _adaptagrams.Cluster_clusterVarId_get
    if _newclass:
        clusterVarId = _swig_property(_adaptagrams.Cluster_clusterVarId_get, _adaptagrams.Cluster_clusterVarId_set)
    __swig_setmethods__["varWeight"] = _adaptagrams.Cluster_varWeight_set
    __swig_getmethods__["varWeight"] = _adaptagrams.Cluster_varWeight_get
    if _newclass:
        varWeight = _swig_property(_adaptagrams.Cluster_varWeight_get, _adaptagrams.Cluster_varWeight_set)
    __swig_setmethods__["internalEdgeWeightFactor"] = _adaptagrams.Cluster_internalEdgeWeightFactor_set
    __swig_getmethods__["internalEdgeWeightFactor"] = _adaptagrams.Cluster_internalEdgeWeightFactor_get
    if _newclass:
        internalEdgeWeightFactor = _swig_property(_adaptagrams.Cluster_internalEdgeWeightFactor_get, _adaptagrams.Cluster_internalEdgeWeightFactor_set)
    __swig_setmethods__["nodes"] = _adaptagrams.Cluster_nodes_set
    __swig_getmethods__["nodes"] = _adaptagrams.Cluster_nodes_get
    if _newclass:
        nodes = _swig_property(_adaptagrams.Cluster_nodes_get, _adaptagrams.Cluster_nodes_set)
    __swig_setmethods__["clusters"] = _adaptagrams.Cluster_clusters_set
    __swig_getmethods__["clusters"] = _adaptagrams.Cluster_clusters_get
    if _newclass:
        clusters = _swig_property(_adaptagrams.Cluster_clusters_get, _adaptagrams.Cluster_clusters_set)
    __swig_setmethods__["hullX"] = _adaptagrams.Cluster_hullX_set
    __swig_getmethods__["hullX"] = _adaptagrams.Cluster_hullX_get
    if _newclass:
        hullX = _swig_property(_adaptagrams.Cluster_hullX_get, _adaptagrams.Cluster_hullX_set)
    __swig_setmethods__["hullY"] = _adaptagrams.Cluster_hullY_set
    __swig_getmethods__["hullY"] = _adaptagrams.Cluster_hullY_get
    if _newclass:
        hullY = _swig_property(_adaptagrams.Cluster_hullY_get, _adaptagrams.Cluster_hullY_set)
Cluster_swigregister = _adaptagrams.Cluster_swigregister
Cluster_swigregister(Cluster)

class RootCluster(Cluster):
    __swig_setmethods__ = {}
    for _s in [Cluster]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RootCluster, name, value)
    __swig_getmethods__ = {}
    for _s in [Cluster]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RootCluster, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _adaptagrams.new_RootCluster()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def computeBoundary(self, rs):
        return _adaptagrams.RootCluster_computeBoundary(self, rs)

    def flat(self):
        return _adaptagrams.RootCluster_flat(self)

    def printCreationCode(self, fp):
        return _adaptagrams.RootCluster_printCreationCode(self, fp)

    def outputToSVG(self, fp):
        return _adaptagrams.RootCluster_outputToSVG(self, fp)

    def allowsMultipleParents(self):
        return _adaptagrams.RootCluster_allowsMultipleParents(self)

    def setAllowsMultipleParents(self, value):
        return _adaptagrams.RootCluster_setAllowsMultipleParents(self, value)
RootCluster_swigregister = _adaptagrams.RootCluster_swigregister
RootCluster_swigregister(RootCluster)

class RectangularCluster(Cluster):
    __swig_setmethods__ = {}
    for _s in [Cluster]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RectangularCluster, name, value)
    __swig_getmethods__ = {}
    for _s in [Cluster]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RectangularCluster, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _adaptagrams.new_RectangularCluster(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def setMargin(self, *args):
        return _adaptagrams.RectangularCluster_setMargin(self, *args)

    def margin(self):
        return _adaptagrams.RectangularCluster_margin(self)

    def setPadding(self, *args):
        return _adaptagrams.RectangularCluster_setPadding(self, *args)

    def padding(self):
        return _adaptagrams.RectangularCluster_padding(self)

    def computeBoundary(self, rs):
        return _adaptagrams.RectangularCluster_computeBoundary(self, rs)

    def countContainedNodes(self, counts):
        return _adaptagrams.RectangularCluster_countContainedNodes(self, counts)

    def printCreationCode(self, fp):
        return _adaptagrams.RectangularCluster_printCreationCode(self, fp)

    def outputToSVG(self, fp):
        return _adaptagrams.RectangularCluster_outputToSVG(self, fp)

    def computeBoundingRect(self, rs):
        return _adaptagrams.RectangularCluster_computeBoundingRect(self, rs)

    def addChildNode(self, index):
        return _adaptagrams.RectangularCluster_addChildNode(self, index)

    def getMinEdgeRect(self, dim):
        return _adaptagrams.RectangularCluster_getMinEdgeRect(self, dim)

    def getMaxEdgeRect(self, dim):
        return _adaptagrams.RectangularCluster_getMaxEdgeRect(self, dim)

    def clusterIsFromFixedRectangle(self):
        return _adaptagrams.RectangularCluster_clusterIsFromFixedRectangle(self)

    def rectangleIndex(self):
        return _adaptagrams.RectangularCluster_rectangleIndex(self)

    def generateFixedRectangleConstraints(self, idleConstraints, rc, vars):
        return _adaptagrams.RectangularCluster_generateFixedRectangleConstraints(self, idleConstraints, rc, vars)
RectangularCluster_swigregister = _adaptagrams.RectangularCluster_swigregister
RectangularCluster_swigregister(RectangularCluster)

class ConvexCluster(Cluster):
    __swig_setmethods__ = {}
    for _s in [Cluster]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConvexCluster, name, value)
    __swig_getmethods__ = {}
    for _s in [Cluster]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConvexCluster, name)
    __repr__ = _swig_repr

    def computeBoundary(self, rs):
        return _adaptagrams.ConvexCluster_computeBoundary(self, rs)

    def printCreationCode(self, fp):
        return _adaptagrams.ConvexCluster_printCreationCode(self, fp)

    def outputToSVG(self, fp):
        return _adaptagrams.ConvexCluster_outputToSVG(self, fp)
    __swig_setmethods__["hullRIDs"] = _adaptagrams.ConvexCluster_hullRIDs_set
    __swig_getmethods__["hullRIDs"] = _adaptagrams.ConvexCluster_hullRIDs_get
    if _newclass:
        hullRIDs = _swig_property(_adaptagrams.ConvexCluster_hullRIDs_get, _adaptagrams.ConvexCluster_hullRIDs_set)
    __swig_setmethods__["hullCorners"] = _adaptagrams.ConvexCluster_hullCorners_set
    __swig_getmethods__["hullCorners"] = _adaptagrams.ConvexCluster_hullCorners_get
    if _newclass:
        hullCorners = _swig_property(_adaptagrams.ConvexCluster_hullCorners_get, _adaptagrams.ConvexCluster_hullCorners_set)

    def __init__(self):
        this = _adaptagrams.new_ConvexCluster()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
ConvexCluster_swigregister = _adaptagrams.ConvexCluster_swigregister
ConvexCluster_swigregister(ConvexCluster)


def convex(*args):
    return _adaptagrams.convex(*args)
convex = _adaptagrams.convex
class InvalidConstraint(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, InvalidConstraint, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, InvalidConstraint, name)
    __repr__ = _swig_repr

    def __init__(self, c):
        this = _adaptagrams.new_InvalidConstraint(c)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["constraint"] = _adaptagrams.InvalidConstraint_constraint_set
    __swig_getmethods__["constraint"] = _adaptagrams.InvalidConstraint_constraint_get
    if _newclass:
        constraint = _swig_property(_adaptagrams.InvalidConstraint_constraint_get, _adaptagrams.InvalidConstraint_constraint_set)
    __swig_destroy__ = _adaptagrams.delete_InvalidConstraint
    __del__ = lambda self: None
InvalidConstraint_swigregister = _adaptagrams.InvalidConstraint_swigregister
InvalidConstraint_swigregister(InvalidConstraint)

class InvalidVariableIndexException(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, InvalidVariableIndexException, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, InvalidVariableIndexException, name)
    __repr__ = _swig_repr

    def __init__(self, c, i):
        this = _adaptagrams.new_InvalidVariableIndexException(c, i)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def what(self):
        return _adaptagrams.InvalidVariableIndexException_what(self)
    __swig_setmethods__["constraint"] = _adaptagrams.InvalidVariableIndexException_constraint_set
    __swig_getmethods__["constraint"] = _adaptagrams.InvalidVariableIndexException_constraint_get
    if _newclass:
        constraint = _swig_property(_adaptagrams.InvalidVariableIndexException_constraint_get, _adaptagrams.InvalidVariableIndexException_constraint_set)
    __swig_setmethods__["index"] = _adaptagrams.InvalidVariableIndexException_index_set
    __swig_getmethods__["index"] = _adaptagrams.InvalidVariableIndexException_index_get
    if _newclass:
        index = _swig_property(_adaptagrams.InvalidVariableIndexException_index_get, _adaptagrams.InvalidVariableIndexException_index_set)
    __swig_destroy__ = _adaptagrams.delete_InvalidVariableIndexException
    __del__ = lambda self: None
InvalidVariableIndexException_swigregister = _adaptagrams.InvalidVariableIndexException_swigregister
InvalidVariableIndexException_swigregister(InvalidVariableIndexException)


def euclideanDist(a, b):
    return _adaptagrams.euclideanDist(a, b)
euclideanDist = _adaptagrams.euclideanDist

def manhattanDist(a, b):
    return _adaptagrams.manhattanDist(a, b)
manhattanDist = _adaptagrams.manhattanDist

def totalLength(poly):
    return _adaptagrams.totalLength(poly)
totalLength = _adaptagrams.totalLength

def angle(a, b, c):
    return _adaptagrams.angle(a, b, c)
angle = _adaptagrams.angle

def segmentIntersect(a, b, c, d):
    return _adaptagrams.segmentIntersect(a, b, c, d)
segmentIntersect = _adaptagrams.segmentIntersect

def segmentShapeIntersect(e1, e2, s1, s2, seenIntersectionAtEndpoint):
    return _adaptagrams.segmentShapeIntersect(e1, e2, s1, s2, seenIntersectionAtEndpoint)
segmentShapeIntersect = _adaptagrams.segmentShapeIntersect

def inPoly(poly, q, countBorder=True):
    return _adaptagrams.inPoly(poly, q, countBorder)
inPoly = _adaptagrams.inPoly

def inPolyGen(poly, q):
    return _adaptagrams.inPolyGen(poly, q)
inPolyGen = _adaptagrams.inPolyGen

def inValidRegion(IgnoreRegions, a0, a1, a2, b):
    return _adaptagrams.inValidRegion(IgnoreRegions, a0, a1, a2, b)
inValidRegion = _adaptagrams.inValidRegion

def cornerSide(c1, c2, c3, p):
    return _adaptagrams.cornerSide(c1, c2, c3, p)
cornerSide = _adaptagrams.cornerSide

def pointOnLine(a, b, c, tolerance=0.0):
    return _adaptagrams.pointOnLine(a, b, c, tolerance)
pointOnLine = _adaptagrams.pointOnLine

def colinear(a, b, c, tolerance=0.0):
    return _adaptagrams.colinear(a, b, c, tolerance)
colinear = _adaptagrams.colinear

def inBetween(a, b, c):
    return _adaptagrams.inBetween(a, b, c)
inBetween = _adaptagrams.inBetween

def vecDir(a, b, c, maybeZero=0.0):
    return _adaptagrams.vecDir(a, b, c, maybeZero)
vecDir = _adaptagrams.vecDir

def projection(a, b, c):
    return _adaptagrams.projection(a, b, c)
projection = _adaptagrams.projection

def segmentIntersectPoint(a1, a2, b1, b2, x, y):
    return _adaptagrams.segmentIntersectPoint(a1, a2, b1, b2, x, y)
segmentIntersectPoint = _adaptagrams.segmentIntersectPoint

def rayIntersectPoint(a1, a2, b1, b2, x, y):
    return _adaptagrams.rayIntersectPoint(a1, a2, b1, b2, x, y)
rayIntersectPoint = _adaptagrams.rayIntersectPoint

def rotationalAngle(p):
    return _adaptagrams.rotationalAngle(p)
rotationalAngle = _adaptagrams.rotationalAngle
class Point(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Point, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Point, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _adaptagrams.new_Point(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def equals(self, rhs, epsilon=0.0001):
        return _adaptagrams.Point_equals(self, rhs, epsilon)
    __swig_setmethods__["x"] = _adaptagrams.Point_x_set
    __swig_getmethods__["x"] = _adaptagrams.Point_x_get
    if _newclass:
        x = _swig_property(_adaptagrams.Point_x_get, _adaptagrams.Point_x_set)
    __swig_setmethods__["y"] = _adaptagrams.Point_y_set
    __swig_getmethods__["y"] = _adaptagrams.Point_y_get
    if _newclass:
        y = _swig_property(_adaptagrams.Point_y_get, _adaptagrams.Point_y_set)
    __swig_setmethods__["id"] = _adaptagrams.Point_id_set
    __swig_getmethods__["id"] = _adaptagrams.Point_id_get
    if _newclass:
        id = _swig_property(_adaptagrams.Point_id_get, _adaptagrams.Point_id_set)
    __swig_setmethods__["vn"] = _adaptagrams.Point_vn_set
    __swig_getmethods__["vn"] = _adaptagrams.Point_vn_get
    if _newclass:
        vn = _swig_property(_adaptagrams.Point_vn_get, _adaptagrams.Point_vn_set)
    __swig_destroy__ = _adaptagrams.delete_Point
    __del__ = lambda self: None
Point_swigregister = _adaptagrams.Point_swigregister
Point_swigregister(Point)
DONT_INTERSECT = cvar.DONT_INTERSECT
DO_INTERSECT = cvar.DO_INTERSECT
PARALLEL = cvar.PARALLEL

class AvoidBox(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AvoidBox, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AvoidBox, name)
    __repr__ = _swig_repr
    __swig_setmethods__["min"] = _adaptagrams.AvoidBox_min_set
    __swig_getmethods__["min"] = _adaptagrams.AvoidBox_min_get
    if _newclass:
        min = _swig_property(_adaptagrams.AvoidBox_min_get, _adaptagrams.AvoidBox_min_set)
    __swig_setmethods__["max"] = _adaptagrams.AvoidBox_max_set
    __swig_getmethods__["max"] = _adaptagrams.AvoidBox_max_get
    if _newclass:
        max = _swig_property(_adaptagrams.AvoidBox_max_get, _adaptagrams.AvoidBox_max_set)

    def length(self, dimension):
        return _adaptagrams.AvoidBox_length(self, dimension)

    def width(self):
        return _adaptagrams.AvoidBox_width(self)

    def height(self):
        return _adaptagrams.AvoidBox_height(self)

    def __init__(self):
        this = _adaptagrams.new_AvoidBox()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _adaptagrams.delete_AvoidBox
    __del__ = lambda self: None
AvoidBox_swigregister = _adaptagrams.AvoidBox_swigregister
AvoidBox_swigregister(AvoidBox)
kUnassignedVertexNumber = cvar.kUnassignedVertexNumber
kShapeConnectionPin = cvar.kShapeConnectionPin

class PolygonInterface(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PolygonInterface, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PolygonInterface, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _adaptagrams.delete_PolygonInterface
    __del__ = lambda self: None

    def clear(self):
        return _adaptagrams.PolygonInterface_clear(self)

    def empty(self):
        return _adaptagrams.PolygonInterface_empty(self)

    def size(self):
        return _adaptagrams.PolygonInterface_size(self)

    def id(self):
        return _adaptagrams.PolygonInterface_id(self)

    def at(self, index):
        return _adaptagrams.PolygonInterface_at(self, index)

    def boundingRectPolygon(self):
        return _adaptagrams.PolygonInterface_boundingRectPolygon(self)

    def offsetBoundingBox(self, offset):
        return _adaptagrams.PolygonInterface_offsetBoundingBox(self, offset)

    def offsetPolygon(self, offset):
        return _adaptagrams.PolygonInterface_offsetPolygon(self, offset)
PolygonInterface_swigregister = _adaptagrams.PolygonInterface_swigregister
PolygonInterface_swigregister(PolygonInterface)

class AvoidEdge(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AvoidEdge, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AvoidEdge, name)
    __repr__ = _swig_repr
    __swig_setmethods__["a"] = _adaptagrams.AvoidEdge_a_set
    __swig_getmethods__["a"] = _adaptagrams.AvoidEdge_a_get
    if _newclass:
        a = _swig_property(_adaptagrams.AvoidEdge_a_get, _adaptagrams.AvoidEdge_a_set)
    __swig_setmethods__["b"] = _adaptagrams.AvoidEdge_b_set
    __swig_getmethods__["b"] = _adaptagrams.AvoidEdge_b_get
    if _newclass:
        b = _swig_property(_adaptagrams.AvoidEdge_b_get, _adaptagrams.AvoidEdge_b_set)

    def __init__(self):
        this = _adaptagrams.new_AvoidEdge()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _adaptagrams.delete_AvoidEdge
    __del__ = lambda self: None
AvoidEdge_swigregister = _adaptagrams.AvoidEdge_swigregister
AvoidEdge_swigregister(AvoidEdge)

class Polygon(PolygonInterface):
    __swig_setmethods__ = {}
    for _s in [PolygonInterface]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Polygon, name, value)
    __swig_getmethods__ = {}
    for _s in [PolygonInterface]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Polygon, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _adaptagrams.new_Polygon(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def clear(self):
        return _adaptagrams.Polygon_clear(self)

    def empty(self):
        return _adaptagrams.Polygon_empty(self)

    def size(self):
        return _adaptagrams.Polygon_size(self)

    def id(self):
        return _adaptagrams.Polygon_id(self)

    def at(self, index):
        return _adaptagrams.Polygon_at(self, index)

    def setPoint(self, index, point):
        return _adaptagrams.Polygon_setPoint(self, index, point)

    def simplify(self):
        return _adaptagrams.Polygon_simplify(self)

    def curvedPolyline(self, curve_amount, closed=False):
        return _adaptagrams.Polygon_curvedPolyline(self, curve_amount, closed)

    def translate(self, xDist, yDist):
        return _adaptagrams.Polygon_translate(self, xDist, yDist)
    __swig_setmethods__["_id"] = _adaptagrams.Polygon__id_set
    __swig_getmethods__["_id"] = _adaptagrams.Polygon__id_get
    if _newclass:
        _id = _swig_property(_adaptagrams.Polygon__id_get, _adaptagrams.Polygon__id_set)
    __swig_setmethods__["ps"] = _adaptagrams.Polygon_ps_set
    __swig_getmethods__["ps"] = _adaptagrams.Polygon_ps_get
    if _newclass:
        ps = _swig_property(_adaptagrams.Polygon_ps_get, _adaptagrams.Polygon_ps_set)
    __swig_setmethods__["ts"] = _adaptagrams.Polygon_ts_set
    __swig_getmethods__["ts"] = _adaptagrams.Polygon_ts_get
    if _newclass:
        ts = _swig_property(_adaptagrams.Polygon_ts_get, _adaptagrams.Polygon_ts_set)
    __swig_setmethods__["checkpointsOnRoute"] = _adaptagrams.Polygon_checkpointsOnRoute_set
    __swig_getmethods__["checkpointsOnRoute"] = _adaptagrams.Polygon_checkpointsOnRoute_get
    if _newclass:
        checkpointsOnRoute = _swig_property(_adaptagrams.Polygon_checkpointsOnRoute_get, _adaptagrams.Polygon_checkpointsOnRoute_set)

    def checkpointsOnSegment(self, segmentLowerIndex, indexModifier=0):
        return _adaptagrams.Polygon_checkpointsOnSegment(self, segmentLowerIndex, indexModifier)
    __swig_destroy__ = _adaptagrams.delete_Polygon
    __del__ = lambda self: None
Polygon_swigregister = _adaptagrams.Polygon_swigregister
Polygon_swigregister(Polygon)

class ReferencingPolygon(PolygonInterface):
    __swig_setmethods__ = {}
    for _s in [PolygonInterface]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ReferencingPolygon, name, value)
    __swig_getmethods__ = {}
    for _s in [PolygonInterface]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ReferencingPolygon, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _adaptagrams.new_ReferencingPolygon(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def clear(self):
        return _adaptagrams.ReferencingPolygon_clear(self)

    def empty(self):
        return _adaptagrams.ReferencingPolygon_empty(self)

    def size(self):
        return _adaptagrams.ReferencingPolygon_size(self)

    def id(self):
        return _adaptagrams.ReferencingPolygon_id(self)

    def at(self, index):
        return _adaptagrams.ReferencingPolygon_at(self, index)
    __swig_setmethods__["_id"] = _adaptagrams.ReferencingPolygon__id_set
    __swig_getmethods__["_id"] = _adaptagrams.ReferencingPolygon__id_get
    if _newclass:
        _id = _swig_property(_adaptagrams.ReferencingPolygon__id_get, _adaptagrams.ReferencingPolygon__id_set)
    __swig_setmethods__["psRef"] = _adaptagrams.ReferencingPolygon_psRef_set
    __swig_getmethods__["psRef"] = _adaptagrams.ReferencingPolygon_psRef_get
    if _newclass:
        psRef = _swig_property(_adaptagrams.ReferencingPolygon_psRef_get, _adaptagrams.ReferencingPolygon_psRef_set)
    __swig_setmethods__["psPoints"] = _adaptagrams.ReferencingPolygon_psPoints_set
    __swig_getmethods__["psPoints"] = _adaptagrams.ReferencingPolygon_psPoints_get
    if _newclass:
        psPoints = _swig_property(_adaptagrams.ReferencingPolygon_psPoints_get, _adaptagrams.ReferencingPolygon_psPoints_set)
    __swig_destroy__ = _adaptagrams.delete_ReferencingPolygon
    __del__ = lambda self: None
ReferencingPolygon_swigregister = _adaptagrams.ReferencingPolygon_swigregister
ReferencingPolygon_swigregister(ReferencingPolygon)

class AvoidRectangle(Polygon):
    __swig_setmethods__ = {}
    for _s in [Polygon]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AvoidRectangle, name, value)
    __swig_getmethods__ = {}
    for _s in [Polygon]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AvoidRectangle, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _adaptagrams.new_AvoidRectangle(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _adaptagrams.delete_AvoidRectangle
    __del__ = lambda self: None
AvoidRectangle_swigregister = _adaptagrams.AvoidRectangle_swigregister
AvoidRectangle_swigregister(AvoidRectangle)

ConnDirNone = _adaptagrams.ConnDirNone
ConnDirUp = _adaptagrams.ConnDirUp
ConnDirDown = _adaptagrams.ConnDirDown
ConnDirLeft = _adaptagrams.ConnDirLeft
ConnDirRight = _adaptagrams.ConnDirRight
ConnDirAll = _adaptagrams.ConnDirAll
ConnEndPoint = _adaptagrams.ConnEndPoint
ConnEndShapePin = _adaptagrams.ConnEndShapePin
ConnEndJunction = _adaptagrams.ConnEndJunction
ConnEndEmpty = _adaptagrams.ConnEndEmpty
class ConnEnd(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConnEnd, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ConnEnd, name)
    __repr__ = _swig_repr

    def type(self):
        return _adaptagrams.ConnEnd_type(self)

    def position(self):
        return _adaptagrams.ConnEnd_position(self)

    def directions(self):
        return _adaptagrams.ConnEnd_directions(self)

    def shape(self):
        return _adaptagrams.ConnEnd_shape(self)

    def junction(self):
        return _adaptagrams.ConnEnd_junction(self)

    def pinClassId(self):
        return _adaptagrams.ConnEnd_pinClassId(self)

    def __init__(self, *args):
        this = _adaptagrams.new_ConnEnd(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _adaptagrams.delete_ConnEnd
    __del__ = lambda self: None
ConnEnd_swigregister = _adaptagrams.ConnEnd_swigregister
ConnEnd_swigregister(ConnEnd)

class LineRep(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LineRep, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LineRep, name)
    __repr__ = _swig_repr
    __swig_setmethods__["begin"] = _adaptagrams.LineRep_begin_set
    __swig_getmethods__["begin"] = _adaptagrams.LineRep_begin_get
    if _newclass:
        begin = _swig_property(_adaptagrams.LineRep_begin_get, _adaptagrams.LineRep_begin_set)
    __swig_setmethods__["end"] = _adaptagrams.LineRep_end_set
    __swig_getmethods__["end"] = _adaptagrams.LineRep_end_get
    if _newclass:
        end = _swig_property(_adaptagrams.LineRep_end_get, _adaptagrams.LineRep_end_set)

    def __init__(self):
        this = _adaptagrams.new_LineRep()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _adaptagrams.delete_LineRep
    __del__ = lambda self: None
LineRep_swigregister = _adaptagrams.LineRep_swigregister
LineRep_swigregister(LineRep)

PolyLineRouting = _adaptagrams.PolyLineRouting
OrthogonalRouting = _adaptagrams.OrthogonalRouting
segmentPenalty = _adaptagrams.segmentPenalty
anglePenalty = _adaptagrams.anglePenalty
crossingPenalty = _adaptagrams.crossingPenalty
clusterCrossingPenalty = _adaptagrams.clusterCrossingPenalty
fixedSharedPathPenalty = _adaptagrams.fixedSharedPathPenalty
portDirectionPenalty = _adaptagrams.portDirectionPenalty
shapeBufferDistance = _adaptagrams.shapeBufferDistance
idealNudgingDistance = _adaptagrams.idealNudgingDistance
reverseDirectionPenalty = _adaptagrams.reverseDirectionPenalty
lastRoutingParameterMarker = _adaptagrams.lastRoutingParameterMarker
nudgeOrthogonalSegmentsConnectedToShapes = _adaptagrams.nudgeOrthogonalSegmentsConnectedToShapes
improveHyperedgeRoutesMovingJunctions = _adaptagrams.improveHyperedgeRoutesMovingJunctions
penaliseOrthogonalSharedPathsAtConnEnds = _adaptagrams.penaliseOrthogonalSharedPathsAtConnEnds
nudgeOrthogonalTouchingColinearSegments = _adaptagrams.nudgeOrthogonalTouchingColinearSegments
performUnifyingNudgingPreprocessingStep = _adaptagrams.performUnifyingNudgingPreprocessingStep
improveHyperedgeRoutesMovingAddingAndDeletingJunctions = _adaptagrams.improveHyperedgeRoutesMovingAddingAndDeletingJunctions
nudgeSharedPathsWithCommonEndPoint = _adaptagrams.nudgeSharedPathsWithCommonEndPoint
lastRoutingOptionMarker = _adaptagrams.lastRoutingOptionMarker
TransactionPhaseOrthogonalVisibilityGraphScanX = _adaptagrams.TransactionPhaseOrthogonalVisibilityGraphScanX
TransactionPhaseOrthogonalVisibilityGraphScanY = _adaptagrams.TransactionPhaseOrthogonalVisibilityGraphScanY
TransactionPhaseRouteSearch = _adaptagrams.TransactionPhaseRouteSearch
TransactionPhaseCrossingDetection = _adaptagrams.TransactionPhaseCrossingDetection
TransactionPhaseRerouteSearch = _adaptagrams.TransactionPhaseRerouteSearch
TransactionPhaseOrthogonalNudgingX = _adaptagrams.TransactionPhaseOrthogonalNudgingX
TransactionPhaseOrthogonalNudgingY = _adaptagrams.TransactionPhaseOrthogonalNudgingY
TransactionPhaseCompleted = _adaptagrams.TransactionPhaseCompleted
class ConnRerouteFlagDelegate(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConnRerouteFlagDelegate, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ConnRerouteFlagDelegate, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _adaptagrams.new_ConnRerouteFlagDelegate()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _adaptagrams.delete_ConnRerouteFlagDelegate
    __del__ = lambda self: None

    def addConn(self, conn):
        return _adaptagrams.ConnRerouteFlagDelegate_addConn(self, conn)

    def removeConn(self, conn):
        return _adaptagrams.ConnRerouteFlagDelegate_removeConn(self, conn)

    def alertConns(self):
        return _adaptagrams.ConnRerouteFlagDelegate_alertConns(self)
ConnRerouteFlagDelegate_swigregister = _adaptagrams.ConnRerouteFlagDelegate_swigregister
ConnRerouteFlagDelegate_swigregister(ConnRerouteFlagDelegate)
runningTo = cvar.runningTo
runningFrom = cvar.runningFrom
runningToAndFrom = cvar.runningToAndFrom

class AvoidTopologyAddonInterface(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AvoidTopologyAddonInterface, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AvoidTopologyAddonInterface, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _adaptagrams.new_AvoidTopologyAddonInterface()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _adaptagrams.delete_AvoidTopologyAddonInterface
    __del__ = lambda self: None

    def clone(self):
        return _adaptagrams.AvoidTopologyAddonInterface_clone(self)

    def improveOrthogonalTopology(self, router):
        return _adaptagrams.AvoidTopologyAddonInterface_improveOrthogonalTopology(self, router)

    def outputCode(self, fp):
        return _adaptagrams.AvoidTopologyAddonInterface_outputCode(self, fp)

    def outputDeletionCode(self, fp):
        return _adaptagrams.AvoidTopologyAddonInterface_outputDeletionCode(self, fp)
AvoidTopologyAddonInterface_swigregister = _adaptagrams.AvoidTopologyAddonInterface_swigregister
AvoidTopologyAddonInterface_swigregister(AvoidTopologyAddonInterface)
zeroParamValue = cvar.zeroParamValue
chooseSensibleParamValue = cvar.chooseSensibleParamValue

class Router(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Router, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Router, name)
    __repr__ = _swig_repr

    def __init__(self, flags):
        if self.__class__ == Router:
            _self = None
        else:
            _self = self
        this = _adaptagrams.new_Router(_self, flags)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _adaptagrams.delete_Router
    __del__ = lambda self: None
    __swig_setmethods__["m_obstacles"] = _adaptagrams.Router_m_obstacles_set
    __swig_getmethods__["m_obstacles"] = _adaptagrams.Router_m_obstacles_get
    if _newclass:
        m_obstacles = _swig_property(_adaptagrams.Router_m_obstacles_get, _adaptagrams.Router_m_obstacles_set)
    __swig_setmethods__["connRefs"] = _adaptagrams.Router_connRefs_set
    __swig_getmethods__["connRefs"] = _adaptagrams.Router_connRefs_get
    if _newclass:
        connRefs = _swig_property(_adaptagrams.Router_connRefs_get, _adaptagrams.Router_connRefs_set)
    __swig_setmethods__["clusterRefs"] = _adaptagrams.Router_clusterRefs_set
    __swig_getmethods__["clusterRefs"] = _adaptagrams.Router_clusterRefs_get
    if _newclass:
        clusterRefs = _swig_property(_adaptagrams.Router_clusterRefs_get, _adaptagrams.Router_clusterRefs_set)
    __swig_setmethods__["visGraph"] = _adaptagrams.Router_visGraph_set
    __swig_getmethods__["visGraph"] = _adaptagrams.Router_visGraph_get
    if _newclass:
        visGraph = _swig_property(_adaptagrams.Router_visGraph_get, _adaptagrams.Router_visGraph_set)
    __swig_setmethods__["invisGraph"] = _adaptagrams.Router_invisGraph_set
    __swig_getmethods__["invisGraph"] = _adaptagrams.Router_invisGraph_get
    if _newclass:
        invisGraph = _swig_property(_adaptagrams.Router_invisGraph_get, _adaptagrams.Router_invisGraph_set)
    __swig_setmethods__["visOrthogGraph"] = _adaptagrams.Router_visOrthogGraph_set
    __swig_getmethods__["visOrthogGraph"] = _adaptagrams.Router_visOrthogGraph_get
    if _newclass:
        visOrthogGraph = _swig_property(_adaptagrams.Router_visOrthogGraph_get, _adaptagrams.Router_visOrthogGraph_set)
    __swig_setmethods__["contains"] = _adaptagrams.Router_contains_set
    __swig_getmethods__["contains"] = _adaptagrams.Router_contains_get
    if _newclass:
        contains = _swig_property(_adaptagrams.Router_contains_get, _adaptagrams.Router_contains_set)
    __swig_setmethods__["vertices"] = _adaptagrams.Router_vertices_set
    __swig_getmethods__["vertices"] = _adaptagrams.Router_vertices_get
    if _newclass:
        vertices = _swig_property(_adaptagrams.Router_vertices_get, _adaptagrams.Router_vertices_set)
    __swig_setmethods__["enclosingClusters"] = _adaptagrams.Router_enclosingClusters_set
    __swig_getmethods__["enclosingClusters"] = _adaptagrams.Router_enclosingClusters_get
    if _newclass:
        enclosingClusters = _swig_property(_adaptagrams.Router_enclosingClusters_get, _adaptagrams.Router_enclosingClusters_set)
    __swig_setmethods__["PartialTime"] = _adaptagrams.Router_PartialTime_set
    __swig_getmethods__["PartialTime"] = _adaptagrams.Router_PartialTime_get
    if _newclass:
        PartialTime = _swig_property(_adaptagrams.Router_PartialTime_get, _adaptagrams.Router_PartialTime_set)
    __swig_setmethods__["SimpleRouting"] = _adaptagrams.Router_SimpleRouting_set
    __swig_getmethods__["SimpleRouting"] = _adaptagrams.Router_SimpleRouting_get
    if _newclass:
        SimpleRouting = _swig_property(_adaptagrams.Router_SimpleRouting_get, _adaptagrams.Router_SimpleRouting_set)
    __swig_setmethods__["ClusteredRouting"] = _adaptagrams.Router_ClusteredRouting_set
    __swig_getmethods__["ClusteredRouting"] = _adaptagrams.Router_ClusteredRouting_get
    if _newclass:
        ClusteredRouting = _swig_property(_adaptagrams.Router_ClusteredRouting_get, _adaptagrams.Router_ClusteredRouting_set)
    __swig_setmethods__["IgnoreRegions"] = _adaptagrams.Router_IgnoreRegions_set
    __swig_getmethods__["IgnoreRegions"] = _adaptagrams.Router_IgnoreRegions_get
    if _newclass:
        IgnoreRegions = _swig_property(_adaptagrams.Router_IgnoreRegions_get, _adaptagrams.Router_IgnoreRegions_set)
    __swig_setmethods__["UseLeesAlgorithm"] = _adaptagrams.Router_UseLeesAlgorithm_set
    __swig_getmethods__["UseLeesAlgorithm"] = _adaptagrams.Router_UseLeesAlgorithm_get
    if _newclass:
        UseLeesAlgorithm = _swig_property(_adaptagrams.Router_UseLeesAlgorithm_get, _adaptagrams.Router_UseLeesAlgorithm_set)
    __swig_setmethods__["InvisibilityGrph"] = _adaptagrams.Router_InvisibilityGrph_set
    __swig_getmethods__["InvisibilityGrph"] = _adaptagrams.Router_InvisibilityGrph_get
    if _newclass:
        InvisibilityGrph = _swig_property(_adaptagrams.Router_InvisibilityGrph_get, _adaptagrams.Router_InvisibilityGrph_set)
    __swig_setmethods__["SelectiveReroute"] = _adaptagrams.Router_SelectiveReroute_set
    __swig_getmethods__["SelectiveReroute"] = _adaptagrams.Router_SelectiveReroute_get
    if _newclass:
        SelectiveReroute = _swig_property(_adaptagrams.Router_SelectiveReroute_get, _adaptagrams.Router_SelectiveReroute_set)
    __swig_setmethods__["PartialFeedback"] = _adaptagrams.Router_PartialFeedback_set
    __swig_getmethods__["PartialFeedback"] = _adaptagrams.Router_PartialFeedback_get
    if _newclass:
        PartialFeedback = _swig_property(_adaptagrams.Router_PartialFeedback_get, _adaptagrams.Router_PartialFeedback_set)
    __swig_setmethods__["RubberBandRouting"] = _adaptagrams.Router_RubberBandRouting_set
    __swig_getmethods__["RubberBandRouting"] = _adaptagrams.Router_RubberBandRouting_get
    if _newclass:
        RubberBandRouting = _swig_property(_adaptagrams.Router_RubberBandRouting_get, _adaptagrams.Router_RubberBandRouting_set)
    __swig_setmethods__["st_checked_edges"] = _adaptagrams.Router_st_checked_edges_set
    __swig_getmethods__["st_checked_edges"] = _adaptagrams.Router_st_checked_edges_get
    if _newclass:
        st_checked_edges = _swig_property(_adaptagrams.Router_st_checked_edges_get, _adaptagrams.Router_st_checked_edges_set)

    def setTransactionUse(self, transactions):
        return _adaptagrams.Router_setTransactionUse(self, transactions)

    def transactionUse(self):
        return _adaptagrams.Router_transactionUse(self)

    def processTransaction(self):
        return _adaptagrams.Router_processTransaction(self)

    def deleteShape(self, shape):
        return _adaptagrams.Router_deleteShape(self, shape)

    def moveShape(self, *args):
        return _adaptagrams.Router_moveShape(self, *args)

    def deleteJunction(self, junction):
        return _adaptagrams.Router_deleteJunction(self, junction)

    def deleteConnector(self, connector):
        return _adaptagrams.Router_deleteConnector(self, connector)

    def moveJunction(self, *args):
        return _adaptagrams.Router_moveJunction(self, *args)

    def setRoutingParameter(self, *args):
        return _adaptagrams.Router_setRoutingParameter(self, *args)

    def routingParameter(self, parameter):
        return _adaptagrams.Router_routingParameter(self, parameter)

    def setRoutingOption(self, option, value):
        return _adaptagrams.Router_setRoutingOption(self, option, value)

    def routingOption(self, option):
        return _adaptagrams.Router_routingOption(self, option)

    def setRoutingPenalty(self, *args):
        return _adaptagrams.Router_setRoutingPenalty(self, *args)

    def hyperedgeRerouter(self):
        return _adaptagrams.Router_hyperedgeRerouter(self)

    def outputInstanceToSVG(self, *args):
        return _adaptagrams.Router_outputInstanceToSVG(self, *args)

    def newObjectId(self):
        return _adaptagrams.Router_newObjectId(self)

    def objectIdIsUnused(self, id):
        return _adaptagrams.Router_objectIdIsUnused(self, id)

    def shouldContinueTransactionWithProgress(self, elapsedTime, phaseNumber, totalPhases, proportion):
        return _adaptagrams.Router_shouldContinueTransactionWithProgress(self, elapsedTime, phaseNumber, totalPhases, proportion)

    def newAndDeletedObjectListsFromHyperedgeImprovement(self):
        return _adaptagrams.Router_newAndDeletedObjectListsFromHyperedgeImprovement(self)

    def setDebugHandler(self, handler):
        return _adaptagrams.Router_setDebugHandler(self, handler)

    def debugHandler(self):
        return _adaptagrams.Router_debugHandler(self)

    def processActions(self):
        return _adaptagrams.Router_processActions(self)

    def deleteCluster(self, cluster):
        return _adaptagrams.Router_deleteCluster(self, cluster)

    def attachedShapes(self, shapes, shapeId, type):
        return _adaptagrams.Router_attachedShapes(self, shapes, shapeId, type)

    def attachedConns(self, conns, shapeId, type):
        return _adaptagrams.Router_attachedConns(self, conns, shapeId, type)

    def markPolylineConnectorsNeedingReroutingForDeletedObstacle(self, obstacle):
        return _adaptagrams.Router_markPolylineConnectorsNeedingReroutingForDeletedObstacle(self, obstacle)

    def generateContains(self, pt):
        return _adaptagrams.Router_generateContains(self, pt)

    def printInfo(self):
        return _adaptagrams.Router_printInfo(self)

    def regenerateStaticBuiltGraph(self):
        return _adaptagrams.Router_regenerateStaticBuiltGraph(self)

    def destroyOrthogonalVisGraph(self):
        return _adaptagrams.Router_destroyOrthogonalVisGraph(self)

    def setStaticGraphInvalidated(self, invalidated):
        return _adaptagrams.Router_setStaticGraphInvalidated(self, invalidated)

    def validConnType(self, *args):
        return _adaptagrams.Router_validConnType(self, *args)

    def isInCrossingPenaltyReroutingStage(self):
        return _adaptagrams.Router_isInCrossingPenaltyReroutingStage(self)

    def markAllObstaclesAsMoved(self):
        return _adaptagrams.Router_markAllObstaclesAsMoved(self)

    def shapeContainingPoint(self, point):
        return _adaptagrams.Router_shapeContainingPoint(self, point)

    def performContinuationCheck(self, phaseNumber, stepNumber, totalSteps):
        return _adaptagrams.Router_performContinuationCheck(self, phaseNumber, stepNumber, totalSteps)

    def registerSettingsChange(self):
        return _adaptagrams.Router_registerSettingsChange(self)

    def setTopologyAddon(self, topologyAddon):
        return _adaptagrams.Router_setTopologyAddon(self, topologyAddon)

    def improveOrthogonalTopology(self):
        return _adaptagrams.Router_improveOrthogonalTopology(self)

    def existsOrthogonalSegmentOverlap(self, atEnds=False):
        return _adaptagrams.Router_existsOrthogonalSegmentOverlap(self, atEnds)

    def existsOrthogonalFixedSegmentOverlap(self, atEnds=False):
        return _adaptagrams.Router_existsOrthogonalFixedSegmentOverlap(self, atEnds)

    def existsOrthogonalTouchingPaths(self):
        return _adaptagrams.Router_existsOrthogonalTouchingPaths(self)

    def existsCrossings(self, optimisedForConnectorType=False):
        return _adaptagrams.Router_existsCrossings(self, optimisedForConnectorType)

    def existsInvalidOrthogonalPaths(self):
        return _adaptagrams.Router_existsInvalidOrthogonalPaths(self)

    def outputDiagramSVG(self, *args):
        return _adaptagrams.Router_outputDiagramSVG(self, *args)

    def outputDiagramText(self, *args):
        return _adaptagrams.Router_outputDiagramText(self, *args)

    def outputDiagram(self, *args):
        return _adaptagrams.Router_outputDiagram(self, *args)
    def __disown__(self):
        self.this.disown()
        _adaptagrams.disown_Router(self)
        return weakref_proxy(self)
Router_swigregister = _adaptagrams.Router_swigregister
Router_swigregister(Router)

ConnType_None = _adaptagrams.ConnType_None
ConnType_PolyLine = _adaptagrams.ConnType_PolyLine
ConnType_Orthogonal = _adaptagrams.ConnType_Orthogonal
class Checkpoint(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Checkpoint, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Checkpoint, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _adaptagrams.new_Checkpoint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["point"] = _adaptagrams.Checkpoint_point_set
    __swig_getmethods__["point"] = _adaptagrams.Checkpoint_point_get
    if _newclass:
        point = _swig_property(_adaptagrams.Checkpoint_point_get, _adaptagrams.Checkpoint_point_set)
    __swig_setmethods__["arrivalDirections"] = _adaptagrams.Checkpoint_arrivalDirections_set
    __swig_getmethods__["arrivalDirections"] = _adaptagrams.Checkpoint_arrivalDirections_get
    if _newclass:
        arrivalDirections = _swig_property(_adaptagrams.Checkpoint_arrivalDirections_get, _adaptagrams.Checkpoint_arrivalDirections_set)
    __swig_setmethods__["departureDirections"] = _adaptagrams.Checkpoint_departureDirections_set
    __swig_getmethods__["departureDirections"] = _adaptagrams.Checkpoint_departureDirections_get
    if _newclass:
        departureDirections = _swig_property(_adaptagrams.Checkpoint_departureDirections_get, _adaptagrams.Checkpoint_departureDirections_set)
    __swig_destroy__ = _adaptagrams.delete_Checkpoint
    __del__ = lambda self: None
Checkpoint_swigregister = _adaptagrams.Checkpoint_swigregister
Checkpoint_swigregister(Checkpoint)

class ConnRef(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConnRef, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ConnRef, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _adaptagrams.new_ConnRef(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def setEndpoints(self, srcPoint, dstPoint):
        return _adaptagrams.ConnRef_setEndpoints(self, srcPoint, dstPoint)

    def setSourceEndpoint(self, srcPoint):
        return _adaptagrams.ConnRef_setSourceEndpoint(self, srcPoint)

    def setDestEndpoint(self, dstPoint):
        return _adaptagrams.ConnRef_setDestEndpoint(self, dstPoint)

    def id(self):
        return _adaptagrams.ConnRef_id(self)

    def router(self):
        return _adaptagrams.ConnRef_router(self)

    def needsRepaint(self):
        return _adaptagrams.ConnRef_needsRepaint(self)

    def route(self):
        return _adaptagrams.ConnRef_route(self)

    def displayRoute(self):
        return _adaptagrams.ConnRef_displayRoute(self)

    def setCallback(self, cb, ptr):
        return _adaptagrams.ConnRef_setCallback(self, cb, ptr)

    def routingType(self):
        return _adaptagrams.ConnRef_routingType(self)

    def setRoutingType(self, type):
        return _adaptagrams.ConnRef_setRoutingType(self, type)

    def splitAtSegment(self, segmentN):
        return _adaptagrams.ConnRef_splitAtSegment(self, segmentN)

    def setRoutingCheckpoints(self, checkpoints):
        return _adaptagrams.ConnRef_setRoutingCheckpoints(self, checkpoints)

    def routingCheckpoints(self):
        return _adaptagrams.ConnRef_routingCheckpoints(self)

    def endpointConnEnds(self):
        return _adaptagrams.ConnRef_endpointConnEnds(self)

    def src(self):
        return _adaptagrams.ConnRef_src(self)

    def dst(self):
        return _adaptagrams.ConnRef_dst(self)

    def setFixedRoute(self, route):
        return _adaptagrams.ConnRef_setFixedRoute(self, route)

    def setFixedExistingRoute(self):
        return _adaptagrams.ConnRef_setFixedExistingRoute(self)

    def hasFixedRoute(self):
        return _adaptagrams.ConnRef_hasFixedRoute(self)

    def clearFixedRoute(self):
        return _adaptagrams.ConnRef_clearFixedRoute(self)

    def set_route(self, route):
        return _adaptagrams.ConnRef_set_route(self, route)

    def calcRouteDist(self):
        return _adaptagrams.ConnRef_calcRouteDist(self)

    def makeActive(self):
        return _adaptagrams.ConnRef_makeActive(self)

    def makeInactive(self):
        return _adaptagrams.ConnRef_makeInactive(self)

    def start(self):
        return _adaptagrams.ConnRef_start(self)

    def removeFromGraph(self):
        return _adaptagrams.ConnRef_removeFromGraph(self)

    def isInitialised(self):
        return _adaptagrams.ConnRef_isInitialised(self)

    def makePathInvalid(self):
        return _adaptagrams.ConnRef_makePathInvalid(self)

    def setHateCrossings(self, value):
        return _adaptagrams.ConnRef_setHateCrossings(self, value)

    def doesHateCrossings(self):
        return _adaptagrams.ConnRef_doesHateCrossings(self)

    def setEndpoint(self, *args):
        return _adaptagrams.ConnRef_setEndpoint(self, *args)

    def possibleDstPinPoints(self):
        return _adaptagrams.ConnRef_possibleDstPinPoints(self)
ConnRef_swigregister = _adaptagrams.ConnRef_swigregister
ConnRef_swigregister(ConnRef)

class PtOrder(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PtOrder, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PtOrder, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _adaptagrams.new_PtOrder()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _adaptagrams.delete_PtOrder
    __del__ = lambda self: None

    def addPoints(self, dim, arg1, arg2):
        return _adaptagrams.PtOrder_addPoints(self, dim, arg1, arg2)

    def addOrderedPoints(self, dim, innerArg, outerArg, swapped):
        return _adaptagrams.PtOrder_addOrderedPoints(self, dim, innerArg, outerArg, swapped)

    def positionFor(self, dim, conn):
        return _adaptagrams.PtOrder_positionFor(self, dim, conn)

    def sortedPoints(self, dim):
        return _adaptagrams.PtOrder_sortedPoints(self, dim)
PtOrder_swigregister = _adaptagrams.PtOrder_swigregister
PtOrder_swigregister(PtOrder)

class ConnectorCrossings(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConnectorCrossings, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ConnectorCrossings, name)
    __repr__ = _swig_repr

    def __init__(self, poly, polyIsConn, conn, polyConnRef=None, connConnRef=None):
        this = _adaptagrams.new_ConnectorCrossings(poly, polyIsConn, conn, polyConnRef, connConnRef)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def clear(self):
        return _adaptagrams.ConnectorCrossings_clear(self)

    def countForSegment(self, cIndex, finalSegment):
        return _adaptagrams.ConnectorCrossings_countForSegment(self, cIndex, finalSegment)
    __swig_setmethods__["poly"] = _adaptagrams.ConnectorCrossings_poly_set
    __swig_getmethods__["poly"] = _adaptagrams.ConnectorCrossings_poly_get
    if _newclass:
        poly = _swig_property(_adaptagrams.ConnectorCrossings_poly_get, _adaptagrams.ConnectorCrossings_poly_set)
    __swig_setmethods__["polyIsConn"] = _adaptagrams.ConnectorCrossings_polyIsConn_set
    __swig_getmethods__["polyIsConn"] = _adaptagrams.ConnectorCrossings_polyIsConn_get
    if _newclass:
        polyIsConn = _swig_property(_adaptagrams.ConnectorCrossings_polyIsConn_get, _adaptagrams.ConnectorCrossings_polyIsConn_set)
    __swig_setmethods__["conn"] = _adaptagrams.ConnectorCrossings_conn_set
    __swig_getmethods__["conn"] = _adaptagrams.ConnectorCrossings_conn_get
    if _newclass:
        conn = _swig_property(_adaptagrams.ConnectorCrossings_conn_get, _adaptagrams.ConnectorCrossings_conn_set)
    __swig_setmethods__["checkForBranchingSegments"] = _adaptagrams.ConnectorCrossings_checkForBranchingSegments_set
    __swig_getmethods__["checkForBranchingSegments"] = _adaptagrams.ConnectorCrossings_checkForBranchingSegments_get
    if _newclass:
        checkForBranchingSegments = _swig_property(_adaptagrams.ConnectorCrossings_checkForBranchingSegments_get, _adaptagrams.ConnectorCrossings_checkForBranchingSegments_set)
    __swig_setmethods__["polyConnRef"] = _adaptagrams.ConnectorCrossings_polyConnRef_set
    __swig_getmethods__["polyConnRef"] = _adaptagrams.ConnectorCrossings_polyConnRef_get
    if _newclass:
        polyConnRef = _swig_property(_adaptagrams.ConnectorCrossings_polyConnRef_get, _adaptagrams.ConnectorCrossings_polyConnRef_set)
    __swig_setmethods__["connConnRef"] = _adaptagrams.ConnectorCrossings_connConnRef_set
    __swig_getmethods__["connConnRef"] = _adaptagrams.ConnectorCrossings_connConnRef_get
    if _newclass:
        connConnRef = _swig_property(_adaptagrams.ConnectorCrossings_connConnRef_get, _adaptagrams.ConnectorCrossings_connConnRef_set)
    __swig_setmethods__["crossingCount"] = _adaptagrams.ConnectorCrossings_crossingCount_set
    __swig_getmethods__["crossingCount"] = _adaptagrams.ConnectorCrossings_crossingCount_get
    if _newclass:
        crossingCount = _swig_property(_adaptagrams.ConnectorCrossings_crossingCount_get, _adaptagrams.ConnectorCrossings_crossingCount_set)
    __swig_setmethods__["crossingFlags"] = _adaptagrams.ConnectorCrossings_crossingFlags_set
    __swig_getmethods__["crossingFlags"] = _adaptagrams.ConnectorCrossings_crossingFlags_get
    if _newclass:
        crossingFlags = _swig_property(_adaptagrams.ConnectorCrossings_crossingFlags_get, _adaptagrams.ConnectorCrossings_crossingFlags_set)
    __swig_setmethods__["crossingPoints"] = _adaptagrams.ConnectorCrossings_crossingPoints_set
    __swig_getmethods__["crossingPoints"] = _adaptagrams.ConnectorCrossings_crossingPoints_get
    if _newclass:
        crossingPoints = _swig_property(_adaptagrams.ConnectorCrossings_crossingPoints_get, _adaptagrams.ConnectorCrossings_crossingPoints_set)
    __swig_setmethods__["pointOrders"] = _adaptagrams.ConnectorCrossings_pointOrders_set
    __swig_getmethods__["pointOrders"] = _adaptagrams.ConnectorCrossings_pointOrders_get
    if _newclass:
        pointOrders = _swig_property(_adaptagrams.ConnectorCrossings_pointOrders_get, _adaptagrams.ConnectorCrossings_pointOrders_set)
    __swig_setmethods__["sharedPaths"] = _adaptagrams.ConnectorCrossings_sharedPaths_set
    __swig_getmethods__["sharedPaths"] = _adaptagrams.ConnectorCrossings_sharedPaths_get
    if _newclass:
        sharedPaths = _swig_property(_adaptagrams.ConnectorCrossings_sharedPaths_get, _adaptagrams.ConnectorCrossings_sharedPaths_set)
    __swig_setmethods__["firstSharedPathAtEndLength"] = _adaptagrams.ConnectorCrossings_firstSharedPathAtEndLength_set
    __swig_getmethods__["firstSharedPathAtEndLength"] = _adaptagrams.ConnectorCrossings_firstSharedPathAtEndLength_get
    if _newclass:
        firstSharedPathAtEndLength = _swig_property(_adaptagrams.ConnectorCrossings_firstSharedPathAtEndLength_get, _adaptagrams.ConnectorCrossings_firstSharedPathAtEndLength_set)
    __swig_setmethods__["secondSharedPathAtEndLength"] = _adaptagrams.ConnectorCrossings_secondSharedPathAtEndLength_set
    __swig_getmethods__["secondSharedPathAtEndLength"] = _adaptagrams.ConnectorCrossings_secondSharedPathAtEndLength_get
    if _newclass:
        secondSharedPathAtEndLength = _swig_property(_adaptagrams.ConnectorCrossings_secondSharedPathAtEndLength_get, _adaptagrams.ConnectorCrossings_secondSharedPathAtEndLength_set)
    __swig_destroy__ = _adaptagrams.delete_ConnectorCrossings
    __del__ = lambda self: None
ConnectorCrossings_swigregister = _adaptagrams.ConnectorCrossings_swigregister
ConnectorCrossings_swigregister(ConnectorCrossings)
CROSSING_NONE = cvar.CROSSING_NONE
CROSSING_TOUCHES = cvar.CROSSING_TOUCHES
CROSSING_SHARES_PATH = cvar.CROSSING_SHARES_PATH
CROSSING_SHARES_PATH_AT_END = cvar.CROSSING_SHARES_PATH_AT_END
CROSSING_SHARES_FIXED_SEGMENT = cvar.CROSSING_SHARES_FIXED_SEGMENT


def splitBranchingSegments(poly, polyIsConn, conn, tolerance=0):
    return _adaptagrams.splitBranchingSegments(poly, polyIsConn, conn, tolerance)
splitBranchingSegments = _adaptagrams.splitBranchingSegments

def validateBendPoint(aInf, bInf, cInf):
    return _adaptagrams.validateBendPoint(aInf, bInf, cInf)
validateBendPoint = _adaptagrams.validateBendPoint
class Obstacle(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Obstacle, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Obstacle, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def id(self):
        return _adaptagrams.Obstacle_id(self)

    def polygon(self):
        return _adaptagrams.Obstacle_polygon(self)

    def router(self):
        return _adaptagrams.Obstacle_router(self)

    def position(self):
        return _adaptagrams.Obstacle_position(self)

    def setNewPoly(self, poly):
        return _adaptagrams.Obstacle_setNewPoly(self, poly)

    def firstVert(self):
        return _adaptagrams.Obstacle_firstVert(self)

    def lastVert(self):
        return _adaptagrams.Obstacle_lastVert(self)

    def routingBox(self):
        return _adaptagrams.Obstacle_routingBox(self)

    def routingPolygon(self):
        return _adaptagrams.Obstacle_routingPolygon(self)

    def attachedConnectors(self):
        return _adaptagrams.Obstacle_attachedConnectors(self)
Obstacle_swigregister = _adaptagrams.Obstacle_swigregister
Obstacle_swigregister(Obstacle)

TransformationType_CW90 = _adaptagrams.TransformationType_CW90
TransformationType_CW180 = _adaptagrams.TransformationType_CW180
TransformationType_CW270 = _adaptagrams.TransformationType_CW270
TransformationType_FlipX = _adaptagrams.TransformationType_FlipX
TransformationType_FlipY = _adaptagrams.TransformationType_FlipY
class ShapeRef(Obstacle):
    __swig_setmethods__ = {}
    for _s in [Obstacle]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ShapeRef, name, value)
    __swig_getmethods__ = {}
    for _s in [Obstacle]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ShapeRef, name)
    __repr__ = _swig_repr

    def __init__(self, router, poly, id=0):
        this = _adaptagrams.new_ShapeRef(router, poly, id)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def polygon(self):
        return _adaptagrams.ShapeRef_polygon(self)

    def transformConnectionPinPositions(self, transform):
        return _adaptagrams.ShapeRef_transformConnectionPinPositions(self, transform)

    def position(self):
        return _adaptagrams.ShapeRef_position(self)
ShapeRef_swigregister = _adaptagrams.ShapeRef_swigregister
ShapeRef_swigregister(ShapeRef)

class JunctionRef(Obstacle):
    __swig_setmethods__ = {}
    for _s in [Obstacle]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, JunctionRef, name, value)
    __swig_getmethods__ = {}
    for _s in [Obstacle]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, JunctionRef, name)
    __repr__ = _swig_repr

    def __init__(self, router, position, id=0):
        this = _adaptagrams.new_JunctionRef(router, position, id)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def removeJunctionAndMergeConnectors(self):
        return _adaptagrams.JunctionRef_removeJunctionAndMergeConnectors(self)

    def position(self):
        return _adaptagrams.JunctionRef_position(self)

    def setPositionFixed(self, fixed):
        return _adaptagrams.JunctionRef_setPositionFixed(self, fixed)

    def positionFixed(self):
        return _adaptagrams.JunctionRef_positionFixed(self)

    def recommendedPosition(self):
        return _adaptagrams.JunctionRef_recommendedPosition(self)

    def makeRectangle(self, router, position):
        return _adaptagrams.JunctionRef_makeRectangle(self, router, position)

    def preferOrthogonalDimension(self, dim):
        return _adaptagrams.JunctionRef_preferOrthogonalDimension(self, dim)
JunctionRef_swigregister = _adaptagrams.JunctionRef_swigregister
JunctionRef_swigregister(JunctionRef)

class ClusterRef(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ClusterRef, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ClusterRef, name)
    __repr__ = _swig_repr

    def __init__(self, router, poly, id=0):
        this = _adaptagrams.new_ClusterRef(router, poly, id)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def setNewPoly(self, poly):
        return _adaptagrams.ClusterRef_setNewPoly(self, poly)

    def id(self):
        return _adaptagrams.ClusterRef_id(self)

    def polygon(self):
        return _adaptagrams.ClusterRef_polygon(self)

    def rectangularPolygon(self):
        return _adaptagrams.ClusterRef_rectangularPolygon(self)

    def router(self):
        return _adaptagrams.ClusterRef_router(self)

    def makeActive(self):
        return _adaptagrams.ClusterRef_makeActive(self)

    def makeInactive(self):
        return _adaptagrams.ClusterRef_makeInactive(self)
ClusterRef_swigregister = _adaptagrams.ClusterRef_swigregister
ClusterRef_swigregister(ClusterRef)

class ShapeConnectionPin(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ShapeConnectionPin, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ShapeConnectionPin, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _adaptagrams.new_ShapeConnectionPin(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def setConnectionCost(self, cost):
        return _adaptagrams.ShapeConnectionPin_setConnectionCost(self, cost)

    def position(self, *args):
        return _adaptagrams.ShapeConnectionPin_position(self, *args)

    def directions(self):
        return _adaptagrams.ShapeConnectionPin_directions(self)

    def setExclusive(self, exclusive):
        return _adaptagrams.ShapeConnectionPin_setExclusive(self, exclusive)

    def isExclusive(self):
        return _adaptagrams.ShapeConnectionPin_isExclusive(self)

    def ids(self):
        return _adaptagrams.ShapeConnectionPin_ids(self)
ShapeConnectionPin_swigregister = _adaptagrams.ShapeConnectionPin_swigregister
ShapeConnectionPin_swigregister(ShapeConnectionPin)
CONNECTIONPIN_UNSET = cvar.CONNECTIONPIN_UNSET
CONNECTIONPIN_CENTRE = cvar.CONNECTIONPIN_CENTRE
ATTACH_POS_TOP = cvar.ATTACH_POS_TOP
ATTACH_POS_CENTRE = cvar.ATTACH_POS_CENTRE
ATTACH_POS_BOTTOM = cvar.ATTACH_POS_BOTTOM
ATTACH_POS_LEFT = cvar.ATTACH_POS_LEFT
ATTACH_POS_RIGHT = cvar.ATTACH_POS_RIGHT
ATTACH_POS_MIN_OFFSET = cvar.ATTACH_POS_MIN_OFFSET
ATTACH_POS_MAX_OFFSET = cvar.ATTACH_POS_MAX_OFFSET

class CmpConnPinPtr(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CmpConnPinPtr, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CmpConnPinPtr, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _adaptagrams.new_CmpConnPinPtr()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _adaptagrams.delete_CmpConnPinPtr
    __del__ = lambda self: None
CmpConnPinPtr_swigregister = _adaptagrams.CmpConnPinPtr_swigregister
CmpConnPinPtr_swigregister(CmpConnPinPtr)

class Node(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Node, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Node, name)
    __repr__ = _swig_repr
    __swig_getmethods__["id"] = _adaptagrams.Node_id_get
    if _newclass:
        id = _swig_property(_adaptagrams.Node_id_get)
    __swig_setmethods__["rect"] = _adaptagrams.Node_rect_set
    __swig_getmethods__["rect"] = _adaptagrams.Node_rect_get
    if _newclass:
        rect = _swig_property(_adaptagrams.Node_rect_get, _adaptagrams.Node_rect_set)

    def __init__(self, id, r, v=None):
        this = _adaptagrams.new_Node(id, r, v)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def setDesiredPos(self, d, weight=1.0):
        return _adaptagrams.Node_setDesiredPos(self, d, weight)

    def initialPos(self, scanDim):
        return _adaptagrams.Node_initialPos(self, scanDim)

    def finalPos(self):
        return _adaptagrams.Node_finalPos(self)

    def posOnLine(self, scanDim, alpha):
        return _adaptagrams.Node_posOnLine(self, scanDim, alpha)

    def getVarConst(self):
        return _adaptagrams.Node_getVarConst(self)
    __swig_setmethods__["var"] = _adaptagrams.Node_var_set
    __swig_getmethods__["var"] = _adaptagrams.Node_var_get
    if _newclass:
        var = _swig_property(_adaptagrams.Node_var_get, _adaptagrams.Node_var_set)
Node_swigregister = _adaptagrams.Node_swigregister
Node_swigregister(Node)


def setNodeVariables(ns, vs):
    return _adaptagrams.setNodeVariables(ns, vs)
setNodeVariables = _adaptagrams.setNodeVariables
class EdgePoint(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, EdgePoint, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, EdgePoint, name)
    __repr__ = _swig_repr
    __swig_setmethods__["node"] = _adaptagrams.EdgePoint_node_set
    __swig_getmethods__["node"] = _adaptagrams.EdgePoint_node_get
    if _newclass:
        node = _swig_property(_adaptagrams.EdgePoint_node_get, _adaptagrams.EdgePoint_node_set)
    TR = _adaptagrams.EdgePoint_TR
    BR = _adaptagrams.EdgePoint_BR
    BL = _adaptagrams.EdgePoint_BL
    TL = _adaptagrams.EdgePoint_TL
    CENTRE = _adaptagrams.EdgePoint_CENTRE
    __swig_setmethods__["rectIntersect"] = _adaptagrams.EdgePoint_rectIntersect_set
    __swig_getmethods__["rectIntersect"] = _adaptagrams.EdgePoint_rectIntersect_get
    if _newclass:
        rectIntersect = _swig_property(_adaptagrams.EdgePoint_rectIntersect_get, _adaptagrams.EdgePoint_rectIntersect_set)

    def createBendConstraint(self, scanDim):
        return _adaptagrams.EdgePoint_createBendConstraint(self, scanDim)

    def __init__(self, n, i):
        this = _adaptagrams.new_EdgePoint(n, i)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def pos(self, dim):
        return _adaptagrams.EdgePoint_pos(self, dim)

    def posX(self):
        return _adaptagrams.EdgePoint_posX(self)

    def posY(self):
        return _adaptagrams.EdgePoint_posY(self)

    def rectIntersectAsVertexNumber(self):
        return _adaptagrams.EdgePoint_rectIntersectAsVertexNumber(self)

    def uniqueCheck(self, e):
        return _adaptagrams.EdgePoint_uniqueCheck(self, e)

    def isEnd(self):
        return _adaptagrams.EdgePoint_isEnd(self)

    def assertConvexBend(self):
        return _adaptagrams.EdgePoint_assertConvexBend(self)

    def offset(self, scanDim):
        return _adaptagrams.EdgePoint_offset(self, scanDim)

    def prune(self, scanDim):
        return _adaptagrams.EdgePoint_prune(self, scanDim)
EdgePoint_swigregister = _adaptagrams.EdgePoint_swigregister
EdgePoint_swigregister(EdgePoint)

class Edge(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Edge, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Edge, name)
    __repr__ = _swig_repr
    __swig_setmethods__["id"] = _adaptagrams.Edge_id_set
    __swig_getmethods__["id"] = _adaptagrams.Edge_id_get
    if _newclass:
        id = _swig_property(_adaptagrams.Edge_id_get, _adaptagrams.Edge_id_set)
    __swig_setmethods__["idealLength"] = _adaptagrams.Edge_idealLength_set
    __swig_getmethods__["idealLength"] = _adaptagrams.Edge_idealLength_get
    if _newclass:
        idealLength = _swig_property(_adaptagrams.Edge_idealLength_get, _adaptagrams.Edge_idealLength_set)
    __swig_setmethods__["nSegments"] = _adaptagrams.Edge_nSegments_set
    __swig_getmethods__["nSegments"] = _adaptagrams.Edge_nSegments_get
    if _newclass:
        nSegments = _swig_property(_adaptagrams.Edge_nSegments_get, _adaptagrams.Edge_nSegments_set)

    def __init__(self, id, idealLength, vs):
        this = _adaptagrams.new_Edge(id, idealLength, vs)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def pathLength(self):
        return _adaptagrams.Edge_pathLength(self)

    def getPath(self, vs):
        return _adaptagrams.Edge_getPath(self, vs)

    def assertConvexBends(self):
        return _adaptagrams.Edge_assertConvexBends(self)

    def cycle(self):
        return _adaptagrams.Edge_cycle(self)
Edge_swigregister = _adaptagrams.Edge_swigregister
Edge_swigregister(Edge)


def crossProduct(x0, y0, x1, y1, x2, y2):
    return _adaptagrams.crossProduct(x0, y0, x1, y1, x2, y2)
crossProduct = _adaptagrams.crossProduct
class ColaTopologyAddon(TopologyAddonInterface):
    __swig_setmethods__ = {}
    for _s in [TopologyAddonInterface]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ColaTopologyAddon, name, value)
    __swig_getmethods__ = {}
    for _s in [TopologyAddonInterface]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ColaTopologyAddon, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _adaptagrams.new_ColaTopologyAddon(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def writeSVGFile(self, *args):
        return _adaptagrams.ColaTopologyAddon_writeSVGFile(self, *args)

    def clone(self):
        return _adaptagrams.ColaTopologyAddon_clone(self)

    def freeAssociatedObjects(self):
        return _adaptagrams.ColaTopologyAddon_freeAssociatedObjects(self)

    def handleResizes(self, resizeList, n, X, Y, ccs, boundingBoxes, clusterHierarchy):
        return _adaptagrams.ColaTopologyAddon_handleResizes(self, resizeList, n, X, Y, ccs, boundingBoxes, clusterHierarchy)

    def computePathLengths(self, G):
        return _adaptagrams.ColaTopologyAddon_computePathLengths(self, G)

    def computeStress(self):
        return _adaptagrams.ColaTopologyAddon_computeStress(self)

    def useTopologySolver(self):
        return _adaptagrams.ColaTopologyAddon_useTopologySolver(self)

    def makeFeasible(self, generateNonOverlapConstraints, boundingBoxes, clusterHierarchy):
        return _adaptagrams.ColaTopologyAddon_makeFeasible(self, generateNonOverlapConstraints, boundingBoxes, clusterHierarchy)

    def moveTo(self, dim, vs, cs, coords, clusterHierarchy):
        return _adaptagrams.ColaTopologyAddon_moveTo(self, dim, vs, cs, coords, clusterHierarchy)

    def applyForcesAndConstraints(self, layout, dim, g, vs, cs, coords, des, oldStress):
        return _adaptagrams.ColaTopologyAddon_applyForcesAndConstraints(self, layout, dim, g, vs, cs, coords, des, oldStress)
    __swig_setmethods__["topologyNodes"] = _adaptagrams.ColaTopologyAddon_topologyNodes_set
    __swig_getmethods__["topologyNodes"] = _adaptagrams.ColaTopologyAddon_topologyNodes_get
    if _newclass:
        topologyNodes = _swig_property(_adaptagrams.ColaTopologyAddon_topologyNodes_get, _adaptagrams.ColaTopologyAddon_topologyNodes_set)
    __swig_setmethods__["topologyRoutes"] = _adaptagrams.ColaTopologyAddon_topologyRoutes_set
    __swig_getmethods__["topologyRoutes"] = _adaptagrams.ColaTopologyAddon_topologyRoutes_get
    if _newclass:
        topologyRoutes = _swig_property(_adaptagrams.ColaTopologyAddon_topologyRoutes_get, _adaptagrams.ColaTopologyAddon_topologyRoutes_set)
    __swig_setmethods__["debugSVGViewBox"] = _adaptagrams.ColaTopologyAddon_debugSVGViewBox_set
    __swig_getmethods__["debugSVGViewBox"] = _adaptagrams.ColaTopologyAddon_debugSVGViewBox_get
    if _newclass:
        debugSVGViewBox = _swig_property(_adaptagrams.ColaTopologyAddon_debugSVGViewBox_get, _adaptagrams.ColaTopologyAddon_debugSVGViewBox_set)
ColaTopologyAddon_swigregister = _adaptagrams.ColaTopologyAddon_swigregister
ColaTopologyAddon_swigregister(ColaTopologyAddon)

class AvoidTopologyAddon(AvoidTopologyAddonInterface):
    __swig_setmethods__ = {}
    for _s in [AvoidTopologyAddonInterface]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AvoidTopologyAddon, name, value)
    __swig_getmethods__ = {}
    for _s in [AvoidTopologyAddonInterface]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AvoidTopologyAddon, name)
    __repr__ = _swig_repr

    def __init__(self, rs, cs, ch, map, moveLimit=120):
        this = _adaptagrams.new_AvoidTopologyAddon(rs, cs, ch, map, moveLimit)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _adaptagrams.delete_AvoidTopologyAddon
    __del__ = lambda self: None

    def clone(self):
        return _adaptagrams.AvoidTopologyAddon_clone(self)

    def improveOrthogonalTopology(self, router):
        return _adaptagrams.AvoidTopologyAddon_improveOrthogonalTopology(self, router)

    def outputCode(self, fp):
        return _adaptagrams.AvoidTopologyAddon_outputCode(self, fp)

    def outputDeletionCode(self, fp):
        return _adaptagrams.AvoidTopologyAddon_outputDeletionCode(self, fp)
AvoidTopologyAddon_swigregister = _adaptagrams.AvoidTopologyAddon_swigregister
AvoidTopologyAddon_swigregister(AvoidTopologyAddon)

ACAHORIZ = _adaptagrams.ACAHORIZ
ACAVERT = _adaptagrams.ACAVERT
ACADELIB = _adaptagrams.ACADELIB
ACACONN = _adaptagrams.ACACONN
ACANOSEP = _adaptagrams.ACANOSEP
ACANORTH = _adaptagrams.ACANORTH
ACAEAST = _adaptagrams.ACAEAST
ACASOUTH = _adaptagrams.ACASOUTH
ACAWEST = _adaptagrams.ACAWEST
ACANORTHEAST = _adaptagrams.ACANORTHEAST
ACASOUTHEAST = _adaptagrams.ACASOUTHEAST
ACANORTHWEST = _adaptagrams.ACANORTHWEST
ACASOUTHWEST = _adaptagrams.ACASOUTHWEST
ACANORTHSOUTH = _adaptagrams.ACANORTHSOUTH
ACAEASTWEST = _adaptagrams.ACAEASTWEST
ACANOTNORTH = _adaptagrams.ACANOTNORTH
ACANOTEAST = _adaptagrams.ACANOTEAST
ACANOTSOUTH = _adaptagrams.ACANOTSOUTH
ACANOTWEST = _adaptagrams.ACANOTWEST
ACAALLSEP = _adaptagrams.ACAALLSEP

def negateSepFlag(sf):
    return _adaptagrams.negateSepFlag(sf)
negateSepFlag = _adaptagrams.negateSepFlag

def sepToAlignFlag(sf):
    return _adaptagrams.sepToAlignFlag(sf)
sepToAlignFlag = _adaptagrams.sepToAlignFlag

def perpAlignFlag(af):
    return _adaptagrams.perpAlignFlag(af)
perpAlignFlag = _adaptagrams.perpAlignFlag

def vectorToSepFlag(dx, dy):
    return _adaptagrams.vectorToSepFlag(dx, dy)
vectorToSepFlag = _adaptagrams.vectorToSepFlag

def propsedSepConflictsWithExistingPosition(pro, ex):
    return _adaptagrams.propsedSepConflictsWithExistingPosition(pro, ex)
propsedSepConflictsWithExistingPosition = _adaptagrams.propsedSepConflictsWithExistingPosition
class OrderedAlignment(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OrderedAlignment, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OrderedAlignment, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _adaptagrams.new_OrderedAlignment()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _adaptagrams.delete_OrderedAlignment
    __del__ = lambda self: None
    __swig_setmethods__["af"] = _adaptagrams.OrderedAlignment_af_set
    __swig_getmethods__["af"] = _adaptagrams.OrderedAlignment_af_get
    if _newclass:
        af = _swig_property(_adaptagrams.OrderedAlignment_af_get, _adaptagrams.OrderedAlignment_af_set)
    __swig_setmethods__["sf"] = _adaptagrams.OrderedAlignment_sf_set
    __swig_getmethods__["sf"] = _adaptagrams.OrderedAlignment_sf_get
    if _newclass:
        sf = _swig_property(_adaptagrams.OrderedAlignment_sf_get, _adaptagrams.OrderedAlignment_sf_set)
    __swig_setmethods__["dim"] = _adaptagrams.OrderedAlignment_dim_set
    __swig_getmethods__["dim"] = _adaptagrams.OrderedAlignment_dim_get
    if _newclass:
        dim = _swig_property(_adaptagrams.OrderedAlignment_dim_get, _adaptagrams.OrderedAlignment_dim_set)
    __swig_setmethods__["src"] = _adaptagrams.OrderedAlignment_src_set
    __swig_getmethods__["src"] = _adaptagrams.OrderedAlignment_src_get
    if _newclass:
        src = _swig_property(_adaptagrams.OrderedAlignment_src_get, _adaptagrams.OrderedAlignment_src_set)
    __swig_setmethods__["tgt"] = _adaptagrams.OrderedAlignment_tgt_set
    __swig_getmethods__["tgt"] = _adaptagrams.OrderedAlignment_tgt_get
    if _newclass:
        tgt = _swig_property(_adaptagrams.OrderedAlignment_tgt_get, _adaptagrams.OrderedAlignment_tgt_set)
    __swig_setmethods__["offsetSrc"] = _adaptagrams.OrderedAlignment_offsetSrc_set
    __swig_getmethods__["offsetSrc"] = _adaptagrams.OrderedAlignment_offsetSrc_get
    if _newclass:
        offsetSrc = _swig_property(_adaptagrams.OrderedAlignment_offsetSrc_get, _adaptagrams.OrderedAlignment_offsetSrc_set)
    __swig_setmethods__["offsetTgt"] = _adaptagrams.OrderedAlignment_offsetTgt_set
    __swig_getmethods__["offsetTgt"] = _adaptagrams.OrderedAlignment_offsetTgt_get
    if _newclass:
        offsetTgt = _swig_property(_adaptagrams.OrderedAlignment_offsetTgt_get, _adaptagrams.OrderedAlignment_offsetTgt_set)
    __swig_setmethods__["separation"] = _adaptagrams.OrderedAlignment_separation_set
    __swig_getmethods__["separation"] = _adaptagrams.OrderedAlignment_separation_get
    if _newclass:
        separation = _swig_property(_adaptagrams.OrderedAlignment_separation_get, _adaptagrams.OrderedAlignment_separation_set)
    __swig_setmethods__["alignment"] = _adaptagrams.OrderedAlignment_alignment_set
    __swig_getmethods__["alignment"] = _adaptagrams.OrderedAlignment_alignment_get
    if _newclass:
        alignment = _swig_property(_adaptagrams.OrderedAlignment_alignment_get, _adaptagrams.OrderedAlignment_alignment_set)
    __swig_setmethods__["edgeIndex"] = _adaptagrams.OrderedAlignment_edgeIndex_set
    __swig_getmethods__["edgeIndex"] = _adaptagrams.OrderedAlignment_edgeIndex_get
    if _newclass:
        edgeIndex = _swig_property(_adaptagrams.OrderedAlignment_edgeIndex_get, _adaptagrams.OrderedAlignment_edgeIndex_set)
    __swig_setmethods__["penalty"] = _adaptagrams.OrderedAlignment_penalty_set
    __swig_getmethods__["penalty"] = _adaptagrams.OrderedAlignment_penalty_get
    if _newclass:
        penalty = _swig_property(_adaptagrams.OrderedAlignment_penalty_get, _adaptagrams.OrderedAlignment_penalty_set)
OrderedAlignment_swigregister = _adaptagrams.OrderedAlignment_swigregister
OrderedAlignment_swigregister(OrderedAlignment)


def sortOrdAlignsByPenalty(lhs, rhs):
    return _adaptagrams.sortOrdAlignsByPenalty(lhs, rhs)
sortOrdAlignsByPenalty = _adaptagrams.sortOrdAlignsByPenalty
class ACALayout(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ACALayout, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ACALayout, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _adaptagrams.new_ACALayout(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def createAlignments(self):
        return _adaptagrams.ACALayout_createAlignments(self)

    def createOneAlignment(self):
        return _adaptagrams.ACALayout_createOneAlignment(self)

    def applyOAsAllOrNothing(self, oas):
        return _adaptagrams.ACALayout_applyOAsAllOrNothing(self, oas)

    def layout(self):
        return _adaptagrams.ACALayout_layout(self)

    def removeOverlaps(self):
        return _adaptagrams.ACALayout_removeOverlaps(self)

    def layoutWithCurrentConstraints(self):
        return _adaptagrams.ACALayout_layoutWithCurrentConstraints(self)

    def updateGraph(self):
        return _adaptagrams.ACALayout_updateGraph(self)

    def updateSepMatrix(self, *args):
        return _adaptagrams.ACALayout_updateSepMatrix(self, *args)

    def outputInstanceToSVG(self, filename):
        return _adaptagrams.ACALayout_outputInstanceToSVG(self, filename)

    def getFDLayout(self):
        return _adaptagrams.ACALayout_getFDLayout(self)

    def addBendPointPenalty(self, b):
        return _adaptagrams.ACALayout_addBendPointPenalty(self, b)

    def favourLongEdges(self, b):
        return _adaptagrams.ACALayout_favourLongEdges(self, b)

    def postponeLeaves(self, b):
        return _adaptagrams.ACALayout_postponeLeaves(self, b)

    def useNonLeafDegree(self, b):
        return _adaptagrams.ACALayout_useNonLeafDegree(self, b)

    def allAtOnce(self, b):
        return _adaptagrams.ACALayout_allAtOnce(self, b)

    def aggressiveOrdering(self, b):
        return _adaptagrams.ACALayout_aggressiveOrdering(self, b)

    def setAvoidNodeOverlaps(self, avoidOverlaps):
        return _adaptagrams.ACALayout_setAvoidNodeOverlaps(self, avoidOverlaps)

    def ignoreEdges(self, ignore):
        return _adaptagrams.ACALayout_ignoreEdges(self, ignore)

    def ignoreNodesForOPWithOffsets(self, ignore):
        return _adaptagrams.ACALayout_ignoreNodesForOPWithOffsets(self, ignore)

    def setNodeAliases(self, aliases):
        return _adaptagrams.ACALayout_setNodeAliases(self, aliases)

    def setAlignmentOffsetsForCompassDirection(self, sf, offsets):
        return _adaptagrams.ACALayout_setAlignmentOffsetsForCompassDirection(self, sf, offsets)

    def setAllowedDirections(self, seps):
        return _adaptagrams.ACALayout_setAllowedDirections(self, seps)

    def setClusterHierarchy(self, rc):
        return _adaptagrams.ACALayout_setClusterHierarchy(self, rc)

    def edgeIsAligned(self, j):
        return _adaptagrams.ACALayout_edgeIsAligned(self, j)

    def addGroupOfNonOverlapExemptRectangles(self, rs):
        return _adaptagrams.ACALayout_addGroupOfNonOverlapExemptRectangles(self, rs)

    def nodesAreAligned(self, i, j):
        return _adaptagrams.ACALayout_nodesAreAligned(self, i, j)

    def layoutPeriod(self, p):
        return _adaptagrams.ACALayout_layoutPeriod(self, p)

    def doFinalLayout(self, b):
        return _adaptagrams.ACALayout_doFinalLayout(self, b)

    def addOrderedAlignments(self, oas):
        return _adaptagrams.ACALayout_addOrderedAlignments(self, oas)

    def initOrdAlign(self, *args):
        return _adaptagrams.ACALayout_initOrdAlign(self, *args)

    def mostRecentOA(self):
        return _adaptagrams.ACALayout_mostRecentOA(self)

    def writeAlignmentTable(self):
        return _adaptagrams.ACALayout_writeAlignmentTable(self)
    __swig_setmethods__["aStateBeforeChop"] = _adaptagrams.ACALayout_aStateBeforeChop_set
    __swig_getmethods__["aStateBeforeChop"] = _adaptagrams.ACALayout_aStateBeforeChop_get
    if _newclass:
        aStateBeforeChop = _swig_property(_adaptagrams.ACALayout_aStateBeforeChop_get, _adaptagrams.ACALayout_aStateBeforeChop_set)

    def writeStateForNodeIds(self, id1, id2):
        return _adaptagrams.ACALayout_writeStateForNodeIds(self, id1, id2)
ACALayout_swigregister = _adaptagrams.ACALayout_swigregister
ACALayout_swigregister(ACALayout)

LinkShape_TLC = _adaptagrams.LinkShape_TLC
LinkShape_H = _adaptagrams.LinkShape_H
LinkShape_BLC = _adaptagrams.LinkShape_BLC
LinkShape_TRC = _adaptagrams.LinkShape_TRC
LinkShape_V = _adaptagrams.LinkShape_V
LinkShape_BRC = _adaptagrams.LinkShape_BRC

def bentLinkShapeCwFromStartingPt(start):
    return _adaptagrams.bentLinkShapeCwFromStartingPt(start)
bentLinkShapeCwFromStartingPt = _adaptagrams.bentLinkShapeCwFromStartingPt

def lookupMinimalBendSeqs(A, d0, Z, d1):
    return _adaptagrams.lookupMinimalBendSeqs(A, d0, Z, d1)
lookupMinimalBendSeqs = _adaptagrams.lookupMinimalBendSeqs

def possibleCardinalDirections(node1, node2):
    return _adaptagrams.possibleCardinalDirections(node1, node2)
possibleCardinalDirections = _adaptagrams.possibleCardinalDirections

def shapeOfLink(link):
    return _adaptagrams.shapeOfLink(link)
shapeOfLink = _adaptagrams.shapeOfLink
class BendSequence(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BendSequence, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BendSequence, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _adaptagrams.new_BendSequence(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def size(self):
        return _adaptagrams.BendSequence_size(self)
    __swig_setmethods__["bendTypes"] = _adaptagrams.BendSequence_bendTypes_set
    __swig_getmethods__["bendTypes"] = _adaptagrams.BendSequence_bendTypes_get
    if _newclass:
        bendTypes = _swig_property(_adaptagrams.BendSequence_bendTypes_get, _adaptagrams.BendSequence_bendTypes_set)
    __swig_setmethods__["bendPoints"] = _adaptagrams.BendSequence_bendPoints_set
    __swig_getmethods__["bendPoints"] = _adaptagrams.BendSequence_bendPoints_get
    if _newclass:
        bendPoints = _swig_property(_adaptagrams.BendSequence_bendPoints_get, _adaptagrams.BendSequence_bendPoints_set)
    __swig_setmethods__["cost"] = _adaptagrams.BendSequence_cost_set
    __swig_getmethods__["cost"] = _adaptagrams.BendSequence_cost_get
    if _newclass:
        cost = _swig_property(_adaptagrams.BendSequence_cost_get, _adaptagrams.BendSequence_cost_set)
    __swig_setmethods__["incomingDirec"] = _adaptagrams.BendSequence_incomingDirec_set
    __swig_getmethods__["incomingDirec"] = _adaptagrams.BendSequence_incomingDirec_get
    if _newclass:
        incomingDirec = _swig_property(_adaptagrams.BendSequence_incomingDirec_get, _adaptagrams.BendSequence_incomingDirec_set)
    __swig_setmethods__["outgoingDirec"] = _adaptagrams.BendSequence_outgoingDirec_set
    __swig_getmethods__["outgoingDirec"] = _adaptagrams.BendSequence_outgoingDirec_get
    if _newclass:
        outgoingDirec = _swig_property(_adaptagrams.BendSequence_outgoingDirec_get, _adaptagrams.BendSequence_outgoingDirec_set)
    __swig_destroy__ = _adaptagrams.delete_BendSequence
    __del__ = lambda self: None
BendSequence_swigregister = _adaptagrams.BendSequence_swigregister
BendSequence_swigregister(BendSequence)
bentLinkShapeCw = cvar.bentLinkShapeCw
applyBendToDir = cvar.applyBendToDir
cwIncomingDirForBend = cvar.cwIncomingDirForBend
minimalBendSeqs = cvar.minimalBendSeqs

class AestheticBend(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AestheticBend, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AestheticBend, name)
    __repr__ = _swig_repr

    def __init__(self, edge, bendNode, nbrNode1, nbrNode2):
        this = _adaptagrams.new_AestheticBend(edge, bendNode, nbrNode1, nbrNode2)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def addBendToEdge(self):
        return _adaptagrams.AestheticBend_addBendToEdge(self)
    __swig_setmethods__["edge"] = _adaptagrams.AestheticBend_edge_set
    __swig_getmethods__["edge"] = _adaptagrams.AestheticBend_edge_get
    if _newclass:
        edge = _swig_property(_adaptagrams.AestheticBend_edge_get, _adaptagrams.AestheticBend_edge_set)
    __swig_setmethods__["bendNode"] = _adaptagrams.AestheticBend_bendNode_set
    __swig_getmethods__["bendNode"] = _adaptagrams.AestheticBend_bendNode_get
    if _newclass:
        bendNode = _swig_property(_adaptagrams.AestheticBend_bendNode_get, _adaptagrams.AestheticBend_bendNode_set)
    __swig_setmethods__["nbrNode1"] = _adaptagrams.AestheticBend_nbrNode1_set
    __swig_getmethods__["nbrNode1"] = _adaptagrams.AestheticBend_nbrNode1_get
    if _newclass:
        nbrNode1 = _swig_property(_adaptagrams.AestheticBend_nbrNode1_get, _adaptagrams.AestheticBend_nbrNode1_set)
    __swig_setmethods__["nbrNode2"] = _adaptagrams.AestheticBend_nbrNode2_set
    __swig_getmethods__["nbrNode2"] = _adaptagrams.AestheticBend_nbrNode2_get
    if _newclass:
        nbrNode2 = _swig_property(_adaptagrams.AestheticBend_nbrNode2_get, _adaptagrams.AestheticBend_nbrNode2_set)
    __swig_destroy__ = _adaptagrams.delete_AestheticBend
    __del__ = lambda self: None
AestheticBend_swigregister = _adaptagrams.AestheticBend_swigregister
AestheticBend_swigregister(AestheticBend)

class Chain(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Chain, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Chain, name)
    __repr__ = _swig_repr

    def __init__(self, G, nodes, isCycle=False):
        this = _adaptagrams.new_Chain(G, nodes, isCycle)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getNode(self, i):
        return _adaptagrams.Chain_getNode(self, i)

    def getEdge(self, i):
        return _adaptagrams.Chain_getEdge(self, i)

    def bendCost(self, bendType, i0):
        return _adaptagrams.Chain_bendCost(self, bendType, i0)

    def size(self):
        return _adaptagrams.Chain_size(self)

    def computePossibleBendSequences(self):
        return _adaptagrams.Chain_computePossibleBendSequences(self)

    def evaluateBendSequence(self, bendSeq):
        return _adaptagrams.Chain_evaluateBendSequence(self, bendSeq)

    def writeConfigSeq(self, bendSeq):
        return _adaptagrams.Chain_writeConfigSeq(self, bendSeq)

    def takeShapeBasedConfiguration(self):
        return _adaptagrams.Chain_takeShapeBasedConfiguration(self)

    def addAestheticBendsToEdges(self):
        return _adaptagrams.Chain_addAestheticBendsToEdges(self)
    __swig_destroy__ = _adaptagrams.delete_Chain
    __del__ = lambda self: None
Chain_swigregister = _adaptagrams.Chain_swigregister
Chain_swigregister(Chain)
Chain.npos = _adaptagrams.cvar.Chain_npos


def buildAllChainsInGraph(graph):
    return _adaptagrams.buildAllChainsInGraph(graph)
buildAllChainsInGraph = _adaptagrams.buildAllChainsInGraph
GapType_CENTRE = _adaptagrams.GapType_CENTRE
GapType_BDRY = _adaptagrams.GapType_BDRY
SepDir_EAST = _adaptagrams.SepDir_EAST
SepDir_SOUTH = _adaptagrams.SepDir_SOUTH
SepDir_WEST = _adaptagrams.SepDir_WEST
SepDir_NORTH = _adaptagrams.SepDir_NORTH
SepDir_RIGHT = _adaptagrams.SepDir_RIGHT
SepDir_DOWN = _adaptagrams.SepDir_DOWN
SepDir_LEFT = _adaptagrams.SepDir_LEFT
SepDir_UP = _adaptagrams.SepDir_UP
SepType_NONE = _adaptagrams.SepType_NONE
SepType_EQ = _adaptagrams.SepType_EQ
SepType_INEQ = _adaptagrams.SepType_INEQ

def sepDirIsCardinal(sd):
    return _adaptagrams.sepDirIsCardinal(sd)
sepDirIsCardinal = _adaptagrams.sepDirIsCardinal

def sepDirToCardinalDir(sd):
    return _adaptagrams.sepDirToCardinalDir(sd)
sepDirToCardinalDir = _adaptagrams.sepDirToCardinalDir

def cardinalDirToSepDir(dir):
    return _adaptagrams.cardinalDirToSepDir(dir)
cardinalDirToSepDir = _adaptagrams.cardinalDirToSepDir

def lateralWeakening(sd):
    return _adaptagrams.lateralWeakening(sd)
lateralWeakening = _adaptagrams.lateralWeakening

def cardinalStrengthening(sd):
    return _adaptagrams.cardinalStrengthening(sd)
cardinalStrengthening = _adaptagrams.cardinalStrengthening
SepTransform_ROTATE90CW = _adaptagrams.SepTransform_ROTATE90CW
SepTransform_ROTATE90ACW = _adaptagrams.SepTransform_ROTATE90ACW
SepTransform_ROTATE180 = _adaptagrams.SepTransform_ROTATE180
SepTransform_FLIPV = _adaptagrams.SepTransform_FLIPV
SepTransform_FLIPH = _adaptagrams.SepTransform_FLIPH
SepTransform_FLIPMD = _adaptagrams.SepTransform_FLIPMD
SepTransform_FLIPOD = _adaptagrams.SepTransform_FLIPOD
class SepPair(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SepPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SepPair, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _adaptagrams.new_SepPair()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["src"] = _adaptagrams.SepPair_src_set
    __swig_getmethods__["src"] = _adaptagrams.SepPair_src_get
    if _newclass:
        src = _swig_property(_adaptagrams.SepPair_src_get, _adaptagrams.SepPair_src_set)
    __swig_setmethods__["tgt"] = _adaptagrams.SepPair_tgt_set
    __swig_getmethods__["tgt"] = _adaptagrams.SepPair_tgt_get
    if _newclass:
        tgt = _swig_property(_adaptagrams.SepPair_tgt_get, _adaptagrams.SepPair_tgt_set)
    __swig_setmethods__["xgt"] = _adaptagrams.SepPair_xgt_set
    __swig_getmethods__["xgt"] = _adaptagrams.SepPair_xgt_get
    if _newclass:
        xgt = _swig_property(_adaptagrams.SepPair_xgt_get, _adaptagrams.SepPair_xgt_set)
    __swig_setmethods__["ygt"] = _adaptagrams.SepPair_ygt_set
    __swig_getmethods__["ygt"] = _adaptagrams.SepPair_ygt_get
    if _newclass:
        ygt = _swig_property(_adaptagrams.SepPair_ygt_get, _adaptagrams.SepPair_ygt_set)
    __swig_setmethods__["xst"] = _adaptagrams.SepPair_xst_set
    __swig_getmethods__["xst"] = _adaptagrams.SepPair_xst_get
    if _newclass:
        xst = _swig_property(_adaptagrams.SepPair_xst_get, _adaptagrams.SepPair_xst_set)
    __swig_setmethods__["yst"] = _adaptagrams.SepPair_yst_set
    __swig_getmethods__["yst"] = _adaptagrams.SepPair_yst_get
    if _newclass:
        yst = _swig_property(_adaptagrams.SepPair_yst_get, _adaptagrams.SepPair_yst_set)
    __swig_setmethods__["xgap"] = _adaptagrams.SepPair_xgap_set
    __swig_getmethods__["xgap"] = _adaptagrams.SepPair_xgap_get
    if _newclass:
        xgap = _swig_property(_adaptagrams.SepPair_xgap_get, _adaptagrams.SepPair_xgap_set)
    __swig_setmethods__["ygap"] = _adaptagrams.SepPair_ygap_set
    __swig_getmethods__["ygap"] = _adaptagrams.SepPair_ygap_get
    if _newclass:
        ygap = _swig_property(_adaptagrams.SepPair_ygap_get, _adaptagrams.SepPair_ygap_set)
    __swig_setmethods__["tglfPrecision"] = _adaptagrams.SepPair_tglfPrecision_set
    __swig_getmethods__["tglfPrecision"] = _adaptagrams.SepPair_tglfPrecision_get
    if _newclass:
        tglfPrecision = _swig_property(_adaptagrams.SepPair_tglfPrecision_get, _adaptagrams.SepPair_tglfPrecision_set)
    __swig_setmethods__["flippedRetrieval"] = _adaptagrams.SepPair_flippedRetrieval_set
    __swig_getmethods__["flippedRetrieval"] = _adaptagrams.SepPair_flippedRetrieval_get
    if _newclass:
        flippedRetrieval = _swig_property(_adaptagrams.SepPair_flippedRetrieval_get, _adaptagrams.SepPair_flippedRetrieval_set)

    def addSep(self, gt, sd, st, gap):
        return _adaptagrams.SepPair_addSep(self, gt, sd, st, gap)

    def transform(self, tf):
        return _adaptagrams.SepPair_transform(self, tf)

    def isVerticalCardinal(self):
        return _adaptagrams.SepPair_isVerticalCardinal(self)

    def isHorizontalCardinal(self):
        return _adaptagrams.SepPair_isHorizontalCardinal(self)

    def isVAlign(self):
        return _adaptagrams.SepPair_isVAlign(self)

    def isHAlign(self):
        return _adaptagrams.SepPair_isHAlign(self)

    def isCardinal(self):
        return _adaptagrams.SepPair_isCardinal(self)

    def getCardinalDir(self):
        return _adaptagrams.SepPair_getCardinalDir(self)

    def roundGapsUpAbs(self):
        return _adaptagrams.SepPair_roundGapsUpAbs(self)

    def writeTglf(self, id2ext, m):
        return _adaptagrams.SepPair_writeTglf(self, id2ext, m)

    def hasConstraintInDim(self, dim):
        return _adaptagrams.SepPair_hasConstraintInDim(self, dim)

    def generateSeparationConstraint(self, dim, cgr, m, vs):
        return _adaptagrams.SepPair_generateSeparationConstraint(self, dim, cgr, m, vs)
    __swig_destroy__ = _adaptagrams.delete_SepPair
    __del__ = lambda self: None
SepPair_swigregister = _adaptagrams.SepPair_swigregister
SepPair_swigregister(SepPair)

class SepPairSubConstraintInfo(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SepPairSubConstraintInfo, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SepPairSubConstraintInfo, name)
    __repr__ = _swig_repr

    def __init__(self, sp, dim):
        this = _adaptagrams.new_SepPairSubConstraintInfo(sp, dim)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["sp"] = _adaptagrams.SepPairSubConstraintInfo_sp_set
    __swig_getmethods__["sp"] = _adaptagrams.SepPairSubConstraintInfo_sp_get
    if _newclass:
        sp = _swig_property(_adaptagrams.SepPairSubConstraintInfo_sp_get, _adaptagrams.SepPairSubConstraintInfo_sp_set)
    __swig_setmethods__["dim"] = _adaptagrams.SepPairSubConstraintInfo_dim_set
    __swig_getmethods__["dim"] = _adaptagrams.SepPairSubConstraintInfo_dim_get
    if _newclass:
        dim = _swig_property(_adaptagrams.SepPairSubConstraintInfo_dim_get, _adaptagrams.SepPairSubConstraintInfo_dim_set)
    __swig_destroy__ = _adaptagrams.delete_SepPairSubConstraintInfo
    __del__ = lambda self: None
SepPairSubConstraintInfo_swigregister = _adaptagrams.SepPairSubConstraintInfo_swigregister
SepPairSubConstraintInfo_swigregister(SepPairSubConstraintInfo)

class SepMatrix(CompoundConstraint):
    __swig_setmethods__ = {}
    for _s in [CompoundConstraint]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SepMatrix, name, value)
    __swig_getmethods__ = {}
    for _s in [CompoundConstraint]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SepMatrix, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _adaptagrams.new_SepMatrix(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _adaptagrams.delete_SepMatrix
    __del__ = lambda self: None

    def addSep(self, id1, id2, gt, sd, st, gap):
        return _adaptagrams.SepMatrix_addSep(self, id1, id2, gt, sd, st, gap)

    def setCardinalOP(self, id1, id2, dir):
        return _adaptagrams.SepMatrix_setCardinalOP(self, id1, id2, dir)

    def addFixedRelativeSep(self, *args):
        return _adaptagrams.SepMatrix_addFixedRelativeSep(self, *args)

    def hAlign(self, id1, id2):
        return _adaptagrams.SepMatrix_hAlign(self, id1, id2)

    def vAlign(self, id1, id2):
        return _adaptagrams.SepMatrix_vAlign(self, id1, id2)

    def alignByEquatedCoord(self, id1, id2, eqCoord):
        return _adaptagrams.SepMatrix_alignByEquatedCoord(self, id1, id2, eqCoord)

    def free(self, id1, id2):
        return _adaptagrams.SepMatrix_free(self, id1, id2)

    def clear(self):
        return _adaptagrams.SepMatrix_clear(self)

    def setCorrespondingConstraints(self, matrix):
        return _adaptagrams.SepMatrix_setCorrespondingConstraints(self, matrix)

    def setSepPair(self, id1, id2, sp):
        return _adaptagrams.SepMatrix_setSepPair(self, id1, id2, sp)

    def transform(self, tf):
        return _adaptagrams.SepMatrix_transform(self, tf)

    def transformClosedSubset(self, tf, ids):
        return _adaptagrams.SepMatrix_transformClosedSubset(self, tf, ids)

    def transformOpenSubset(self, tf, ids):
        return _adaptagrams.SepMatrix_transformOpenSubset(self, tf, ids)

    def removeNode(self, id):
        return _adaptagrams.SepMatrix_removeNode(self, id)

    def removeNodes(self, nodes):
        return _adaptagrams.SepMatrix_removeNodes(self, nodes)

    def getCardinalDir(self, id1, id2):
        return _adaptagrams.SepMatrix_getCardinalDir(self, id1, id2)

    def getAlignedSets(self, hSets, vSets):
        return _adaptagrams.SepMatrix_getAlignedSets(self, hSets, vSets)

    def areHAligned(self, id1, id2):
        return _adaptagrams.SepMatrix_areHAligned(self, id1, id2)

    def areVAligned(self, id1, id2):
        return _adaptagrams.SepMatrix_areVAligned(self, id1, id2)

    def writeTglf(self, id2ext):
        return _adaptagrams.SepMatrix_writeTglf(self, id2ext)

    def setGraph(self, G):
        return _adaptagrams.SepMatrix_setGraph(self, G)

    def getGraph(self):
        return _adaptagrams.SepMatrix_getGraph(self)

    def roundGapsUpward(self):
        return _adaptagrams.SepMatrix_roundGapsUpward(self)

    def setExtraBdryGap(self, extraBdryGap):
        return _adaptagrams.SepMatrix_setExtraBdryGap(self, extraBdryGap)

    def getExtraBdryGap(self):
        return _adaptagrams.SepMatrix_getExtraBdryGap(self)

    def generateVariables(self, dim, vars):
        return _adaptagrams.SepMatrix_generateVariables(self, dim, vars)

    def generateSeparationConstraints(self, dim, vs, cs, bbs):
        return _adaptagrams.SepMatrix_generateSeparationConstraints(self, dim, vs, cs, bbs)

    def toString(self):
        return _adaptagrams.SepMatrix_toString(self)

    def markAllSubConstraintsAsInactive(self):
        return _adaptagrams.SepMatrix_markAllSubConstraintsAsInactive(self)

    def getCurrSubConstraintAlternatives(self, vs):
        return _adaptagrams.SepMatrix_getCurrSubConstraintAlternatives(self, vs)
SepMatrix_swigregister = _adaptagrams.SepMatrix_swigregister
SepMatrix_swigregister(SepMatrix)
PRIORITY_SEPMATRIX = cvar.PRIORITY_SEPMATRIX

class SepCo(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SepCo, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SepCo, name)
    __repr__ = _swig_repr

    def __init__(self, dim, left, right, gap, exact=False):
        this = _adaptagrams.new_SepCo(dim, left, right, gap, exact)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def generateColaConstraints(self, cgr, ccs):
        return _adaptagrams.SepCo_generateColaConstraints(self, cgr, ccs)

    def getDirecRelativeToNode(self, baseNode):
        return _adaptagrams.SepCo_getDirecRelativeToNode(self, baseNode)

    def addToMatrix(self, matrix):
        return _adaptagrams.SepCo_addToMatrix(self, matrix)

    def violation(self):
        return _adaptagrams.SepCo_violation(self)

    def toString(self):
        return _adaptagrams.SepCo_toString(self)
    __swig_setmethods__["dim"] = _adaptagrams.SepCo_dim_set
    __swig_getmethods__["dim"] = _adaptagrams.SepCo_dim_get
    if _newclass:
        dim = _swig_property(_adaptagrams.SepCo_dim_get, _adaptagrams.SepCo_dim_set)
    __swig_setmethods__["left"] = _adaptagrams.SepCo_left_set
    __swig_getmethods__["left"] = _adaptagrams.SepCo_left_get
    if _newclass:
        left = _swig_property(_adaptagrams.SepCo_left_get, _adaptagrams.SepCo_left_set)
    __swig_setmethods__["right"] = _adaptagrams.SepCo_right_set
    __swig_getmethods__["right"] = _adaptagrams.SepCo_right_get
    if _newclass:
        right = _swig_property(_adaptagrams.SepCo_right_get, _adaptagrams.SepCo_right_set)
    __swig_setmethods__["gap"] = _adaptagrams.SepCo_gap_set
    __swig_getmethods__["gap"] = _adaptagrams.SepCo_gap_get
    if _newclass:
        gap = _swig_property(_adaptagrams.SepCo_gap_get, _adaptagrams.SepCo_gap_set)
    __swig_setmethods__["exact"] = _adaptagrams.SepCo_exact_set
    __swig_getmethods__["exact"] = _adaptagrams.SepCo_exact_get
    if _newclass:
        exact = _swig_property(_adaptagrams.SepCo_exact_get, _adaptagrams.SepCo_exact_set)
    __swig_destroy__ = _adaptagrams.delete_SepCo
    __del__ = lambda self: None
SepCo_swigregister = _adaptagrams.SepCo_swigregister
SepCo_swigregister(SepCo)

class Projection(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Projection, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Projection, name)
    __repr__ = _swig_repr

    def __init__(self, s, d):
        this = _adaptagrams.new_Projection(s, d)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def size(self):
        return _adaptagrams.Projection_size(self)

    def generateColaConstraints(self, cgr):
        return _adaptagrams.Projection_generateColaConstraints(self, cgr)

    def toString(self):
        return _adaptagrams.Projection_toString(self)
    __swig_setmethods__["sepCoSet"] = _adaptagrams.Projection_sepCoSet_set
    __swig_getmethods__["sepCoSet"] = _adaptagrams.Projection_sepCoSet_get
    if _newclass:
        sepCoSet = _swig_property(_adaptagrams.Projection_sepCoSet_get, _adaptagrams.Projection_sepCoSet_set)
    __swig_setmethods__["dim"] = _adaptagrams.Projection_dim_set
    __swig_getmethods__["dim"] = _adaptagrams.Projection_dim_get
    if _newclass:
        dim = _swig_property(_adaptagrams.Projection_dim_get, _adaptagrams.Projection_dim_set)
    __swig_destroy__ = _adaptagrams.delete_Projection
    __del__ = lambda self: None
Projection_swigregister = _adaptagrams.Projection_swigregister
Projection_swigregister(Projection)

class ProjSeq(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ProjSeq, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ProjSeq, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _adaptagrams.new_ProjSeq()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def addProjection(self, sepCos, dim):
        return _adaptagrams.ProjSeq_addProjection(self, sepCos, dim)

    def nextProjection(self):
        return _adaptagrams.ProjSeq_nextProjection(self)

    def noteStresschange(self, dS):
        return _adaptagrams.ProjSeq_noteStresschange(self, dS)

    def toString(self):
        return _adaptagrams.ProjSeq_toString(self)

    def __iadd__(self, rhs):
        return _adaptagrams.ProjSeq___iadd__(self, rhs)

    def getAllConstraints(self):
        return _adaptagrams.ProjSeq_getAllConstraints(self)

    def reset(self):
        return _adaptagrams.ProjSeq_reset(self)

    def violation(self):
        return _adaptagrams.ProjSeq_violation(self)
    __swig_destroy__ = _adaptagrams.delete_ProjSeq
    __del__ = lambda self: None
ProjSeq_swigregister = _adaptagrams.ProjSeq_swigregister
ProjSeq_swigregister(ProjSeq)

class Side(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Side, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Side, name)
    __repr__ = _swig_repr

    def __init__(self, nodeSeq, direc):
        this = _adaptagrams.new_Side(nodeSeq, direc)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getNodeSeq(self):
        return _adaptagrams.Side_getNodeSeq(self)

    def containsNode(self, id):
        return _adaptagrams.Side_containsNode(self, id)

    def findNodeIndex(self, id):
        return _adaptagrams.Side_findNodeIndex(self, id)

    def getForwardDirec(self):
        return _adaptagrams.Side_getForwardDirec(self)

    def getAlignmentDimension(self):
        return _adaptagrams.Side_getAlignmentDimension(self)

    def firstNode(self):
        return _adaptagrams.Side_firstNode(self)

    def lastNode(self):
        return _adaptagrams.Side_lastNode(self)

    def toString(self):
        return _adaptagrams.Side_toString(self)

    def getCentreCoord(self):
        return _adaptagrams.Side_getCentreCoord(self)

    def getNumRootNodes(self):
        return _adaptagrams.Side_getNumRootNodes(self)

    def addTreePlacement(self, tp):
        return _adaptagrams.Side_addTreePlacement(self, tp)

    def computeCollateralProjSeq(self, tp, padding=0):
        return _adaptagrams.Side_computeCollateralProjSeq(self, tp, padding)

    def closedInterval(self):
        return _adaptagrams.Side_closedInterval(self)

    def getIntervalOppositeSegment(self, seg, openInterval=False):
        return _adaptagrams.Side_getIntervalOppositeSegment(self, seg, openInterval)

    def liesOppositeSegment(self, seg, openInterval=False):
        return _adaptagrams.Side_liesOppositeSegment(self, seg, openInterval)

    def getFirstPtOppositeSegment(self, seg):
        return _adaptagrams.Side_getFirstPtOppositeSegment(self, seg)

    def halfWidthOppositeSegment(self, seg):
        return _adaptagrams.Side_halfWidthOppositeSegment(self, seg)

    def getTreePlacements(self):
        return _adaptagrams.Side_getTreePlacements(self)
    __swig_destroy__ = _adaptagrams.delete_Side
    __del__ = lambda self: None
Side_swigregister = _adaptagrams.Side_swigregister
Side_swigregister(Side)

NexusPolarity_ENTER_FROM = _adaptagrams.NexusPolarity_ENTER_FROM
NexusPolarity_EXIT_TO = _adaptagrams.NexusPolarity_EXIT_TO
class Nexus(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Nexus, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Nexus, name)
    __repr__ = _swig_repr

    def __init__(self, u):
        this = _adaptagrams.new_Nexus(u)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def addSide(self, side):
        return _adaptagrams.Nexus_addSide(self, side)

    def getNeighboursOfADirection(self, direc):
        return _adaptagrams.Nexus_getNeighboursOfADirection(self, direc)

    def toString(self):
        return _adaptagrams.Nexus_toString(self)
    __swig_destroy__ = _adaptagrams.delete_Nexus
    __del__ = lambda self: None
Nexus_swigregister = _adaptagrams.Nexus_swigregister
Nexus_swigregister(Nexus)

class FaceSet(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FaceSet, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FaceSet, name)
    __repr__ = _swig_repr

    def __init__(self, G):
        this = _adaptagrams.new_FaceSet(G)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getNumFaces(self):
        return _adaptagrams.FaceSet_getNumFaces(self)

    def listAllPossibleTreePlacements(self, tree, opts):
        return _adaptagrams.FaceSet_listAllPossibleTreePlacements(self, tree, opts)

    def getAllTreePlacements(self):
        return _adaptagrams.FaceSet_getAllTreePlacements(self)

    def getFaces(self):
        return _adaptagrams.FaceSet_getFaces(self)

    def getExternalFace(self):
        return _adaptagrams.FaceSet_getExternalFace(self)

    def getNumTreesByGrowthDir(self, scaleBySize=False):
        return _adaptagrams.FaceSet_getNumTreesByGrowthDir(self, scaleBySize)
    __swig_destroy__ = _adaptagrams.delete_FaceSet
    __del__ = lambda self: None
FaceSet_swigregister = _adaptagrams.FaceSet_swigregister
FaceSet_swigregister(FaceSet)

class Face(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Face, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Face, name)
    __repr__ = _swig_repr

    def __init__(self, G):
        this = _adaptagrams.new_Face(G)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def initWithEdgeSeq(self, edges):
        return _adaptagrams.Face_initWithEdgeSeq(self, edges)

    def getNodeSeq(self):
        return _adaptagrams.Face_getNodeSeq(self)

    def getSides(self):
        return _adaptagrams.Face_getSides(self)

    def getNexusLookup(self):
        return _adaptagrams.Face_getNexusLookup(self)

    def containsNodeIdSeq(self, idSeq):
        return _adaptagrams.Face_containsNodeIdSeq(self, idSeq)

    def getGraph(self):
        return _adaptagrams.Face_getGraph(self)

    def id(self):
        return _adaptagrams.Face_id(self)

    def isExternal(self):
        return _adaptagrams.Face_isExternal(self)

    def toString(self):
        return _adaptagrams.Face_toString(self)

    def getNbrPairs(self):
        return _adaptagrams.Face_getNbrPairs(self)

    def getRelevantSidesForPlacement(self, tp):
        return _adaptagrams.Face_getRelevantSidesForPlacement(self, tp)

    def listAllPossibleTreePlacements(self, tps, tree, root, opts):
        return _adaptagrams.Face_listAllPossibleTreePlacements(self, tps, tree, root, opts)

    def inwardDirsAvailable(self, node):
        return _adaptagrams.Face_inwardDirsAvailable(self, node)

    def insertTreeNode(self, tp, padding=0):
        return _adaptagrams.Face_insertTreeNode(self, tp, padding)

    def computeCollateralProjSeq(self, tp, padding=0):
        return _adaptagrams.Face_computeCollateralProjSeq(self, tp, padding)

    def applyProjSeq(self, ps):
        return _adaptagrams.Face_applyProjSeq(self, ps)

    def doCollateralExpansion(self, tp, padding=-1):
        return _adaptagrams.Face_doCollateralExpansion(self, tp, padding)

    def buildBdrySegsFacingOneDir(self, facingDir, closedSegs, openSegs, ignoreTP=0):
        return _adaptagrams.Face_buildBdrySegsFacingOneDir(self, facingDir, closedSegs, openSegs, ignoreTP)

    def buildBestProjSeq(self, *args):
        return _adaptagrams.Face_buildBestProjSeq(self, *args)

    def getAllSidesOppositeSegment(self, seg, openInterval=False):
        return _adaptagrams.Face_getAllSidesOppositeSegment(self, seg, openInterval)

    def getSetOfAllTreePlacements(self):
        return _adaptagrams.Face_getSetOfAllTreePlacements(self)

    def getAllTreePlacements(self, *args):
        return _adaptagrams.Face_getAllTreePlacements(self, *args)

    def getNumTreesByGrowthDir(self, counts, scaleBySize=False):
        return _adaptagrams.Face_getNumTreesByGrowthDir(self, counts, scaleBySize)
    __swig_destroy__ = _adaptagrams.delete_Face
    __del__ = lambda self: None
Face_swigregister = _adaptagrams.Face_swigregister
Face_swigregister(Face)

class BoundingBox(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BoundingBox, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BoundingBox, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _adaptagrams.new_BoundingBox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __iadd__(self, rhs):
        return _adaptagrams.BoundingBox___iadd__(self, rhs)

    def repr(self):
        return _adaptagrams.BoundingBox_repr(self)

    def w(self):
        return _adaptagrams.BoundingBox_w(self)

    def h(self):
        return _adaptagrams.BoundingBox_h(self)

    def getInterval(self, dim):
        return _adaptagrams.BoundingBox_getInterval(self, dim)

    def centre(self):
        return _adaptagrams.BoundingBox_centre(self)

    def buildSideSegment(self, side):
        return _adaptagrams.BoundingBox_buildSideSegment(self, side)

    def perimeter(self):
        return _adaptagrams.BoundingBox_perimeter(self)
    __swig_setmethods__["x"] = _adaptagrams.BoundingBox_x_set
    __swig_getmethods__["x"] = _adaptagrams.BoundingBox_x_get
    if _newclass:
        x = _swig_property(_adaptagrams.BoundingBox_x_get, _adaptagrams.BoundingBox_x_set)
    __swig_setmethods__["X"] = _adaptagrams.BoundingBox_X_set
    __swig_getmethods__["X"] = _adaptagrams.BoundingBox_X_get
    if _newclass:
        X = _swig_property(_adaptagrams.BoundingBox_X_get, _adaptagrams.BoundingBox_X_set)
    __swig_setmethods__["y"] = _adaptagrams.BoundingBox_y_set
    __swig_getmethods__["y"] = _adaptagrams.BoundingBox_y_get
    if _newclass:
        y = _swig_property(_adaptagrams.BoundingBox_y_get, _adaptagrams.BoundingBox_y_set)
    __swig_setmethods__["Y"] = _adaptagrams.BoundingBox_Y_set
    __swig_getmethods__["Y"] = _adaptagrams.BoundingBox_Y_get
    if _newclass:
        Y = _swig_property(_adaptagrams.BoundingBox_Y_get, _adaptagrams.BoundingBox_Y_set)
    __swig_destroy__ = _adaptagrams.delete_BoundingBox
    __del__ = lambda self: None
BoundingBox_swigregister = _adaptagrams.BoundingBox_swigregister
BoundingBox_swigregister(BoundingBox)

class ColaOptions(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ColaOptions, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ColaOptions, name)
    __repr__ = _swig_repr
    __swig_setmethods__["idealEdgeLength"] = _adaptagrams.ColaOptions_idealEdgeLength_set
    __swig_getmethods__["idealEdgeLength"] = _adaptagrams.ColaOptions_idealEdgeLength_get
    if _newclass:
        idealEdgeLength = _swig_property(_adaptagrams.ColaOptions_idealEdgeLength_get, _adaptagrams.ColaOptions_idealEdgeLength_set)
    __swig_setmethods__["preventOverlaps"] = _adaptagrams.ColaOptions_preventOverlaps_set
    __swig_getmethods__["preventOverlaps"] = _adaptagrams.ColaOptions_preventOverlaps_get
    if _newclass:
        preventOverlaps = _swig_property(_adaptagrams.ColaOptions_preventOverlaps_get, _adaptagrams.ColaOptions_preventOverlaps_set)
    __swig_setmethods__["solidifyAlignedEdges"] = _adaptagrams.ColaOptions_solidifyAlignedEdges_set
    __swig_getmethods__["solidifyAlignedEdges"] = _adaptagrams.ColaOptions_solidifyAlignedEdges_get
    if _newclass:
        solidifyAlignedEdges = _swig_property(_adaptagrams.ColaOptions_solidifyAlignedEdges_get, _adaptagrams.ColaOptions_solidifyAlignedEdges_set)
    __swig_setmethods__["solidEdgeExemptions"] = _adaptagrams.ColaOptions_solidEdgeExemptions_set
    __swig_getmethods__["solidEdgeExemptions"] = _adaptagrams.ColaOptions_solidEdgeExemptions_get
    if _newclass:
        solidEdgeExemptions = _swig_property(_adaptagrams.ColaOptions_solidEdgeExemptions_get, _adaptagrams.ColaOptions_solidEdgeExemptions_set)
    __swig_setmethods__["xAxis"] = _adaptagrams.ColaOptions_xAxis_set
    __swig_getmethods__["xAxis"] = _adaptagrams.ColaOptions_xAxis_get
    if _newclass:
        xAxis = _swig_property(_adaptagrams.ColaOptions_xAxis_get, _adaptagrams.ColaOptions_xAxis_set)
    __swig_setmethods__["yAxis"] = _adaptagrams.ColaOptions_yAxis_set
    __swig_getmethods__["yAxis"] = _adaptagrams.ColaOptions_yAxis_get
    if _newclass:
        yAxis = _swig_property(_adaptagrams.ColaOptions_yAxis_get, _adaptagrams.ColaOptions_yAxis_set)
    __swig_setmethods__["makeFeasible"] = _adaptagrams.ColaOptions_makeFeasible_set
    __swig_getmethods__["makeFeasible"] = _adaptagrams.ColaOptions_makeFeasible_get
    if _newclass:
        makeFeasible = _swig_property(_adaptagrams.ColaOptions_makeFeasible_get, _adaptagrams.ColaOptions_makeFeasible_set)
    __swig_setmethods__["makeFeasible_xBorder"] = _adaptagrams.ColaOptions_makeFeasible_xBorder_set
    __swig_getmethods__["makeFeasible_xBorder"] = _adaptagrams.ColaOptions_makeFeasible_xBorder_get
    if _newclass:
        makeFeasible_xBorder = _swig_property(_adaptagrams.ColaOptions_makeFeasible_xBorder_get, _adaptagrams.ColaOptions_makeFeasible_xBorder_set)
    __swig_setmethods__["makeFeasible_yBorder"] = _adaptagrams.ColaOptions_makeFeasible_yBorder_set
    __swig_getmethods__["makeFeasible_yBorder"] = _adaptagrams.ColaOptions_makeFeasible_yBorder_get
    if _newclass:
        makeFeasible_yBorder = _swig_property(_adaptagrams.ColaOptions_makeFeasible_yBorder_get, _adaptagrams.ColaOptions_makeFeasible_yBorder_set)
    __swig_setmethods__["useNeighbourStress"] = _adaptagrams.ColaOptions_useNeighbourStress_set
    __swig_getmethods__["useNeighbourStress"] = _adaptagrams.ColaOptions_useNeighbourStress_get
    if _newclass:
        useNeighbourStress = _swig_property(_adaptagrams.ColaOptions_useNeighbourStress_get, _adaptagrams.ColaOptions_useNeighbourStress_set)
    __swig_setmethods__["nbrStressIELScalar"] = _adaptagrams.ColaOptions_nbrStressIELScalar_set
    __swig_getmethods__["nbrStressIELScalar"] = _adaptagrams.ColaOptions_nbrStressIELScalar_get
    if _newclass:
        nbrStressIELScalar = _swig_property(_adaptagrams.ColaOptions_nbrStressIELScalar_get, _adaptagrams.ColaOptions_nbrStressIELScalar_set)
    __swig_setmethods__["useMajorization"] = _adaptagrams.ColaOptions_useMajorization_set
    __swig_getmethods__["useMajorization"] = _adaptagrams.ColaOptions_useMajorization_get
    if _newclass:
        useMajorization = _swig_property(_adaptagrams.ColaOptions_useMajorization_get, _adaptagrams.ColaOptions_useMajorization_set)
    __swig_setmethods__["useScaling"] = _adaptagrams.ColaOptions_useScaling_set
    __swig_getmethods__["useScaling"] = _adaptagrams.ColaOptions_useScaling_get
    if _newclass:
        useScaling = _swig_property(_adaptagrams.ColaOptions_useScaling_get, _adaptagrams.ColaOptions_useScaling_set)
    __swig_setmethods__["ccs"] = _adaptagrams.ColaOptions_ccs_set
    __swig_getmethods__["ccs"] = _adaptagrams.ColaOptions_ccs_get
    if _newclass:
        ccs = _swig_property(_adaptagrams.ColaOptions_ccs_get, _adaptagrams.ColaOptions_ccs_set)
    __swig_setmethods__["nodeClusters"] = _adaptagrams.ColaOptions_nodeClusters_set
    __swig_getmethods__["nodeClusters"] = _adaptagrams.ColaOptions_nodeClusters_get
    if _newclass:
        nodeClusters = _swig_property(_adaptagrams.ColaOptions_nodeClusters_get, _adaptagrams.ColaOptions_nodeClusters_set)
    __swig_setmethods__["eLengths"] = _adaptagrams.ColaOptions_eLengths_set
    __swig_getmethods__["eLengths"] = _adaptagrams.ColaOptions_eLengths_get
    if _newclass:
        eLengths = _swig_property(_adaptagrams.ColaOptions_eLengths_get, _adaptagrams.ColaOptions_eLengths_set)
    __swig_setmethods__["doneTest"] = _adaptagrams.ColaOptions_doneTest_set
    __swig_getmethods__["doneTest"] = _adaptagrams.ColaOptions_doneTest_get
    if _newclass:
        doneTest = _swig_property(_adaptagrams.ColaOptions_doneTest_get, _adaptagrams.ColaOptions_doneTest_set)
    __swig_setmethods__["preIteration"] = _adaptagrams.ColaOptions_preIteration_set
    __swig_getmethods__["preIteration"] = _adaptagrams.ColaOptions_preIteration_get
    if _newclass:
        preIteration = _swig_property(_adaptagrams.ColaOptions_preIteration_get, _adaptagrams.ColaOptions_preIteration_set)
    __swig_setmethods__["logger"] = _adaptagrams.ColaOptions_logger_set
    __swig_getmethods__["logger"] = _adaptagrams.ColaOptions_logger_get
    if _newclass:
        logger = _swig_property(_adaptagrams.ColaOptions_logger_get, _adaptagrams.ColaOptions_logger_set)

    def __init__(self):
        this = _adaptagrams.new_ColaOptions()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _adaptagrams.delete_ColaOptions
    __del__ = lambda self: None
ColaOptions_swigregister = _adaptagrams.ColaOptions_swigregister
ColaOptions_swigregister(ColaOptions)

class ColaGraphRep(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ColaGraphRep, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ColaGraphRep, name)
    __repr__ = _swig_repr
    __swig_setmethods__["rs"] = _adaptagrams.ColaGraphRep_rs_set
    __swig_getmethods__["rs"] = _adaptagrams.ColaGraphRep_rs_get
    if _newclass:
        rs = _swig_property(_adaptagrams.ColaGraphRep_rs_get, _adaptagrams.ColaGraphRep_rs_set)
    __swig_setmethods__["es"] = _adaptagrams.ColaGraphRep_es_set
    __swig_getmethods__["es"] = _adaptagrams.ColaGraphRep_es_get
    if _newclass:
        es = _swig_property(_adaptagrams.ColaGraphRep_es_get, _adaptagrams.ColaGraphRep_es_set)
    __swig_setmethods__["rc"] = _adaptagrams.ColaGraphRep_rc_set
    __swig_getmethods__["rc"] = _adaptagrams.ColaGraphRep_rc_get
    if _newclass:
        rc = _swig_property(_adaptagrams.ColaGraphRep_rc_get, _adaptagrams.ColaGraphRep_rc_set)
    __swig_setmethods__["id2ix"] = _adaptagrams.ColaGraphRep_id2ix_set
    __swig_getmethods__["id2ix"] = _adaptagrams.ColaGraphRep_id2ix_get
    if _newclass:
        id2ix = _swig_property(_adaptagrams.ColaGraphRep_id2ix_get, _adaptagrams.ColaGraphRep_id2ix_set)
    __swig_setmethods__["ix2id"] = _adaptagrams.ColaGraphRep_ix2id_set
    __swig_getmethods__["ix2id"] = _adaptagrams.ColaGraphRep_ix2id_get
    if _newclass:
        ix2id = _swig_property(_adaptagrams.ColaGraphRep_ix2id_get, _adaptagrams.ColaGraphRep_ix2id_set)

    def __init__(self):
        this = _adaptagrams.new_ColaGraphRep()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _adaptagrams.delete_ColaGraphRep
    __del__ = lambda self: None
ColaGraphRep_swigregister = _adaptagrams.ColaGraphRep_swigregister
ColaGraphRep_swigregister(ColaGraphRep)

class NodeIdCmp(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, NodeIdCmp, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, NodeIdCmp, name)
    __repr__ = _swig_repr

    def __call__(self, *args):
        return _adaptagrams.NodeIdCmp___call__(self, *args)

    def __init__(self):
        this = _adaptagrams.new_NodeIdCmp()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _adaptagrams.delete_NodeIdCmp
    __del__ = lambda self: None
NodeIdCmp_swigregister = _adaptagrams.NodeIdCmp_swigregister
NodeIdCmp_swigregister(NodeIdCmp)

class Graph(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Graph, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Graph, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _adaptagrams.new_Graph(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _adaptagrams.delete_Graph
    __del__ = lambda self: None

    def getMaxDegree(self):
        return _adaptagrams.Graph_getMaxDegree(self)

    def addNode(self, *args):
        return _adaptagrams.Graph_addNode(self, *args)

    def addEdge(self, *args):
        return _adaptagrams.Graph_addEdge(self, *args)

    def hasNode(self, id):
        return _adaptagrams.Graph_hasNode(self, id)

    def hasEdge(self, id):
        return _adaptagrams.Graph_hasEdge(self, id)

    def severEdge(self, edge):
        return _adaptagrams.Graph_severEdge(self, edge)

    def severNode(self, node):
        return _adaptagrams.Graph_severNode(self, node)

    def severNodeNotingNeighbours(self, node):
        return _adaptagrams.Graph_severNodeNotingNeighbours(self, node)

    def removeNode(self, node):
        return _adaptagrams.Graph_removeNode(self, node)

    def removeNodes(self, nodes):
        return _adaptagrams.Graph_removeNodes(self, nodes)

    def severAndRemoveNode(self, *args):
        return _adaptagrams.Graph_severAndRemoveNode(self, *args)

    def cloneNode(self, id):
        return _adaptagrams.Graph_cloneNode(self, id)

    def getNode(self, id):
        return _adaptagrams.Graph_getNode(self, id)

    def getNodeLookup(self):
        return _adaptagrams.Graph_getNodeLookup(self)

    def getNodeLookupWithIgnore(self, *args):
        return _adaptagrams.Graph_getNodeLookupWithIgnore(self, *args)

    def getEdgeLookup(self):
        return _adaptagrams.Graph_getEdgeLookup(self)

    def getNumNodes(self):
        return _adaptagrams.Graph_getNumNodes(self)

    def getNumEdges(self):
        return _adaptagrams.Graph_getNumEdges(self)

    def isEmpty(self):
        return _adaptagrams.Graph_isEmpty(self)

    def isTree(self):
        return _adaptagrams.Graph_isTree(self)

    def computeAvgNodeDim(self):
        return _adaptagrams.Graph_computeAvgNodeDim(self)

    def getIEL(self):
        return _adaptagrams.Graph_getIEL(self)

    def recomputeIEL(self):
        return _adaptagrams.Graph_recomputeIEL(self)

    def getBoundingBox(self, *args):
        return _adaptagrams.Graph_getBoundingBox(self, *args)

    def getConnComps(self):
        return _adaptagrams.Graph_getConnComps(self)

    def getChainsAndCycles(self, chains, cycles):
        return _adaptagrams.Graph_getChainsAndCycles(self, chains, cycles)

    def writeTglf(self, useExternalIds=False):
        return _adaptagrams.Graph_writeTglf(self, useExternalIds)

    def writeSvg(self, useExternalIds=False):
        return _adaptagrams.Graph_writeSvg(self, useExternalIds)

    def writeId2Ix(self):
        return _adaptagrams.Graph_writeId2Ix(self)

    def writeIx2Id(self):
        return _adaptagrams.Graph_writeIx2Id(self)

    def rotate90cw(self, opts=None):
        return _adaptagrams.Graph_rotate90cw(self, opts)

    def rotate90acw(self, opts=None):
        return _adaptagrams.Graph_rotate90acw(self, opts)

    def rotate180(self):
        return _adaptagrams.Graph_rotate180(self)

    def translate(self, dx, dy):
        return _adaptagrams.Graph_translate(self, dx, dy)

    def putInBasePosition(self):
        return _adaptagrams.Graph_putInBasePosition(self)

    def hasSameLayoutAs(self, other, tol=0.001, idMap=None):
        return _adaptagrams.Graph_hasSameLayoutAs(self, other, tol, idMap)

    def getEdgeBySrcIdTgtIdLookup(self):
        return _adaptagrams.Graph_getEdgeBySrcIdTgtIdLookup(self)

    def destress(self, *args):
        return _adaptagrams.Graph_destress(self, *args)

    def solidifyAlignedEdges(self, dim, opts):
        return _adaptagrams.Graph_solidifyAlignedEdges(self, dim, opts)

    def makeFeasible(self, opts):
        return _adaptagrams.Graph_makeFeasible(self, opts)

    def project(self, opts, dim, accept=0):
        return _adaptagrams.Graph_project(self, opts, dim, accept)

    def projectOntoSepCo(self, opts, sepco, accept=0):
        return _adaptagrams.Graph_projectOntoSepCo(self, opts, sepco, accept)

    def applyProjSeq(self, opts, ps, accept=0):
        return _adaptagrams.Graph_applyProjSeq(self, opts, ps, accept)

    def updateNodesFromRects(self, xAxis=True, yAxis=True):
        return _adaptagrams.Graph_updateNodesFromRects(self, xAxis, yAxis)

    def updateColaGraphRep(self):
        return _adaptagrams.Graph_updateColaGraphRep(self)

    def buildRootCluster(self, opts):
        return _adaptagrams.Graph_buildRootCluster(self, opts)

    def getColaGraphRep(self):
        return _adaptagrams.Graph_getColaGraphRep(self)

    def getSepMatrix(self):
        return _adaptagrams.Graph_getSepMatrix(self)

    def buildUniqueBendPoints(self):
        return _adaptagrams.Graph_buildUniqueBendPoints(self)

    def pushNodePositions(self):
        return _adaptagrams.Graph_pushNodePositions(self)

    def popNodePositions(self):
        return _adaptagrams.Graph_popNodePositions(self)

    def setEdgeThickness(self, t):
        return _adaptagrams.Graph_setEdgeThickness(self, t)

    def getEdgeThickness(self):
        return _adaptagrams.Graph_getEdgeThickness(self)

    def padAllNodes(self, dw, dh):
        return _adaptagrams.Graph_padAllNodes(self, dw, dh)

    def setPosesInCorrespNodes(self, H):
        return _adaptagrams.Graph_setPosesInCorrespNodes(self, H)

    def setRoutesInCorrespEdges(self, H, directed=False):
        return _adaptagrams.Graph_setRoutesInCorrespEdges(self, H, directed)

    def route(self, routingType):
        return _adaptagrams.Graph_route(self, routingType)

    def clearAllRoutes(self):
        return _adaptagrams.Graph_clearAllRoutes(self)

    def buildRoutes(self):
        return _adaptagrams.Graph_buildRoutes(self)

    def addBendlessSubnetworkToRoutingAdapter(self, ra):
        return _adaptagrams.Graph_addBendlessSubnetworkToRoutingAdapter(self, ra)

    def clearAllConstraints(self):
        return _adaptagrams.Graph_clearAllConstraints(self)

    def setCorrespondingConstraints(self, H):
        return _adaptagrams.Graph_setCorrespondingConstraints(self, H)
    __swig_setmethods__["m_debugOutputPath"] = _adaptagrams.Graph_m_debugOutputPath_set
    __swig_getmethods__["m_debugOutputPath"] = _adaptagrams.Graph_m_debugOutputPath_get
    if _newclass:
        m_debugOutputPath = _swig_property(_adaptagrams.Graph_m_debugOutputPath_get, _adaptagrams.Graph_m_debugOutputPath_set)
    __swig_setmethods__["m_projectionDebugLevel"] = _adaptagrams.Graph_m_projectionDebugLevel_set
    __swig_getmethods__["m_projectionDebugLevel"] = _adaptagrams.Graph_m_projectionDebugLevel_get
    if _newclass:
        m_projectionDebugLevel = _swig_property(_adaptagrams.Graph_m_projectionDebugLevel_get, _adaptagrams.Graph_m_projectionDebugLevel_set)
Graph_swigregister = _adaptagrams.Graph_swigregister
Graph_swigregister(Graph)

class DialectNode(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DialectNode, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DialectNode, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    if _newclass:
        allocate = staticmethod(_adaptagrams.DialectNode_allocate)
    else:
        allocate = _adaptagrams.DialectNode_allocate

    def makeGhost(self):
        return _adaptagrams.DialectNode_makeGhost(self)
    __swig_destroy__ = _adaptagrams.delete_DialectNode
    __del__ = lambda self: None

    def id(self):
        return _adaptagrams.DialectNode_id(self)

    def getDegree(self):
        return _adaptagrams.DialectNode_getDegree(self)

    def setGraph(self, graph):
        return _adaptagrams.DialectNode_setGraph(self, graph)

    def getGraph(self):
        return _adaptagrams.DialectNode_getGraph(self)

    def addEdge(self, edge):
        return _adaptagrams.DialectNode_addEdge(self, edge)

    def removeEdge(self, edge):
        return _adaptagrams.DialectNode_removeEdge(self, edge)

    def getEdgeLookup(self):
        return _adaptagrams.DialectNode_getEdgeLookup(self)

    def getCopyOfEdgeLookup(self):
        return _adaptagrams.DialectNode_getCopyOfEdgeLookup(self)

    def copyGeometry(self, other):
        return _adaptagrams.DialectNode_copyGeometry(self, other)

    def copyOtherGhostProperties(self, other):
        return _adaptagrams.DialectNode_copyOtherGhostProperties(self, other)

    def getHalfDimensions(self):
        return _adaptagrams.DialectNode_getHalfDimensions(self)

    def getDimensions(self):
        return _adaptagrams.DialectNode_getDimensions(self)

    def getBoundingBox(self):
        return _adaptagrams.DialectNode_getBoundingBox(self)

    def getBoundaryCompassPt(self, dir):
        return _adaptagrams.DialectNode_getBoundaryCompassPt(self, dir)

    def setCentre(self, cx, cy):
        return _adaptagrams.DialectNode_setCentre(self, cx, cy)

    def translate(self, dx, dy):
        return _adaptagrams.DialectNode_translate(self, dx, dy)

    def applyPlaneMap(self, map):
        return _adaptagrams.DialectNode_applyPlaneMap(self, map)

    def getCentre(self):
        return _adaptagrams.DialectNode_getCentre(self)

    def setExternalId(self, id):
        return _adaptagrams.DialectNode_setExternalId(self, id)

    def getExternalId(self):
        return _adaptagrams.DialectNode_getExternalId(self)

    def getNeighbours(self):
        return _adaptagrams.DialectNode_getNeighbours(self)

    def getNeighboursCwCyclic(self):
        return _adaptagrams.DialectNode_getNeighboursCwCyclic(self)

    def getChildren(self):
        return _adaptagrams.DialectNode_getChildren(self)

    def setDims(self, w, h):
        return _adaptagrams.DialectNode_setDims(self, w, h)

    def setBoundingBox(self, x, X, y, Y):
        return _adaptagrams.DialectNode_setBoundingBox(self, x, X, y, Y)

    def addPadding(self, dw, dh):
        return _adaptagrams.DialectNode_addPadding(self, dw, dh)

    def updatePosnFromRect(self, r):
        return _adaptagrams.DialectNode_updatePosnFromRect(self, r)

    def updateXCoordFromRect(self, r):
        return _adaptagrams.DialectNode_updateXCoordFromRect(self, r)

    def updateYCoordFromRect(self, r):
        return _adaptagrams.DialectNode_updateYCoordFromRect(self, r)

    def makeLibavoidPolygon(self):
        return _adaptagrams.DialectNode_makeLibavoidPolygon(self)

    def isRoot(self):
        return _adaptagrams.DialectNode_isRoot(self)

    def setIsRoot(self, isRoot):
        return _adaptagrams.DialectNode_setIsRoot(self, isRoot)

    def liesOppositeSegment(self, seg, openInterval=False):
        return _adaptagrams.DialectNode_liesOppositeSegment(self, seg, openInterval)

    def writeSvg(self, useExternalId=False):
        return _adaptagrams.DialectNode_writeSvg(self, useExternalId)
DialectNode_swigregister = _adaptagrams.DialectNode_swigregister
DialectNode_swigregister(DialectNode)

def DialectNode_allocate(*args):
    return _adaptagrams.DialectNode_allocate(*args)
DialectNode_allocate = _adaptagrams.DialectNode_allocate

class GhostNode(DialectNode):
    __swig_setmethods__ = {}
    for _s in [DialectNode]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GhostNode, name, value)
    __swig_getmethods__ = {}
    for _s in [DialectNode]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GhostNode, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    if _newclass:
        allocate = staticmethod(_adaptagrams.GhostNode_allocate)
    else:
        allocate = _adaptagrams.GhostNode_allocate

    def id(self):
        return _adaptagrams.GhostNode_id(self)

    def trueID(self):
        return _adaptagrams.GhostNode_trueID(self)

    def getChildren(self):
        return _adaptagrams.GhostNode_getChildren(self)

    def setMasquerade(self, doMasquerade):
        return _adaptagrams.GhostNode_setMasquerade(self, doMasquerade)
    __swig_destroy__ = _adaptagrams.delete_GhostNode
    __del__ = lambda self: None
GhostNode_swigregister = _adaptagrams.GhostNode_swigregister
GhostNode_swigregister(GhostNode)

def GhostNode_allocate(node):
    return _adaptagrams.GhostNode_allocate(node)
GhostNode_allocate = _adaptagrams.GhostNode_allocate

class DialectEdge(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DialectEdge, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DialectEdge, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    if _newclass:
        allocate = staticmethod(_adaptagrams.DialectEdge_allocate)
    else:
        allocate = _adaptagrams.DialectEdge_allocate
    __swig_destroy__ = _adaptagrams.delete_DialectEdge
    __del__ = lambda self: None

    def id(self):
        return _adaptagrams.DialectEdge_id(self)

    def getOtherEnd(self, end1):
        return _adaptagrams.DialectEdge_getOtherEnd(self, end1)

    def getSourceEnd(self):
        return _adaptagrams.DialectEdge_getSourceEnd(self)

    def getTargetEnd(self):
        return _adaptagrams.DialectEdge_getTargetEnd(self)

    def getEndIds(self):
        return _adaptagrams.DialectEdge_getEndIds(self)

    def setGraph(self, graph):
        return _adaptagrams.DialectEdge_setGraph(self, graph)

    def sever(self):
        return _adaptagrams.DialectEdge_sever(self)

    def getBoundingBox(self):
        return _adaptagrams.DialectEdge_getBoundingBox(self)

    def addRoutePoint(self, x, y):
        return _adaptagrams.DialectEdge_addRoutePoint(self, x, y)

    def setRoute(self, route):
        return _adaptagrams.DialectEdge_setRoute(self, route)

    def getRoute(self):
        return _adaptagrams.DialectEdge_getRoute(self)

    def getRoutePoints(self):
        return _adaptagrams.DialectEdge_getRoutePoints(self)

    def writeRouteTglf(self):
        return _adaptagrams.DialectEdge_writeRouteTglf(self)

    def makeLibavoidConnEnds(self, *args):
        return _adaptagrams.DialectEdge_makeLibavoidConnEnds(self, *args)

    def setBendNodes(self, bends):
        return _adaptagrams.DialectEdge_setBendNodes(self, bends)

    def addBendNode(self, bn):
        return _adaptagrams.DialectEdge_addBendNode(self, bn)

    def getBendNodes(self):
        return _adaptagrams.DialectEdge_getBendNodes(self)

    def hasBendNodes(self):
        return _adaptagrams.DialectEdge_hasBendNodes(self)

    def rotate90cw(self):
        return _adaptagrams.DialectEdge_rotate90cw(self)

    def rotate90acw(self):
        return _adaptagrams.DialectEdge_rotate90acw(self)

    def rotate180(self):
        return _adaptagrams.DialectEdge_rotate180(self)

    def translate(self, dx, dy):
        return _adaptagrams.DialectEdge_translate(self, dx, dy)

    def clearRouteAndBends(self):
        return _adaptagrams.DialectEdge_clearRouteAndBends(self)

    def buildRouteFromBends(self):
        return _adaptagrams.DialectEdge_buildRouteFromBends(self)

    def writeSvg(self):
        return _adaptagrams.DialectEdge_writeSvg(self)

    def writePolylineConnectorData(self):
        return _adaptagrams.DialectEdge_writePolylineConnectorData(self)

    def writeRoundedOrthoConnectorData(self):
        return _adaptagrams.DialectEdge_writeRoundedOrthoConnectorData(self)
DialectEdge_swigregister = _adaptagrams.DialectEdge_swigregister
DialectEdge_swigregister(DialectEdge)

def DialectEdge_allocate(src, tgt):
    return _adaptagrams.DialectEdge_allocate(src, tgt)
DialectEdge_allocate = _adaptagrams.DialectEdge_allocate


def doHOLA(*args):
    return _adaptagrams.doHOLA(*args)
doHOLA = _adaptagrams.doHOLA

def buildGraphFromTglf(*args):
    return _adaptagrams.buildGraphFromTglf(*args)
buildGraphFromTglf = _adaptagrams.buildGraphFromTglf

def buildGraphFromTglfFile(filepath):
    return _adaptagrams.buildGraphFromTglfFile(filepath)
buildGraphFromTglfFile = _adaptagrams.buildGraphFromTglfFile

def writeStringToFile(s, filepath):
    return _adaptagrams.writeStringToFile(s, filepath)
writeStringToFile = _adaptagrams.writeStringToFile
AlignmentFlag_NONE = _adaptagrams.AlignmentFlag_NONE
AlignmentFlag_HALIGN = _adaptagrams.AlignmentFlag_HALIGN
AlignmentFlag_VALIGN = _adaptagrams.AlignmentFlag_VALIGN
AlignmentFlag_HINFEAS = _adaptagrams.AlignmentFlag_HINFEAS
AlignmentFlag_VINFEAS = _adaptagrams.AlignmentFlag_VINFEAS

def __and__(a, b):
    return _adaptagrams.__and__(a, b)
__and__ = _adaptagrams.__and__

def __ior__(a, b):
    return _adaptagrams.__ior__(a, b)
__ior__ = _adaptagrams.__ior__
class AlignmentTable(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AlignmentTable, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AlignmentTable, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _adaptagrams.new_AlignmentTable(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def areAligned(self, uid, vid, flag):
        return _adaptagrams.AlignmentTable_areAligned(self, uid, vid, flag)

    def addAlignment(self, uid, vid, flag):
        return _adaptagrams.AlignmentTable_addAlignment(self, uid, vid, flag)

    def addAlignments(self, nodes, matrix):
        return _adaptagrams.AlignmentTable_addAlignments(self, nodes, matrix)

    def getAlignedIds(self, uid, flag):
        return _adaptagrams.AlignmentTable_getAlignedIds(self, uid, flag)

    def noteInfeasibility(self, uid, vid, flag):
        return _adaptagrams.AlignmentTable_noteInfeasibility(self, uid, vid, flag)

    def isMarkedInfeasible(self, uid, vid, flag):
        return _adaptagrams.AlignmentTable_isMarkedInfeasible(self, uid, vid, flag)
    __swig_setmethods__["state"] = _adaptagrams.AlignmentTable_state_set
    __swig_getmethods__["state"] = _adaptagrams.AlignmentTable_state_get
    if _newclass:
        state = _swig_property(_adaptagrams.AlignmentTable_state_get, _adaptagrams.AlignmentTable_state_set)
    __swig_destroy__ = _adaptagrams.delete_AlignmentTable
    __del__ = lambda self: None
AlignmentTable_swigregister = _adaptagrams.AlignmentTable_swigregister
AlignmentTable_swigregister(AlignmentTable)


def manhattan(u, v):
    return _adaptagrams.manhattan(u, v)
manhattan = _adaptagrams.manhattan
class PotentialAlignment(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PotentialAlignment, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PotentialAlignment, name)
    __repr__ = _swig_repr

    def __init__(self, u, v, flag):
        this = _adaptagrams.new_PotentialAlignment(u, v, flag)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def remove(self):
        return _adaptagrams.PotentialAlignment_remove(self)

    def addToTable(self, table):
        return _adaptagrams.PotentialAlignment_addToTable(self, table)

    def noteInfeasibility(self, table):
        return _adaptagrams.PotentialAlignment_noteInfeasibility(self, table)

    def writeSepCo(self):
        return _adaptagrams.PotentialAlignment_writeSepCo(self)

    def addToGraph(self, G):
        return _adaptagrams.PotentialAlignment_addToGraph(self, G)
    __swig_setmethods__["u"] = _adaptagrams.PotentialAlignment_u_set
    __swig_getmethods__["u"] = _adaptagrams.PotentialAlignment_u_get
    if _newclass:
        u = _swig_property(_adaptagrams.PotentialAlignment_u_get, _adaptagrams.PotentialAlignment_u_set)
    __swig_setmethods__["v"] = _adaptagrams.PotentialAlignment_v_set
    __swig_getmethods__["v"] = _adaptagrams.PotentialAlignment_v_get
    if _newclass:
        v = _swig_property(_adaptagrams.PotentialAlignment_v_get, _adaptagrams.PotentialAlignment_v_set)
    __swig_setmethods__["flag"] = _adaptagrams.PotentialAlignment_flag_set
    __swig_getmethods__["flag"] = _adaptagrams.PotentialAlignment_flag_get
    if _newclass:
        flag = _swig_property(_adaptagrams.PotentialAlignment_flag_get, _adaptagrams.PotentialAlignment_flag_set)
    __swig_setmethods__["cost"] = _adaptagrams.PotentialAlignment_cost_set
    __swig_getmethods__["cost"] = _adaptagrams.PotentialAlignment_cost_get
    if _newclass:
        cost = _swig_property(_adaptagrams.PotentialAlignment_cost_get, _adaptagrams.PotentialAlignment_cost_set)
    __swig_setmethods__["removed"] = _adaptagrams.PotentialAlignment_removed_set
    __swig_getmethods__["removed"] = _adaptagrams.PotentialAlignment_removed_get
    if _newclass:
        removed = _swig_property(_adaptagrams.PotentialAlignment_removed_get, _adaptagrams.PotentialAlignment_removed_set)
    __swig_setmethods__["prev"] = _adaptagrams.PotentialAlignment_prev_set
    __swig_getmethods__["prev"] = _adaptagrams.PotentialAlignment_prev_get
    if _newclass:
        prev = _swig_property(_adaptagrams.PotentialAlignment_prev_get, _adaptagrams.PotentialAlignment_prev_set)
    __swig_setmethods__["next"] = _adaptagrams.PotentialAlignment_next_set
    __swig_getmethods__["next"] = _adaptagrams.PotentialAlignment_next_get
    if _newclass:
        next = _swig_property(_adaptagrams.PotentialAlignment_next_get, _adaptagrams.PotentialAlignment_next_set)
    __swig_destroy__ = _adaptagrams.delete_PotentialAlignment
    __del__ = lambda self: None
PotentialAlignment_swigregister = _adaptagrams.PotentialAlignment_swigregister
PotentialAlignment_swigregister(PotentialAlignment)


def doNearAlignments(graph, atab, ignore, opts, reattempt=False):
    return _adaptagrams.doNearAlignments(graph, atab, ignore, opts, reattempt)
doNearAlignments = _adaptagrams.doNearAlignments
class OrthoHubLayoutOptions(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OrthoHubLayoutOptions, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OrthoHubLayoutOptions, name)
    __repr__ = _swig_repr
    __swig_setmethods__["avoidFlatTriangles"] = _adaptagrams.OrthoHubLayoutOptions_avoidFlatTriangles_set
    __swig_getmethods__["avoidFlatTriangles"] = _adaptagrams.OrthoHubLayoutOptions_avoidFlatTriangles_get
    if _newclass:
        avoidFlatTriangles = _swig_property(_adaptagrams.OrthoHubLayoutOptions_avoidFlatTriangles_get, _adaptagrams.OrthoHubLayoutOptions_avoidFlatTriangles_set)
    __swig_setmethods__["includeLinks"] = _adaptagrams.OrthoHubLayoutOptions_includeLinks_set
    __swig_getmethods__["includeLinks"] = _adaptagrams.OrthoHubLayoutOptions_includeLinks_get
    if _newclass:
        includeLinks = _swig_property(_adaptagrams.OrthoHubLayoutOptions_includeLinks_get, _adaptagrams.OrthoHubLayoutOptions_includeLinks_set)

    def __init__(self):
        this = _adaptagrams.new_OrthoHubLayoutOptions()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _adaptagrams.delete_OrthoHubLayoutOptions
    __del__ = lambda self: None
OrthoHubLayoutOptions_swigregister = _adaptagrams.OrthoHubLayoutOptions_swigregister
OrthoHubLayoutOptions_swigregister(OrthoHubLayoutOptions)

class OrthoHubLayout(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OrthoHubLayout, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OrthoHubLayout, name)
    __repr__ = _swig_repr

    def __init__(self, G, opts):
        this = _adaptagrams.new_OrthoHubLayout(G, opts)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def layout(self, logger=None):
        return _adaptagrams.OrthoHubLayout_layout(self, logger)
    __swig_destroy__ = _adaptagrams.delete_OrthoHubLayout
    __del__ = lambda self: None
OrthoHubLayout_swigregister = _adaptagrams.OrthoHubLayout_swigregister
OrthoHubLayout_swigregister(OrthoHubLayout)

AspectRatioClass_NONE = _adaptagrams.AspectRatioClass_NONE
AspectRatioClass_PORTRAIT = _adaptagrams.AspectRatioClass_PORTRAIT
AspectRatioClass_LANDSCAPE = _adaptagrams.AspectRatioClass_LANDSCAPE
TreeRoutingType_STRICT = _adaptagrams.TreeRoutingType_STRICT
TreeRoutingType_CORE_ATTACHMENT = _adaptagrams.TreeRoutingType_CORE_ATTACHMENT
TreeRoutingType_MONOTONIC = _adaptagrams.TreeRoutingType_MONOTONIC
ExpansionEstimateMethod_SPACE = _adaptagrams.ExpansionEstimateMethod_SPACE
ExpansionEstimateMethod_CONSTRAINTS = _adaptagrams.ExpansionEstimateMethod_CONSTRAINTS
class HolaOpts(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HolaOpts, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HolaOpts, name)
    __repr__ = _swig_repr
    __swig_setmethods__["defaultTreeGrowthDir"] = _adaptagrams.HolaOpts_defaultTreeGrowthDir_set
    __swig_getmethods__["defaultTreeGrowthDir"] = _adaptagrams.HolaOpts_defaultTreeGrowthDir_get
    if _newclass:
        defaultTreeGrowthDir = _swig_property(_adaptagrams.HolaOpts_defaultTreeGrowthDir_get, _adaptagrams.HolaOpts_defaultTreeGrowthDir_set)
    __swig_setmethods__["treeLayoutScalar_nodeSep"] = _adaptagrams.HolaOpts_treeLayoutScalar_nodeSep_set
    __swig_getmethods__["treeLayoutScalar_nodeSep"] = _adaptagrams.HolaOpts_treeLayoutScalar_nodeSep_get
    if _newclass:
        treeLayoutScalar_nodeSep = _swig_property(_adaptagrams.HolaOpts_treeLayoutScalar_nodeSep_get, _adaptagrams.HolaOpts_treeLayoutScalar_nodeSep_set)
    __swig_setmethods__["treeLayoutScalar_rankSep"] = _adaptagrams.HolaOpts_treeLayoutScalar_rankSep_set
    __swig_getmethods__["treeLayoutScalar_rankSep"] = _adaptagrams.HolaOpts_treeLayoutScalar_rankSep_get
    if _newclass:
        treeLayoutScalar_rankSep = _swig_property(_adaptagrams.HolaOpts_treeLayoutScalar_rankSep_get, _adaptagrams.HolaOpts_treeLayoutScalar_rankSep_set)
    __swig_setmethods__["preferConvexTrees"] = _adaptagrams.HolaOpts_preferConvexTrees_set
    __swig_getmethods__["preferConvexTrees"] = _adaptagrams.HolaOpts_preferConvexTrees_get
    if _newclass:
        preferConvexTrees = _swig_property(_adaptagrams.HolaOpts_preferConvexTrees_get, _adaptagrams.HolaOpts_preferConvexTrees_set)
    __swig_setmethods__["peeledTreeRouting"] = _adaptagrams.HolaOpts_peeledTreeRouting_set
    __swig_getmethods__["peeledTreeRouting"] = _adaptagrams.HolaOpts_peeledTreeRouting_get
    if _newclass:
        peeledTreeRouting = _swig_property(_adaptagrams.HolaOpts_peeledTreeRouting_get, _adaptagrams.HolaOpts_peeledTreeRouting_set)
    __swig_setmethods__["wholeTreeRouting"] = _adaptagrams.HolaOpts_wholeTreeRouting_set
    __swig_getmethods__["wholeTreeRouting"] = _adaptagrams.HolaOpts_wholeTreeRouting_get
    if _newclass:
        wholeTreeRouting = _swig_property(_adaptagrams.HolaOpts_wholeTreeRouting_get, _adaptagrams.HolaOpts_wholeTreeRouting_set)
    __swig_setmethods__["orthoHubAvoidFlatTriangles"] = _adaptagrams.HolaOpts_orthoHubAvoidFlatTriangles_set
    __swig_getmethods__["orthoHubAvoidFlatTriangles"] = _adaptagrams.HolaOpts_orthoHubAvoidFlatTriangles_get
    if _newclass:
        orthoHubAvoidFlatTriangles = _swig_property(_adaptagrams.HolaOpts_orthoHubAvoidFlatTriangles_get, _adaptagrams.HolaOpts_orthoHubAvoidFlatTriangles_set)
    __swig_setmethods__["useACAforLinks"] = _adaptagrams.HolaOpts_useACAforLinks_set
    __swig_getmethods__["useACAforLinks"] = _adaptagrams.HolaOpts_useACAforLinks_get
    if _newclass:
        useACAforLinks = _swig_property(_adaptagrams.HolaOpts_useACAforLinks_get, _adaptagrams.HolaOpts_useACAforLinks_set)
    __swig_setmethods__["routingScalar_crossingPenalty"] = _adaptagrams.HolaOpts_routingScalar_crossingPenalty_set
    __swig_getmethods__["routingScalar_crossingPenalty"] = _adaptagrams.HolaOpts_routingScalar_crossingPenalty_get
    if _newclass:
        routingScalar_crossingPenalty = _swig_property(_adaptagrams.HolaOpts_routingScalar_crossingPenalty_get, _adaptagrams.HolaOpts_routingScalar_crossingPenalty_set)
    __swig_setmethods__["routingScalar_segmentPenalty"] = _adaptagrams.HolaOpts_routingScalar_segmentPenalty_set
    __swig_getmethods__["routingScalar_segmentPenalty"] = _adaptagrams.HolaOpts_routingScalar_segmentPenalty_get
    if _newclass:
        routingScalar_segmentPenalty = _swig_property(_adaptagrams.HolaOpts_routingScalar_segmentPenalty_get, _adaptagrams.HolaOpts_routingScalar_segmentPenalty_set)
    __swig_setmethods__["treePlacement_favourCardinal"] = _adaptagrams.HolaOpts_treePlacement_favourCardinal_set
    __swig_getmethods__["treePlacement_favourCardinal"] = _adaptagrams.HolaOpts_treePlacement_favourCardinal_get
    if _newclass:
        treePlacement_favourCardinal = _swig_property(_adaptagrams.HolaOpts_treePlacement_favourCardinal_get, _adaptagrams.HolaOpts_treePlacement_favourCardinal_set)
    __swig_setmethods__["treePlacement_favourExternal"] = _adaptagrams.HolaOpts_treePlacement_favourExternal_set
    __swig_getmethods__["treePlacement_favourExternal"] = _adaptagrams.HolaOpts_treePlacement_favourExternal_get
    if _newclass:
        treePlacement_favourExternal = _swig_property(_adaptagrams.HolaOpts_treePlacement_favourExternal_get, _adaptagrams.HolaOpts_treePlacement_favourExternal_set)
    __swig_setmethods__["treePlacement_favourIsolation"] = _adaptagrams.HolaOpts_treePlacement_favourIsolation_set
    __swig_getmethods__["treePlacement_favourIsolation"] = _adaptagrams.HolaOpts_treePlacement_favourIsolation_get
    if _newclass:
        treePlacement_favourIsolation = _swig_property(_adaptagrams.HolaOpts_treePlacement_favourIsolation_get, _adaptagrams.HolaOpts_treePlacement_favourIsolation_set)
    __swig_setmethods__["expansion_doCostlierDimensionFirst"] = _adaptagrams.HolaOpts_expansion_doCostlierDimensionFirst_set
    __swig_getmethods__["expansion_doCostlierDimensionFirst"] = _adaptagrams.HolaOpts_expansion_doCostlierDimensionFirst_get
    if _newclass:
        expansion_doCostlierDimensionFirst = _swig_property(_adaptagrams.HolaOpts_expansion_doCostlierDimensionFirst_get, _adaptagrams.HolaOpts_expansion_doCostlierDimensionFirst_set)
    __swig_setmethods__["expansion_estimateMethod"] = _adaptagrams.HolaOpts_expansion_estimateMethod_set
    __swig_getmethods__["expansion_estimateMethod"] = _adaptagrams.HolaOpts_expansion_estimateMethod_get
    if _newclass:
        expansion_estimateMethod = _swig_property(_adaptagrams.HolaOpts_expansion_estimateMethod_get, _adaptagrams.HolaOpts_expansion_estimateMethod_set)
    __swig_setmethods__["do_near_align"] = _adaptagrams.HolaOpts_do_near_align_set
    __swig_getmethods__["do_near_align"] = _adaptagrams.HolaOpts_do_near_align_get
    if _newclass:
        do_near_align = _swig_property(_adaptagrams.HolaOpts_do_near_align_get, _adaptagrams.HolaOpts_do_near_align_set)
    __swig_setmethods__["align_reps"] = _adaptagrams.HolaOpts_align_reps_set
    __swig_getmethods__["align_reps"] = _adaptagrams.HolaOpts_align_reps_get
    if _newclass:
        align_reps = _swig_property(_adaptagrams.HolaOpts_align_reps_get, _adaptagrams.HolaOpts_align_reps_set)
    __swig_setmethods__["nearAlignScalar_kinkWidth"] = _adaptagrams.HolaOpts_nearAlignScalar_kinkWidth_set
    __swig_getmethods__["nearAlignScalar_kinkWidth"] = _adaptagrams.HolaOpts_nearAlignScalar_kinkWidth_get
    if _newclass:
        nearAlignScalar_kinkWidth = _swig_property(_adaptagrams.HolaOpts_nearAlignScalar_kinkWidth_get, _adaptagrams.HolaOpts_nearAlignScalar_kinkWidth_set)
    __swig_setmethods__["nearAlignScalar_scope"] = _adaptagrams.HolaOpts_nearAlignScalar_scope_set
    __swig_getmethods__["nearAlignScalar_scope"] = _adaptagrams.HolaOpts_nearAlignScalar_scope_get
    if _newclass:
        nearAlignScalar_scope = _swig_property(_adaptagrams.HolaOpts_nearAlignScalar_scope_get, _adaptagrams.HolaOpts_nearAlignScalar_scope_set)
    __swig_setmethods__["nodePaddingScalar"] = _adaptagrams.HolaOpts_nodePaddingScalar_set
    __swig_getmethods__["nodePaddingScalar"] = _adaptagrams.HolaOpts_nodePaddingScalar_get
    if _newclass:
        nodePaddingScalar = _swig_property(_adaptagrams.HolaOpts_nodePaddingScalar_get, _adaptagrams.HolaOpts_nodePaddingScalar_set)
    __swig_setmethods__["preferredAspectRatio"] = _adaptagrams.HolaOpts_preferredAspectRatio_set
    __swig_getmethods__["preferredAspectRatio"] = _adaptagrams.HolaOpts_preferredAspectRatio_get
    if _newclass:
        preferredAspectRatio = _swig_property(_adaptagrams.HolaOpts_preferredAspectRatio_get, _adaptagrams.HolaOpts_preferredAspectRatio_set)
    __swig_setmethods__["preferredTreeGrowthDir"] = _adaptagrams.HolaOpts_preferredTreeGrowthDir_set
    __swig_getmethods__["preferredTreeGrowthDir"] = _adaptagrams.HolaOpts_preferredTreeGrowthDir_get
    if _newclass:
        preferredTreeGrowthDir = _swig_property(_adaptagrams.HolaOpts_preferredTreeGrowthDir_get, _adaptagrams.HolaOpts_preferredTreeGrowthDir_set)
    __swig_setmethods__["putUlcAtOrigin"] = _adaptagrams.HolaOpts_putUlcAtOrigin_set
    __swig_getmethods__["putUlcAtOrigin"] = _adaptagrams.HolaOpts_putUlcAtOrigin_get
    if _newclass:
        putUlcAtOrigin = _swig_property(_adaptagrams.HolaOpts_putUlcAtOrigin_get, _adaptagrams.HolaOpts_putUlcAtOrigin_set)

    def __init__(self):
        this = _adaptagrams.new_HolaOpts()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _adaptagrams.delete_HolaOpts
    __del__ = lambda self: None
HolaOpts_swigregister = _adaptagrams.HolaOpts_swigregister
HolaOpts_swigregister(HolaOpts)

CompassDir_EAST = _adaptagrams.CompassDir_EAST
CompassDir_SOUTH = _adaptagrams.CompassDir_SOUTH
CompassDir_WEST = _adaptagrams.CompassDir_WEST
CompassDir_NORTH = _adaptagrams.CompassDir_NORTH
CompassDir_SE = _adaptagrams.CompassDir_SE
CompassDir_SW = _adaptagrams.CompassDir_SW
CompassDir_NW = _adaptagrams.CompassDir_NW
CompassDir_NE = _adaptagrams.CompassDir_NE
CardinalDir_EAST = _adaptagrams.CardinalDir_EAST
CardinalDir_SOUTH = _adaptagrams.CardinalDir_SOUTH
CardinalDir_WEST = _adaptagrams.CardinalDir_WEST
CardinalDir_NORTH = _adaptagrams.CardinalDir_NORTH
class Compass(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Compass, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Compass, name)
    __repr__ = _swig_repr
    if _newclass:
        isVertical = staticmethod(_adaptagrams.Compass_isVertical)
    else:
        isVertical = _adaptagrams.Compass_isVertical
    if _newclass:
        isHorizontal = staticmethod(_adaptagrams.Compass_isHorizontal)
    else:
        isHorizontal = _adaptagrams.Compass_isHorizontal
    if _newclass:
        isVerticalCard = staticmethod(_adaptagrams.Compass_isVerticalCard)
    else:
        isVerticalCard = _adaptagrams.Compass_isVerticalCard
    if _newclass:
        isHorizontalCard = staticmethod(_adaptagrams.Compass_isHorizontalCard)
    else:
        isHorizontalCard = _adaptagrams.Compass_isHorizontalCard
    if _newclass:
        isInDim = staticmethod(_adaptagrams.Compass_isInDim)
    else:
        isInDim = _adaptagrams.Compass_isInDim
    if _newclass:
        isIncreasing = staticmethod(_adaptagrams.Compass_isIncreasing)
    else:
        isIncreasing = _adaptagrams.Compass_isIncreasing
    if _newclass:
        isDecreasing = staticmethod(_adaptagrams.Compass_isDecreasing)
    else:
        isDecreasing = _adaptagrams.Compass_isDecreasing
    if _newclass:
        isIncreasingCard = staticmethod(_adaptagrams.Compass_isIncreasingCard)
    else:
        isIncreasingCard = _adaptagrams.Compass_isIncreasingCard
    if _newclass:
        isDecreasingCard = staticmethod(_adaptagrams.Compass_isDecreasingCard)
    else:
        isDecreasingCard = _adaptagrams.Compass_isDecreasingCard
    if _newclass:
        sameDimension = staticmethod(_adaptagrams.Compass_sameDimension)
    else:
        sameDimension = _adaptagrams.Compass_sameDimension
    if _newclass:
        arePerpendicular = staticmethod(_adaptagrams.Compass_arePerpendicular)
    else:
        arePerpendicular = _adaptagrams.Compass_arePerpendicular
    if _newclass:
        compassDirection = staticmethod(_adaptagrams.Compass_compassDirection)
    else:
        compassDirection = _adaptagrams.Compass_compassDirection
    if _newclass:
        cardinalDirection = staticmethod(_adaptagrams.Compass_cardinalDirection)
    else:
        cardinalDirection = _adaptagrams.Compass_cardinalDirection
    if _newclass:
        isCardinal = staticmethod(_adaptagrams.Compass_isCardinal)
    else:
        isCardinal = _adaptagrams.Compass_isCardinal
    if _newclass:
        cardRotateCw90 = staticmethod(_adaptagrams.Compass_cardRotateCw90)
    else:
        cardRotateCw90 = _adaptagrams.Compass_cardRotateCw90
    if _newclass:
        cardRotateAcw90 = staticmethod(_adaptagrams.Compass_cardRotateAcw90)
    else:
        cardRotateAcw90 = _adaptagrams.Compass_cardRotateAcw90
    if _newclass:
        cardFlip = staticmethod(_adaptagrams.Compass_cardFlip)
    else:
        cardFlip = _adaptagrams.Compass_cardFlip
    if _newclass:
        dirToString = staticmethod(_adaptagrams.Compass_dirToString)
    else:
        dirToString = _adaptagrams.Compass_dirToString
    if _newclass:
        cardToString = staticmethod(_adaptagrams.Compass_cardToString)
    else:
        cardToString = _adaptagrams.Compass_cardToString
    if _newclass:
        cardinalComponents = staticmethod(_adaptagrams.Compass_cardinalComponents)
    else:
        cardinalComponents = _adaptagrams.Compass_cardinalComponents
    if _newclass:
        getRotationFunction = staticmethod(_adaptagrams.Compass_getRotationFunction)
    else:
        getRotationFunction = _adaptagrams.Compass_getRotationFunction
    if _newclass:
        getInplaceRotationFunction = staticmethod(_adaptagrams.Compass_getInplaceRotationFunction)
    else:
        getInplaceRotationFunction = _adaptagrams.Compass_getInplaceRotationFunction
    if _newclass:
        vectorSigns = staticmethod(_adaptagrams.Compass_vectorSigns)
    else:
        vectorSigns = _adaptagrams.Compass_vectorSigns

    def __init__(self):
        this = _adaptagrams.new_Compass()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _adaptagrams.delete_Compass
    __del__ = lambda self: None
Compass_swigregister = _adaptagrams.Compass_swigregister
Compass_swigregister(Compass)

def Compass_isVertical(d):
    return _adaptagrams.Compass_isVertical(d)
Compass_isVertical = _adaptagrams.Compass_isVertical

def Compass_isHorizontal(d):
    return _adaptagrams.Compass_isHorizontal(d)
Compass_isHorizontal = _adaptagrams.Compass_isHorizontal

def Compass_isVerticalCard(d):
    return _adaptagrams.Compass_isVerticalCard(d)
Compass_isVerticalCard = _adaptagrams.Compass_isVerticalCard

def Compass_isHorizontalCard(d):
    return _adaptagrams.Compass_isHorizontalCard(d)
Compass_isHorizontalCard = _adaptagrams.Compass_isHorizontalCard

def Compass_isInDim(d, dim):
    return _adaptagrams.Compass_isInDim(d, dim)
Compass_isInDim = _adaptagrams.Compass_isInDim

def Compass_isIncreasing(d):
    return _adaptagrams.Compass_isIncreasing(d)
Compass_isIncreasing = _adaptagrams.Compass_isIncreasing

def Compass_isDecreasing(d):
    return _adaptagrams.Compass_isDecreasing(d)
Compass_isDecreasing = _adaptagrams.Compass_isDecreasing

def Compass_isIncreasingCard(d):
    return _adaptagrams.Compass_isIncreasingCard(d)
Compass_isIncreasingCard = _adaptagrams.Compass_isIncreasingCard

def Compass_isDecreasingCard(d):
    return _adaptagrams.Compass_isDecreasingCard(d)
Compass_isDecreasingCard = _adaptagrams.Compass_isDecreasingCard

def Compass_sameDimension(d0, d1):
    return _adaptagrams.Compass_sameDimension(d0, d1)
Compass_sameDimension = _adaptagrams.Compass_sameDimension

def Compass_arePerpendicular(d0, d1):
    return _adaptagrams.Compass_arePerpendicular(d0, d1)
Compass_arePerpendicular = _adaptagrams.Compass_arePerpendicular

def Compass_compassDirection(*args):
    return _adaptagrams.Compass_compassDirection(*args)
Compass_compassDirection = _adaptagrams.Compass_compassDirection

def Compass_cardinalDirection(*args):
    return _adaptagrams.Compass_cardinalDirection(*args)
Compass_cardinalDirection = _adaptagrams.Compass_cardinalDirection

def Compass_isCardinal(d):
    return _adaptagrams.Compass_isCardinal(d)
Compass_isCardinal = _adaptagrams.Compass_isCardinal

def Compass_cardRotateCw90(d):
    return _adaptagrams.Compass_cardRotateCw90(d)
Compass_cardRotateCw90 = _adaptagrams.Compass_cardRotateCw90

def Compass_cardRotateAcw90(d):
    return _adaptagrams.Compass_cardRotateAcw90(d)
Compass_cardRotateAcw90 = _adaptagrams.Compass_cardRotateAcw90

def Compass_cardFlip(d):
    return _adaptagrams.Compass_cardFlip(d)
Compass_cardFlip = _adaptagrams.Compass_cardFlip

def Compass_dirToString(d):
    return _adaptagrams.Compass_dirToString(d)
Compass_dirToString = _adaptagrams.Compass_dirToString

def Compass_cardToString(d):
    return _adaptagrams.Compass_cardToString(d)
Compass_cardToString = _adaptagrams.Compass_cardToString

def Compass_cardinalComponents(d):
    return _adaptagrams.Compass_cardinalComponents(d)
Compass_cardinalComponents = _adaptagrams.Compass_cardinalComponents

def Compass_getRotationFunction(fromDir, toDir):
    return _adaptagrams.Compass_getRotationFunction(fromDir, toDir)
Compass_getRotationFunction = _adaptagrams.Compass_getRotationFunction

def Compass_getInplaceRotationFunction(fromDir, toDir):
    return _adaptagrams.Compass_getInplaceRotationFunction(fromDir, toDir)
Compass_getInplaceRotationFunction = _adaptagrams.Compass_getInplaceRotationFunction

def Compass_vectorSigns(d):
    return _adaptagrams.Compass_vectorSigns(d)
Compass_vectorSigns = _adaptagrams.Compass_vectorSigns
Compass.cwCards = _adaptagrams.cvar.Compass_cwCards
Compass.acwCards = _adaptagrams.cvar.Compass_acwCards
Compass.cwAllDoubled = _adaptagrams.cvar.Compass_cwAllDoubled
Compass.acwAllDoubled = _adaptagrams.cvar.Compass_acwAllDoubled
Compass.vertical = _adaptagrams.cvar.Compass_vertical
Compass.horizontal = _adaptagrams.cvar.Compass_horizontal
Compass.libavoidConnDirs = _adaptagrams.cvar.Compass_libavoidConnDirs
Compass.rotateCw90 = _adaptagrams.cvar.Compass_rotateCw90
Compass.flip = _adaptagrams.cvar.Compass_flip
Compass.varDim = _adaptagrams.cvar.Compass_varDim
Compass.constDim = _adaptagrams.cvar.Compass_constDim

class LineSegment(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LineSegment, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LineSegment, name)
    __repr__ = _swig_repr

    def __init__(self, p0, p1):
        this = _adaptagrams.new_LineSegment(p0, p1)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getConstCoord(self):
        return _adaptagrams.LineSegment_getConstCoord(self)

    def closedIntervalIntersects(self, a, b):
        return _adaptagrams.LineSegment_closedIntervalIntersects(self, a, b)

    def openIntervalIntersects(self, a, b):
        return _adaptagrams.LineSegment_openIntervalIntersects(self, a, b)

    def closedIntervalIncludesCoord(self, a):
        return _adaptagrams.LineSegment_closedIntervalIncludesCoord(self, a)

    def openIntervalIncludesCoord(self, a):
        return _adaptagrams.LineSegment_openIntervalIncludesCoord(self, a)

    def closedIntervalIntersection(self, a, b):
        return _adaptagrams.LineSegment_closedIntervalIntersection(self, a, b)

    def openIntervalIntersection(self, a, b):
        return _adaptagrams.LineSegment_openIntervalIntersection(self, a, b)

    def ptOnWhichSide(self, p):
        return _adaptagrams.LineSegment_ptOnWhichSide(self, p)

    def coordOnWhichSide(self, z1):
        return _adaptagrams.LineSegment_coordOnWhichSide(self, z1)
    __swig_setmethods__["p0"] = _adaptagrams.LineSegment_p0_set
    __swig_getmethods__["p0"] = _adaptagrams.LineSegment_p0_get
    if _newclass:
        p0 = _swig_property(_adaptagrams.LineSegment_p0_get, _adaptagrams.LineSegment_p0_set)
    __swig_setmethods__["p1"] = _adaptagrams.LineSegment_p1_set
    __swig_getmethods__["p1"] = _adaptagrams.LineSegment_p1_get
    if _newclass:
        p1 = _swig_property(_adaptagrams.LineSegment_p1_get, _adaptagrams.LineSegment_p1_set)
    __swig_setmethods__["x0"] = _adaptagrams.LineSegment_x0_set
    __swig_getmethods__["x0"] = _adaptagrams.LineSegment_x0_get
    if _newclass:
        x0 = _swig_property(_adaptagrams.LineSegment_x0_get, _adaptagrams.LineSegment_x0_set)
    __swig_setmethods__["y0"] = _adaptagrams.LineSegment_y0_set
    __swig_getmethods__["y0"] = _adaptagrams.LineSegment_y0_get
    if _newclass:
        y0 = _swig_property(_adaptagrams.LineSegment_y0_get, _adaptagrams.LineSegment_y0_set)
    __swig_setmethods__["x1"] = _adaptagrams.LineSegment_x1_set
    __swig_getmethods__["x1"] = _adaptagrams.LineSegment_x1_get
    if _newclass:
        x1 = _swig_property(_adaptagrams.LineSegment_x1_get, _adaptagrams.LineSegment_x1_set)
    __swig_setmethods__["y1"] = _adaptagrams.LineSegment_y1_set
    __swig_getmethods__["y1"] = _adaptagrams.LineSegment_y1_get
    if _newclass:
        y1 = _swig_property(_adaptagrams.LineSegment_y1_get, _adaptagrams.LineSegment_y1_set)
    __swig_setmethods__["direc"] = _adaptagrams.LineSegment_direc_set
    __swig_getmethods__["direc"] = _adaptagrams.LineSegment_direc_get
    if _newclass:
        direc = _swig_property(_adaptagrams.LineSegment_direc_get, _adaptagrams.LineSegment_direc_set)
    __swig_setmethods__["varDim"] = _adaptagrams.LineSegment_varDim_set
    __swig_getmethods__["varDim"] = _adaptagrams.LineSegment_varDim_get
    if _newclass:
        varDim = _swig_property(_adaptagrams.LineSegment_varDim_get, _adaptagrams.LineSegment_varDim_set)
    __swig_setmethods__["constDim"] = _adaptagrams.LineSegment_constDim_set
    __swig_getmethods__["constDim"] = _adaptagrams.LineSegment_constDim_get
    if _newclass:
        constDim = _swig_property(_adaptagrams.LineSegment_constDim_get, _adaptagrams.LineSegment_constDim_set)
    __swig_setmethods__["z"] = _adaptagrams.LineSegment_z_set
    __swig_getmethods__["z"] = _adaptagrams.LineSegment_z_get
    if _newclass:
        z = _swig_property(_adaptagrams.LineSegment_z_get, _adaptagrams.LineSegment_z_set)
    __swig_setmethods__["w0"] = _adaptagrams.LineSegment_w0_set
    __swig_getmethods__["w0"] = _adaptagrams.LineSegment_w0_get
    if _newclass:
        w0 = _swig_property(_adaptagrams.LineSegment_w0_get, _adaptagrams.LineSegment_w0_set)
    __swig_setmethods__["w1"] = _adaptagrams.LineSegment_w1_set
    __swig_getmethods__["w1"] = _adaptagrams.LineSegment_w1_get
    if _newclass:
        w1 = _swig_property(_adaptagrams.LineSegment_w1_get, _adaptagrams.LineSegment_w1_set)
    __swig_setmethods__["wl"] = _adaptagrams.LineSegment_wl_set
    __swig_getmethods__["wl"] = _adaptagrams.LineSegment_wl_get
    if _newclass:
        wl = _swig_property(_adaptagrams.LineSegment_wl_get, _adaptagrams.LineSegment_wl_set)
    __swig_setmethods__["wh"] = _adaptagrams.LineSegment_wh_set
    __swig_getmethods__["wh"] = _adaptagrams.LineSegment_wh_get
    if _newclass:
        wh = _swig_property(_adaptagrams.LineSegment_wh_get, _adaptagrams.LineSegment_wh_set)
    __swig_setmethods__["length"] = _adaptagrams.LineSegment_length_set
    __swig_getmethods__["length"] = _adaptagrams.LineSegment_length_get
    if _newclass:
        length = _swig_property(_adaptagrams.LineSegment_length_get, _adaptagrams.LineSegment_length_set)
    __swig_destroy__ = _adaptagrams.delete_LineSegment
    __del__ = lambda self: None
LineSegment_swigregister = _adaptagrams.LineSegment_swigregister
LineSegment_swigregister(LineSegment)
LineSegment.EPSILON = _adaptagrams.cvar.LineSegment_EPSILON

class PeeledNode(GhostNode):
    __swig_setmethods__ = {}
    for _s in [GhostNode]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PeeledNode, name, value)
    __swig_getmethods__ = {}
    for _s in [GhostNode]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PeeledNode, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    if _newclass:
        allocate = staticmethod(_adaptagrams.PeeledNode_allocate)
    else:
        allocate = _adaptagrams.PeeledNode_allocate
    __swig_destroy__ = _adaptagrams.delete_PeeledNode
    __del__ = lambda self: None
PeeledNode_swigregister = _adaptagrams.PeeledNode_swigregister
PeeledNode_swigregister(PeeledNode)

def PeeledNode_allocate(node):
    return _adaptagrams.PeeledNode_allocate(node)
PeeledNode_allocate = _adaptagrams.PeeledNode_allocate

class Stem(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Stem, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Stem, name)
    __repr__ = _swig_repr

    def __init__(self, leaf, root):
        this = _adaptagrams.new_Stem(leaf, root)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["m_plain_leaf"] = _adaptagrams.Stem_m_plain_leaf_set
    __swig_getmethods__["m_plain_leaf"] = _adaptagrams.Stem_m_plain_leaf_get
    if _newclass:
        m_plain_leaf = _swig_property(_adaptagrams.Stem_m_plain_leaf_get, _adaptagrams.Stem_m_plain_leaf_set)
    __swig_setmethods__["m_plain_root"] = _adaptagrams.Stem_m_plain_root_set
    __swig_getmethods__["m_plain_root"] = _adaptagrams.Stem_m_plain_root_get
    if _newclass:
        m_plain_root = _swig_property(_adaptagrams.Stem_m_plain_root_get, _adaptagrams.Stem_m_plain_root_set)

    def addSelfToGraph(self, H):
        return _adaptagrams.Stem_addSelfToGraph(self, H)
    __swig_destroy__ = _adaptagrams.delete_Stem
    __del__ = lambda self: None
Stem_swigregister = _adaptagrams.Stem_swigregister
Stem_swigregister(Stem)


def makeStemsFromLeaves(leaves):
    return _adaptagrams.makeStemsFromLeaves(leaves)
makeStemsFromLeaves = _adaptagrams.makeStemsFromLeaves
class NodeBuckets(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, NodeBuckets, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, NodeBuckets, name)
    __repr__ = _swig_repr

    def __init__(self, graph):
        this = _adaptagrams.new_NodeBuckets(graph)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def takeLeaves(self):
        return _adaptagrams.NodeBuckets_takeLeaves(self)

    def moveNode(self, id, oldDegree, newDegree):
        return _adaptagrams.NodeBuckets_moveNode(self, id, oldDegree, newDegree)

    def severNodes(self, nodes):
        return _adaptagrams.NodeBuckets_severNodes(self, nodes)
    __swig_setmethods__["m_graph"] = _adaptagrams.NodeBuckets_m_graph_set
    __swig_getmethods__["m_graph"] = _adaptagrams.NodeBuckets_m_graph_get
    if _newclass:
        m_graph = _swig_property(_adaptagrams.NodeBuckets_m_graph_get, _adaptagrams.NodeBuckets_m_graph_set)
    __swig_setmethods__["m_maxDegree"] = _adaptagrams.NodeBuckets_m_maxDegree_set
    __swig_getmethods__["m_maxDegree"] = _adaptagrams.NodeBuckets_m_maxDegree_get
    if _newclass:
        m_maxDegree = _swig_property(_adaptagrams.NodeBuckets_m_maxDegree_get, _adaptagrams.NodeBuckets_m_maxDegree_set)
    __swig_setmethods__["m_buckets"] = _adaptagrams.NodeBuckets_m_buckets_set
    __swig_getmethods__["m_buckets"] = _adaptagrams.NodeBuckets_m_buckets_get
    if _newclass:
        m_buckets = _swig_property(_adaptagrams.NodeBuckets_m_buckets_get, _adaptagrams.NodeBuckets_m_buckets_set)
    __swig_destroy__ = _adaptagrams.delete_NodeBuckets
    __del__ = lambda self: None
NodeBuckets_swigregister = _adaptagrams.NodeBuckets_swigregister
NodeBuckets_swigregister(NodeBuckets)


def peel(G):
    return _adaptagrams.peel(G)
peel = _adaptagrams.peel
class EdgeSegment(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, EdgeSegment, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, EdgeSegment, name)
    __repr__ = _swig_repr

    def __init__(self, node1, node2):
        this = _adaptagrams.new_EdgeSegment(node1, node2)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def setNewClosingNode(self, u):
        return _adaptagrams.EdgeSegment_setNewClosingNode(self, u)

    def getEvents(self):
        return _adaptagrams.EdgeSegment_getEvents(self)

    def addSep(self, m):
        return _adaptagrams.EdgeSegment_addSep(self, m)
    __swig_setmethods__["orientation"] = _adaptagrams.EdgeSegment_orientation_set
    __swig_getmethods__["orientation"] = _adaptagrams.EdgeSegment_orientation_get
    if _newclass:
        orientation = _swig_property(_adaptagrams.EdgeSegment_orientation_get, _adaptagrams.EdgeSegment_orientation_set)
    __swig_setmethods__["constCoord"] = _adaptagrams.EdgeSegment_constCoord_set
    __swig_getmethods__["constCoord"] = _adaptagrams.EdgeSegment_constCoord_get
    if _newclass:
        constCoord = _swig_property(_adaptagrams.EdgeSegment_constCoord_get, _adaptagrams.EdgeSegment_constCoord_set)
    __swig_setmethods__["lowerBound"] = _adaptagrams.EdgeSegment_lowerBound_set
    __swig_getmethods__["lowerBound"] = _adaptagrams.EdgeSegment_lowerBound_get
    if _newclass:
        lowerBound = _swig_property(_adaptagrams.EdgeSegment_lowerBound_get, _adaptagrams.EdgeSegment_lowerBound_set)
    __swig_setmethods__["upperBound"] = _adaptagrams.EdgeSegment_upperBound_set
    __swig_getmethods__["upperBound"] = _adaptagrams.EdgeSegment_upperBound_get
    if _newclass:
        upperBound = _swig_property(_adaptagrams.EdgeSegment_upperBound_get, _adaptagrams.EdgeSegment_upperBound_set)
    __swig_setmethods__["openingNode"] = _adaptagrams.EdgeSegment_openingNode_set
    __swig_getmethods__["openingNode"] = _adaptagrams.EdgeSegment_openingNode_get
    if _newclass:
        openingNode = _swig_property(_adaptagrams.EdgeSegment_openingNode_get, _adaptagrams.EdgeSegment_openingNode_set)
    __swig_setmethods__["closingNode"] = _adaptagrams.EdgeSegment_closingNode_set
    __swig_getmethods__["closingNode"] = _adaptagrams.EdgeSegment_closingNode_get
    if _newclass:
        closingNode = _swig_property(_adaptagrams.EdgeSegment_closingNode_get, _adaptagrams.EdgeSegment_closingNode_set)
    __swig_destroy__ = _adaptagrams.delete_EdgeSegment
    __del__ = lambda self: None
EdgeSegment_swigregister = _adaptagrams.EdgeSegment_swigregister
EdgeSegment_swigregister(EdgeSegment)

EventType_CLOSE = _adaptagrams.EventType_CLOSE
EventType_SUSTAIN = _adaptagrams.EventType_SUSTAIN
EventType_OPEN = _adaptagrams.EventType_OPEN
class Event(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Event, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Event, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _adaptagrams.new_Event(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getNode(self):
        return _adaptagrams.Event_getNode(self)
    __swig_setmethods__["seg"] = _adaptagrams.Event_seg_set
    __swig_getmethods__["seg"] = _adaptagrams.Event_seg_get
    if _newclass:
        seg = _swig_property(_adaptagrams.Event_seg_get, _adaptagrams.Event_seg_set)
    __swig_setmethods__["endpt"] = _adaptagrams.Event_endpt_set
    __swig_getmethods__["endpt"] = _adaptagrams.Event_endpt_get
    if _newclass:
        endpt = _swig_property(_adaptagrams.Event_endpt_get, _adaptagrams.Event_endpt_set)
    __swig_setmethods__["constCoord"] = _adaptagrams.Event_constCoord_set
    __swig_getmethods__["constCoord"] = _adaptagrams.Event_constCoord_get
    if _newclass:
        constCoord = _swig_property(_adaptagrams.Event_constCoord_get, _adaptagrams.Event_constCoord_set)
    __swig_setmethods__["varCoord"] = _adaptagrams.Event_varCoord_set
    __swig_getmethods__["varCoord"] = _adaptagrams.Event_varCoord_get
    if _newclass:
        varCoord = _swig_property(_adaptagrams.Event_varCoord_get, _adaptagrams.Event_varCoord_set)
    __swig_setmethods__["type"] = _adaptagrams.Event_type_set
    __swig_getmethods__["type"] = _adaptagrams.Event_type_get
    if _newclass:
        type = _swig_property(_adaptagrams.Event_type_get, _adaptagrams.Event_type_set)
    __swig_setmethods__["companion"] = _adaptagrams.Event_companion_set
    __swig_getmethods__["companion"] = _adaptagrams.Event_companion_get
    if _newclass:
        companion = _swig_property(_adaptagrams.Event_companion_get, _adaptagrams.Event_companion_set)

    def x(self):
        return _adaptagrams.Event_x(self)

    def y(self):
        return _adaptagrams.Event_y(self)
    __swig_destroy__ = _adaptagrams.delete_Event
    __del__ = lambda self: None
Event_swigregister = _adaptagrams.Event_swigregister
Event_swigregister(Event)


def CompareActiveEvents(a, b):
    return _adaptagrams.CompareActiveEvents(a, b)
CompareActiveEvents = _adaptagrams.CompareActiveEvents
class OrthoPlanariserOptions(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OrthoPlanariserOptions, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OrthoPlanariserOptions, name)
    __repr__ = _swig_repr
    __swig_setmethods__["generateConstraints"] = _adaptagrams.OrthoPlanariserOptions_generateConstraints_set
    __swig_getmethods__["generateConstraints"] = _adaptagrams.OrthoPlanariserOptions_generateConstraints_get
    if _newclass:
        generateConstraints = _swig_property(_adaptagrams.OrthoPlanariserOptions_generateConstraints_get, _adaptagrams.OrthoPlanariserOptions_generateConstraints_set)

    def __init__(self):
        this = _adaptagrams.new_OrthoPlanariserOptions()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _adaptagrams.delete_OrthoPlanariserOptions
    __del__ = lambda self: None
OrthoPlanariserOptions_swigregister = _adaptagrams.OrthoPlanariserOptions_swigregister
OrthoPlanariserOptions_swigregister(OrthoPlanariserOptions)

class OrthoPlanariser(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OrthoPlanariser, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OrthoPlanariser, name)
    __repr__ = _swig_repr

    def __init__(self, G):
        this = _adaptagrams.new_OrthoPlanariser(G)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _adaptagrams.delete_OrthoPlanariser
    __del__ = lambda self: None

    def setOpts(self, opts):
        return _adaptagrams.OrthoPlanariser_setOpts(self, opts)

    def planarise(self):
        return _adaptagrams.OrthoPlanariser_planarise(self)
OrthoPlanariser_swigregister = _adaptagrams.OrthoPlanariser_swigregister
OrthoPlanariser_swigregister(OrthoPlanariser)

RouteProcessing_NONE = _adaptagrams.RouteProcessing_NONE
RouteProcessing_RECORD = _adaptagrams.RouteProcessing_RECORD
RouteProcessing_REFINE_AND_RECORD = _adaptagrams.RouteProcessing_REFINE_AND_RECORD
class RoutingAdapter(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RoutingAdapter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RoutingAdapter, name)
    __repr__ = _swig_repr

    def __init__(self, flag):
        this = _adaptagrams.new_RoutingAdapter(flag)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def addNodes(self, nodes):
        return _adaptagrams.RoutingAdapter_addNodes(self, nodes)

    def addEdges(self, edges, connDirs=None):
        return _adaptagrams.RoutingAdapter_addEdges(self, edges, connDirs)

    def route(self, *args):
        return _adaptagrams.RoutingAdapter_route(self, *args)

    def recordRoutes(self, refine=False):
        return _adaptagrams.RoutingAdapter_recordRoutes(self, refine)
    __swig_setmethods__["router"] = _adaptagrams.RoutingAdapter_router_set
    __swig_getmethods__["router"] = _adaptagrams.RoutingAdapter_router_get
    if _newclass:
        router = _swig_property(_adaptagrams.RoutingAdapter_router_get, _adaptagrams.RoutingAdapter_router_set)
    __swig_setmethods__["edges"] = _adaptagrams.RoutingAdapter_edges_set
    __swig_getmethods__["edges"] = _adaptagrams.RoutingAdapter_edges_get
    if _newclass:
        edges = _swig_property(_adaptagrams.RoutingAdapter_edges_get, _adaptagrams.RoutingAdapter_edges_set)
    __swig_setmethods__["edgeIdToConnRef"] = _adaptagrams.RoutingAdapter_edgeIdToConnRef_set
    __swig_getmethods__["edgeIdToConnRef"] = _adaptagrams.RoutingAdapter_edgeIdToConnRef_get
    if _newclass:
        edgeIdToConnRef = _swig_property(_adaptagrams.RoutingAdapter_edgeIdToConnRef_get, _adaptagrams.RoutingAdapter_edgeIdToConnRef_set)
    __swig_setmethods__["nodeIdToShapeRef"] = _adaptagrams.RoutingAdapter_nodeIdToShapeRef_set
    __swig_getmethods__["nodeIdToShapeRef"] = _adaptagrams.RoutingAdapter_nodeIdToShapeRef_get
    if _newclass:
        nodeIdToShapeRef = _swig_property(_adaptagrams.RoutingAdapter_nodeIdToShapeRef_get, _adaptagrams.RoutingAdapter_nodeIdToShapeRef_set)
    __swig_destroy__ = _adaptagrams.delete_RoutingAdapter
    __del__ = lambda self: None
RoutingAdapter_swigregister = _adaptagrams.RoutingAdapter_swigregister
RoutingAdapter_swigregister(RoutingAdapter)

class LeaflessOrthoRouter(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LeaflessOrthoRouter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LeaflessOrthoRouter, name)
    __repr__ = _swig_repr

    def __init__(self, G, opts):
        this = _adaptagrams.new_LeaflessOrthoRouter(G, opts)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _adaptagrams.delete_LeaflessOrthoRouter
    __del__ = lambda self: None

    def route(self, logger=None):
        return _adaptagrams.LeaflessOrthoRouter_route(self, logger)

    def setShapeBufferDistanceIELScalar(self, a):
        return _adaptagrams.LeaflessOrthoRouter_setShapeBufferDistanceIELScalar(self, a)
    __swig_setmethods__["recordEachAttempt"] = _adaptagrams.LeaflessOrthoRouter_recordEachAttempt_set
    __swig_getmethods__["recordEachAttempt"] = _adaptagrams.LeaflessOrthoRouter_recordEachAttempt_get
    if _newclass:
        recordEachAttempt = _swig_property(_adaptagrams.LeaflessOrthoRouter_recordEachAttempt_get, _adaptagrams.LeaflessOrthoRouter_recordEachAttempt_set)
    __swig_setmethods__["routingAttemptTglf"] = _adaptagrams.LeaflessOrthoRouter_routingAttemptTglf_set
    __swig_getmethods__["routingAttemptTglf"] = _adaptagrams.LeaflessOrthoRouter_routingAttemptTglf_get
    if _newclass:
        routingAttemptTglf = _swig_property(_adaptagrams.LeaflessOrthoRouter_routingAttemptTglf_get, _adaptagrams.LeaflessOrthoRouter_routingAttemptTglf_set)
LeaflessOrthoRouter_swigregister = _adaptagrams.LeaflessOrthoRouter_swigregister
LeaflessOrthoRouter_swigregister(LeaflessOrthoRouter)


def reattachTrees(core, trees, opts, logger=None):
    return _adaptagrams.reattachTrees(core, trees, opts, logger)
reattachTrees = _adaptagrams.reattachTrees

def chooseBestPlacement(tps, opts):
    return _adaptagrams.chooseBestPlacement(tps, opts)
chooseBestPlacement = _adaptagrams.chooseBestPlacement
class TreePlacement(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TreePlacement, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TreePlacement, name)
    __repr__ = _swig_repr

    def __init__(self, tree, face, faceRoot, dp, dg, flip=False):
        this = _adaptagrams.new_TreePlacement(tree, face, faceRoot, dp, dg, flip)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getPlacementDir(self):
        return _adaptagrams.TreePlacement_getPlacementDir(self)

    def getGrowthDir(self):
        return _adaptagrams.TreePlacement_getGrowthDir(self)

    def isExternal(self):
        return _adaptagrams.TreePlacement_isExternal(self)

    def id(self):
        return _adaptagrams.TreePlacement_id(self)

    def getNumPotentialNbrs(self):
        return _adaptagrams.TreePlacement_getNumPotentialNbrs(self)

    def estimateCost(self):
        return _adaptagrams.TreePlacement_estimateCost(self)

    def getRootNode(self):
        return _adaptagrams.TreePlacement_getRootNode(self)

    def getFace(self):
        return _adaptagrams.TreePlacement_getFace(self)

    def insertTreeNode(self, padding=0):
        return _adaptagrams.TreePlacement_insertTreeNode(self, padding)

    def toString(self):
        return _adaptagrams.TreePlacement_toString(self)

    def buildTreeBox(self, padding=0):
        return _adaptagrams.TreePlacement_buildTreeBox(self, padding)

    def recordBoxNode(self, boxNode):
        return _adaptagrams.TreePlacement_recordBoxNode(self, boxNode)

    def hasBoxNode(self):
        return _adaptagrams.TreePlacement_hasBoxNode(self)

    def getBoxNode(self):
        return _adaptagrams.TreePlacement_getBoxNode(self)

    def buildBestProjSeq(self, *args):
        return _adaptagrams.TreePlacement_buildBestProjSeq(self, *args)

    def somePointOppositeSegment(self, seg, pt, padding=-1, openInterval=False):
        return _adaptagrams.TreePlacement_somePointOppositeSegment(self, seg, pt, padding, openInterval)

    def applyGeometryToTree(self):
        return _adaptagrams.TreePlacement_applyGeometryToTree(self)

    def insertTreeIntoGraph(self, G, treeNodes, bufferNodes, treeEdges):
        return _adaptagrams.TreePlacement_insertTreeIntoGraph(self, G, treeNodes, bufferNodes, treeEdges)

    def size(self):
        return _adaptagrams.TreePlacement_size(self)

    def setRootAligns(self, dim, idSet):
        return _adaptagrams.TreePlacement_setRootAligns(self, dim, idSet)

    def rootIsAlignedWith(self, dim, id):
        return _adaptagrams.TreePlacement_rootIsAlignedWith(self, dim, id)
    __swig_destroy__ = _adaptagrams.delete_TreePlacement
    __del__ = lambda self: None
TreePlacement_swigregister = _adaptagrams.TreePlacement_swigregister
TreePlacement_swigregister(TreePlacement)

class Tree(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Tree, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Tree, name)
    __repr__ = _swig_repr

    def __init__(self, G, root):
        this = _adaptagrams.new_Tree(G, root)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def symmetricLayout(self, growthDir, nodeSep, rankSep, convexOrdering=True):
        return _adaptagrams.Tree_symmetricLayout(self, growthDir, nodeSep, rankSep, convexOrdering)

    def flip(self):
        return _adaptagrams.Tree_flip(self)

    def translate(self, vect):
        return _adaptagrams.Tree_translate(self, vect)

    def rotate(self, dg):
        return _adaptagrams.Tree_rotate(self, dg)

    def rotateGrowthDirCW(self, quarterTurns):
        return _adaptagrams.Tree_rotateGrowthDirCW(self, quarterTurns)

    def underlyingGraph(self):
        return _adaptagrams.Tree_underlyingGraph(self)

    def getRootNode(self):
        return _adaptagrams.Tree_getRootNode(self)

    def repr(self):
        return _adaptagrams.Tree_repr(self)

    def getRootNodeID(self):
        return _adaptagrams.Tree_getRootNodeID(self)

    def isSymmetrical(self):
        return _adaptagrams.Tree_isSymmetrical(self)

    def buildRootlessBox(self, growthDir):
        return _adaptagrams.Tree_buildRootlessBox(self, growthDir)

    def size(self):
        return _adaptagrams.Tree_size(self)

    def addNetworkToRoutingAdapter(self, ra, trt, core=0):
        return _adaptagrams.Tree_addNetworkToRoutingAdapter(self, ra, trt, core)

    def addNetwork(self, G, treeNodes, treeEdges):
        return _adaptagrams.Tree_addNetwork(self, G, treeNodes, treeEdges)

    def addConstraints(self, G, alignRoot):
        return _adaptagrams.Tree_addConstraints(self, G, alignRoot)

    def addBufferNodesAndConstraints(self, G, bufferNodes):
        return _adaptagrams.Tree_addBufferNodesAndConstraints(self, G, bufferNodes)
    __swig_destroy__ = _adaptagrams.delete_Tree
    __del__ = lambda self: None
Tree_swigregister = _adaptagrams.Tree_swigregister
Tree_swigregister(Tree)

# This file is compatible with both classic and new-style classes.


